/* automatically generated by rust-bindgen */

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl <T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self { __BindgenUnionField(::std::marker::PhantomData) }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T { ::std::mem::transmute(self) }
}
impl <T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self { Self::new() }
}
impl <T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::std::marker::Copy for __BindgenUnionField<T> { }
impl <T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
pub const _STDIO_H: ::std::os::raw::c_uint = 1;
pub const _FEATURES_H: ::std::os::raw::c_uint = 1;
pub const _DEFAULT_SOURCE: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC11: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC99: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC95: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX_IMPLICITLY: ::std::os::raw::c_uint = 1;
pub const _POSIX_SOURCE: ::std::os::raw::c_uint = 1;
pub const _POSIX_C_SOURCE: ::std::os::raw::c_uint = 200809;
pub const __USE_POSIX: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX2: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX199309: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX199506: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2K: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2K8: ::std::os::raw::c_uint = 1;
pub const _ATFILE_SOURCE: ::std::os::raw::c_uint = 1;
pub const __USE_MISC: ::std::os::raw::c_uint = 1;
pub const __USE_ATFILE: ::std::os::raw::c_uint = 1;
pub const __USE_FORTIFY_LEVEL: ::std::os::raw::c_uint = 0;
pub const _STDC_PREDEF_H: ::std::os::raw::c_uint = 1;
pub const __STDC_IEC_559__: ::std::os::raw::c_uint = 1;
pub const __STDC_IEC_559_COMPLEX__: ::std::os::raw::c_uint = 1;
pub const __STDC_ISO_10646__: ::std::os::raw::c_uint = 201304;
pub const __STDC_NO_THREADS__: ::std::os::raw::c_uint = 1;
pub const __GNU_LIBRARY__: ::std::os::raw::c_uint = 6;
pub const __GLIBC__: ::std::os::raw::c_uint = 2;
pub const __GLIBC_MINOR__: ::std::os::raw::c_uint = 22;
pub const _SYS_CDEFS_H: ::std::os::raw::c_uint = 1;
pub const __WORDSIZE: ::std::os::raw::c_uint = 64;
pub const __WORDSIZE_TIME64_COMPAT32: ::std::os::raw::c_uint = 1;
pub const __SYSCALL_WORDSIZE: ::std::os::raw::c_uint = 64;
pub const _BITS_TYPES_H: ::std::os::raw::c_uint = 1;
pub const _BITS_TYPESIZES_H: ::std::os::raw::c_uint = 1;
pub const __OFF_T_MATCHES_OFF64_T: ::std::os::raw::c_uint = 1;
pub const __INO_T_MATCHES_INO64_T: ::std::os::raw::c_uint = 1;
pub const __FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const __FILE_defined: ::std::os::raw::c_uint = 1;
pub const ____FILE_defined: ::std::os::raw::c_uint = 1;
pub const _G_config_h: ::std::os::raw::c_uint = 1;
pub const ____mbstate_t_defined: ::std::os::raw::c_uint = 1;
pub const _G_HAVE_MMAP: ::std::os::raw::c_uint = 1;
pub const _G_HAVE_MREMAP: ::std::os::raw::c_uint = 1;
pub const _G_IO_IO_FILE_VERSION: ::std::os::raw::c_uint = 131073;
pub const _G_BUFSIZ: ::std::os::raw::c_uint = 8192;
pub const _IO_BUFSIZ: ::std::os::raw::c_uint = 8192;
pub const __GNUC_VA_LIST: ::std::os::raw::c_uint = 1;
pub const _IO_UNIFIED_JUMPTABLES: ::std::os::raw::c_uint = 1;
pub const EOF: ::std::os::raw::c_int = -1;
pub const _IOS_INPUT: ::std::os::raw::c_uint = 1;
pub const _IOS_OUTPUT: ::std::os::raw::c_uint = 2;
pub const _IOS_ATEND: ::std::os::raw::c_uint = 4;
pub const _IOS_APPEND: ::std::os::raw::c_uint = 8;
pub const _IOS_TRUNC: ::std::os::raw::c_uint = 16;
pub const _IOS_NOCREATE: ::std::os::raw::c_uint = 32;
pub const _IOS_NOREPLACE: ::std::os::raw::c_uint = 64;
pub const _IOS_BIN: ::std::os::raw::c_uint = 128;
pub const _IO_MAGIC: ::std::os::raw::c_uint = 4222418944;
pub const _OLD_STDIO_MAGIC: ::std::os::raw::c_uint = 4206624768;
pub const _IO_MAGIC_MASK: ::std::os::raw::c_uint = 4294901760;
pub const _IO_USER_BUF: ::std::os::raw::c_uint = 1;
pub const _IO_UNBUFFERED: ::std::os::raw::c_uint = 2;
pub const _IO_NO_READS: ::std::os::raw::c_uint = 4;
pub const _IO_NO_WRITES: ::std::os::raw::c_uint = 8;
pub const _IO_EOF_SEEN: ::std::os::raw::c_uint = 16;
pub const _IO_ERR_SEEN: ::std::os::raw::c_uint = 32;
pub const _IO_DELETE_DONT_CLOSE: ::std::os::raw::c_uint = 64;
pub const _IO_LINKED: ::std::os::raw::c_uint = 128;
pub const _IO_IN_BACKUP: ::std::os::raw::c_uint = 256;
pub const _IO_LINE_BUF: ::std::os::raw::c_uint = 512;
pub const _IO_TIED_PUT_GET: ::std::os::raw::c_uint = 1024;
pub const _IO_CURRENTLY_PUTTING: ::std::os::raw::c_uint = 2048;
pub const _IO_IS_APPENDING: ::std::os::raw::c_uint = 4096;
pub const _IO_IS_FILEBUF: ::std::os::raw::c_uint = 8192;
pub const _IO_BAD_SEEN: ::std::os::raw::c_uint = 16384;
pub const _IO_USER_LOCK: ::std::os::raw::c_uint = 32768;
pub const _IO_FLAGS2_MMAP: ::std::os::raw::c_uint = 1;
pub const _IO_FLAGS2_NOTCANCEL: ::std::os::raw::c_uint = 2;
pub const _IO_FLAGS2_USER_WBUF: ::std::os::raw::c_uint = 8;
pub const _IO_SKIPWS: ::std::os::raw::c_uint = 1;
pub const _IO_LEFT: ::std::os::raw::c_uint = 2;
pub const _IO_RIGHT: ::std::os::raw::c_uint = 4;
pub const _IO_INTERNAL: ::std::os::raw::c_uint = 8;
pub const _IO_DEC: ::std::os::raw::c_uint = 16;
pub const _IO_OCT: ::std::os::raw::c_uint = 32;
pub const _IO_HEX: ::std::os::raw::c_uint = 64;
pub const _IO_SHOWBASE: ::std::os::raw::c_uint = 128;
pub const _IO_SHOWPOINT: ::std::os::raw::c_uint = 256;
pub const _IO_UPPERCASE: ::std::os::raw::c_uint = 512;
pub const _IO_SHOWPOS: ::std::os::raw::c_uint = 1024;
pub const _IO_SCIENTIFIC: ::std::os::raw::c_uint = 2048;
pub const _IO_FIXED: ::std::os::raw::c_uint = 4096;
pub const _IO_UNITBUF: ::std::os::raw::c_uint = 8192;
pub const _IO_STDIO: ::std::os::raw::c_uint = 16384;
pub const _IO_DONT_CLOSE: ::std::os::raw::c_uint = 32768;
pub const _IO_BOOLALPHA: ::std::os::raw::c_uint = 65536;
pub const _IOFBF: ::std::os::raw::c_uint = 0;
pub const _IOLBF: ::std::os::raw::c_uint = 1;
pub const _IONBF: ::std::os::raw::c_uint = 2;
pub const BUFSIZ: ::std::os::raw::c_uint = 8192;
pub const SEEK_SET: ::std::os::raw::c_uint = 0;
pub const SEEK_CUR: ::std::os::raw::c_uint = 1;
pub const SEEK_END: ::std::os::raw::c_uint = 2;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\x00";
pub const L_tmpnam: ::std::os::raw::c_uint = 20;
pub const TMP_MAX: ::std::os::raw::c_uint = 238328;
pub const FILENAME_MAX: ::std::os::raw::c_uint = 4096;
pub const L_ctermid: ::std::os::raw::c_uint = 9;
pub const FOPEN_MAX: ::std::os::raw::c_uint = 16;
pub const _STDINT_H: ::std::os::raw::c_uint = 1;
pub const _BITS_WCHAR_H: ::std::os::raw::c_uint = 1;
pub const INT8_MIN: ::std::os::raw::c_int = -128;
pub const INT16_MIN: ::std::os::raw::c_int = -32768;
pub const INT32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT8_MAX: ::std::os::raw::c_uint = 127;
pub const INT16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const UINT8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const INT_LEAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_LEAST16_MIN: ::std::os::raw::c_int = -32768;
pub const INT_LEAST32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_LEAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_LEAST16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT_LEAST32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const UINT_LEAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_LEAST16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT_LEAST32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const INT_FAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_FAST16_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST32_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_FAST16_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const INT_FAST32_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINT_FAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_FAST16_MAX: ::std::os::raw::c_int = -1;
pub const UINT_FAST32_MAX: ::std::os::raw::c_int = -1;
pub const INTPTR_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INTPTR_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINTPTR_MAX: ::std::os::raw::c_int = -1;
pub const PTRDIFF_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const PTRDIFF_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const SIG_ATOMIC_MIN: ::std::os::raw::c_int = -2147483648;
pub const SIG_ATOMIC_MAX: ::std::os::raw::c_uint = 2147483647;
pub const SIZE_MAX: ::std::os::raw::c_int = -1;
pub const WINT_MIN: ::std::os::raw::c_uint = 0;
pub const WINT_MAX: ::std::os::raw::c_uint = 4294967295;
pub const HEADER_IMAGE: ::std::os::raw::c_uint = 61;
pub const HEADER_SIGNATURES: ::std::os::raw::c_uint = 62;
pub const HEADER_IMMUTABLE: ::std::os::raw::c_uint = 63;
pub const HEADER_REGIONS: ::std::os::raw::c_uint = 64;
pub const HEADER_I18NTABLE: ::std::os::raw::c_uint = 100;
pub const HEADER_SIGBASE: ::std::os::raw::c_uint = 256;
pub const HEADER_TAGBASE: ::std::os::raw::c_uint = 1000;
pub const RPMTAG_EXTERNAL_TAG: ::std::os::raw::c_uint = 1000000;
pub const RPM_MIN_TYPE: ::std::os::raw::c_uint = 0;
pub const RPM_MAX_TYPE: ::std::os::raw::c_uint = 9;
pub const RPM_FORCEFREE_TYPE: ::std::os::raw::c_uint = 255;
pub const RPM_MASK_TYPE: ::std::os::raw::c_uint = 65535;
pub const _SYS_TYPES_H: ::std::os::raw::c_uint = 1;
pub const __clock_t_defined: ::std::os::raw::c_uint = 1;
pub const __time_t_defined: ::std::os::raw::c_uint = 1;
pub const __clockid_t_defined: ::std::os::raw::c_uint = 1;
pub const __timer_t_defined: ::std::os::raw::c_uint = 1;
pub const __BIT_TYPES_DEFINED__: ::std::os::raw::c_uint = 1;
pub const _ENDIAN_H: ::std::os::raw::c_uint = 1;
pub const __LITTLE_ENDIAN: ::std::os::raw::c_uint = 1234;
pub const __BIG_ENDIAN: ::std::os::raw::c_uint = 4321;
pub const __PDP_ENDIAN: ::std::os::raw::c_uint = 3412;
pub const __BYTE_ORDER: ::std::os::raw::c_uint = 1234;
pub const __FLOAT_WORD_ORDER: ::std::os::raw::c_uint = 1234;
pub const LITTLE_ENDIAN: ::std::os::raw::c_uint = 1234;
pub const BIG_ENDIAN: ::std::os::raw::c_uint = 4321;
pub const PDP_ENDIAN: ::std::os::raw::c_uint = 3412;
pub const BYTE_ORDER: ::std::os::raw::c_uint = 1234;
pub const _BITS_BYTESWAP_H: ::std::os::raw::c_uint = 1;
pub const _SYS_SELECT_H: ::std::os::raw::c_uint = 1;
pub const __FD_ZERO_STOS: &'static [u8; 6usize] = b"stosq\x00";
pub const _SIGSET_H_types: ::std::os::raw::c_uint = 1;
pub const __timespec_defined: ::std::os::raw::c_uint = 1;
pub const _STRUCT_TIMEVAL: ::std::os::raw::c_uint = 1;
pub const FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const _SYS_SYSMACROS_H: ::std::os::raw::c_uint = 1;
pub const _BITS_PTHREADTYPES_H: ::std::os::raw::c_uint = 1;
pub const __SIZEOF_PTHREAD_ATTR_T: ::std::os::raw::c_uint = 56;
pub const __SIZEOF_PTHREAD_MUTEX_T: ::std::os::raw::c_uint = 40;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: ::std::os::raw::c_uint = 4;
pub const __SIZEOF_PTHREAD_COND_T: ::std::os::raw::c_uint = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: ::std::os::raw::c_uint = 4;
pub const __SIZEOF_PTHREAD_RWLOCK_T: ::std::os::raw::c_uint = 56;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: ::std::os::raw::c_uint = 8;
pub const __SIZEOF_PTHREAD_BARRIER_T: ::std::os::raw::c_uint = 32;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: ::std::os::raw::c_uint = 4;
pub const __have_pthread_attr_t: ::std::os::raw::c_uint = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: ::std::os::raw::c_uint = 1;
pub const __PTHREAD_RWLOCK_INT_FLAGS_SHARED: ::std::os::raw::c_uint = 1;
pub const _SYS_STAT_H: ::std::os::raw::c_uint = 1;
pub const _BITS_STAT_H: ::std::os::raw::c_uint = 1;
pub const _STAT_VER_KERNEL: ::std::os::raw::c_uint = 0;
pub const _STAT_VER_LINUX: ::std::os::raw::c_uint = 1;
pub const _MKNOD_VER_LINUX: ::std::os::raw::c_uint = 0;
pub const _STAT_VER: ::std::os::raw::c_uint = 1;
pub const __S_IFMT: ::std::os::raw::c_uint = 61440;
pub const __S_IFDIR: ::std::os::raw::c_uint = 16384;
pub const __S_IFCHR: ::std::os::raw::c_uint = 8192;
pub const __S_IFBLK: ::std::os::raw::c_uint = 24576;
pub const __S_IFREG: ::std::os::raw::c_uint = 32768;
pub const __S_IFIFO: ::std::os::raw::c_uint = 4096;
pub const __S_IFLNK: ::std::os::raw::c_uint = 40960;
pub const __S_IFSOCK: ::std::os::raw::c_uint = 49152;
pub const __S_ISUID: ::std::os::raw::c_uint = 2048;
pub const __S_ISGID: ::std::os::raw::c_uint = 1024;
pub const __S_ISVTX: ::std::os::raw::c_uint = 512;
pub const __S_IREAD: ::std::os::raw::c_uint = 256;
pub const __S_IWRITE: ::std::os::raw::c_uint = 128;
pub const __S_IEXEC: ::std::os::raw::c_uint = 64;
pub const UTIME_NOW: ::std::os::raw::c_uint = 1073741823;
pub const UTIME_OMIT: ::std::os::raw::c_uint = 1073741822;
pub const S_IFMT: ::std::os::raw::c_uint = 61440;
pub const S_IFDIR: ::std::os::raw::c_uint = 16384;
pub const S_IFCHR: ::std::os::raw::c_uint = 8192;
pub const S_IFBLK: ::std::os::raw::c_uint = 24576;
pub const S_IFREG: ::std::os::raw::c_uint = 32768;
pub const S_IFIFO: ::std::os::raw::c_uint = 4096;
pub const S_IFLNK: ::std::os::raw::c_uint = 40960;
pub const S_IFSOCK: ::std::os::raw::c_uint = 49152;
pub const S_ISUID: ::std::os::raw::c_uint = 2048;
pub const S_ISGID: ::std::os::raw::c_uint = 1024;
pub const S_ISVTX: ::std::os::raw::c_uint = 512;
pub const S_IRUSR: ::std::os::raw::c_uint = 256;
pub const S_IWUSR: ::std::os::raw::c_uint = 128;
pub const S_IXUSR: ::std::os::raw::c_uint = 64;
pub const S_IRWXU: ::std::os::raw::c_uint = 448;
pub const S_IREAD: ::std::os::raw::c_uint = 256;
pub const S_IWRITE: ::std::os::raw::c_uint = 128;
pub const S_IEXEC: ::std::os::raw::c_uint = 64;
pub const S_IRGRP: ::std::os::raw::c_uint = 32;
pub const S_IWGRP: ::std::os::raw::c_uint = 16;
pub const S_IXGRP: ::std::os::raw::c_uint = 8;
pub const S_IRWXG: ::std::os::raw::c_uint = 56;
pub const S_IROTH: ::std::os::raw::c_uint = 4;
pub const S_IWOTH: ::std::os::raw::c_uint = 2;
pub const S_IXOTH: ::std::os::raw::c_uint = 1;
pub const S_IRWXO: ::std::os::raw::c_uint = 7;
pub const ACCESSPERMS: ::std::os::raw::c_uint = 511;
pub const ALLPERMS: ::std::os::raw::c_uint = 4095;
pub const DEFFILEMODE: ::std::os::raw::c_uint = 438;
pub const S_BLKSIZE: ::std::os::raw::c_uint = 512;
pub const _MKNOD_VER: ::std::os::raw::c_uint = 0;
pub const _STDLIB_H: ::std::os::raw::c_uint = 1;
pub const WNOHANG: ::std::os::raw::c_uint = 1;
pub const WUNTRACED: ::std::os::raw::c_uint = 2;
pub const WSTOPPED: ::std::os::raw::c_uint = 2;
pub const WEXITED: ::std::os::raw::c_uint = 4;
pub const WCONTINUED: ::std::os::raw::c_uint = 8;
pub const WNOWAIT: ::std::os::raw::c_uint = 16777216;
pub const __WNOTHREAD: ::std::os::raw::c_uint = 536870912;
pub const __WALL: ::std::os::raw::c_uint = 1073741824;
pub const __WCLONE: ::std::os::raw::c_uint = 2147483648;
pub const __W_CONTINUED: ::std::os::raw::c_uint = 65535;
pub const __WCOREFLAG: ::std::os::raw::c_uint = 128;
pub const __ldiv_t_defined: ::std::os::raw::c_uint = 1;
pub const __lldiv_t_defined: ::std::os::raw::c_uint = 1;
pub const RAND_MAX: ::std::os::raw::c_uint = 2147483647;
pub const EXIT_FAILURE: ::std::os::raw::c_uint = 1;
pub const EXIT_SUCCESS: ::std::os::raw::c_uint = 0;
pub const _ALLOCA_H: ::std::os::raw::c_uint = 1;
pub const _UNISTD_H: ::std::os::raw::c_uint = 1;
pub const _POSIX_VERSION: ::std::os::raw::c_uint = 200809;
pub const __POSIX2_THIS_VERSION: ::std::os::raw::c_uint = 200809;
pub const _POSIX2_VERSION: ::std::os::raw::c_uint = 200809;
pub const _POSIX2_C_VERSION: ::std::os::raw::c_uint = 200809;
pub const _POSIX2_C_BIND: ::std::os::raw::c_uint = 200809;
pub const _POSIX2_C_DEV: ::std::os::raw::c_uint = 200809;
pub const _POSIX2_SW_DEV: ::std::os::raw::c_uint = 200809;
pub const _POSIX2_LOCALEDEF: ::std::os::raw::c_uint = 200809;
pub const _XOPEN_VERSION: ::std::os::raw::c_uint = 700;
pub const _XOPEN_XCU_VERSION: ::std::os::raw::c_uint = 4;
pub const _XOPEN_XPG2: ::std::os::raw::c_uint = 1;
pub const _XOPEN_XPG3: ::std::os::raw::c_uint = 1;
pub const _XOPEN_XPG4: ::std::os::raw::c_uint = 1;
pub const _XOPEN_UNIX: ::std::os::raw::c_uint = 1;
pub const _XOPEN_CRYPT: ::std::os::raw::c_uint = 1;
pub const _XOPEN_ENH_I18N: ::std::os::raw::c_uint = 1;
pub const _XOPEN_LEGACY: ::std::os::raw::c_uint = 1;
pub const _BITS_POSIX_OPT_H: ::std::os::raw::c_uint = 1;
pub const _POSIX_JOB_CONTROL: ::std::os::raw::c_uint = 1;
pub const _POSIX_SAVED_IDS: ::std::os::raw::c_uint = 1;
pub const _POSIX_PRIORITY_SCHEDULING: ::std::os::raw::c_uint = 200809;
pub const _POSIX_SYNCHRONIZED_IO: ::std::os::raw::c_uint = 200809;
pub const _POSIX_FSYNC: ::std::os::raw::c_uint = 200809;
pub const _POSIX_MAPPED_FILES: ::std::os::raw::c_uint = 200809;
pub const _POSIX_MEMLOCK: ::std::os::raw::c_uint = 200809;
pub const _POSIX_MEMLOCK_RANGE: ::std::os::raw::c_uint = 200809;
pub const _POSIX_MEMORY_PROTECTION: ::std::os::raw::c_uint = 200809;
pub const _POSIX_CHOWN_RESTRICTED: ::std::os::raw::c_uint = 0;
pub const _POSIX_VDISABLE: u8 = b'\x00';
pub const _POSIX_NO_TRUNC: ::std::os::raw::c_uint = 1;
pub const _XOPEN_REALTIME: ::std::os::raw::c_uint = 1;
pub const _XOPEN_REALTIME_THREADS: ::std::os::raw::c_uint = 1;
pub const _XOPEN_SHM: ::std::os::raw::c_uint = 1;
pub const _POSIX_THREADS: ::std::os::raw::c_uint = 200809;
pub const _POSIX_REENTRANT_FUNCTIONS: ::std::os::raw::c_uint = 1;
pub const _POSIX_THREAD_SAFE_FUNCTIONS: ::std::os::raw::c_uint = 200809;
pub const _POSIX_THREAD_PRIORITY_SCHEDULING: ::std::os::raw::c_uint = 200809;
pub const _POSIX_THREAD_ATTR_STACKSIZE: ::std::os::raw::c_uint = 200809;
pub const _POSIX_THREAD_ATTR_STACKADDR: ::std::os::raw::c_uint = 200809;
pub const _POSIX_THREAD_PRIO_INHERIT: ::std::os::raw::c_uint = 200809;
pub const _POSIX_THREAD_PRIO_PROTECT: ::std::os::raw::c_uint = 200809;
pub const _POSIX_THREAD_ROBUST_PRIO_INHERIT: ::std::os::raw::c_uint = 200809;
pub const _POSIX_THREAD_ROBUST_PRIO_PROTECT: ::std::os::raw::c_int = -1;
pub const _POSIX_SEMAPHORES: ::std::os::raw::c_uint = 200809;
pub const _POSIX_REALTIME_SIGNALS: ::std::os::raw::c_uint = 200809;
pub const _POSIX_ASYNCHRONOUS_IO: ::std::os::raw::c_uint = 200809;
pub const _POSIX_ASYNC_IO: ::std::os::raw::c_uint = 1;
pub const _LFS_ASYNCHRONOUS_IO: ::std::os::raw::c_uint = 1;
pub const _POSIX_PRIORITIZED_IO: ::std::os::raw::c_uint = 200809;
pub const _LFS64_ASYNCHRONOUS_IO: ::std::os::raw::c_uint = 1;
pub const _LFS_LARGEFILE: ::std::os::raw::c_uint = 1;
pub const _LFS64_LARGEFILE: ::std::os::raw::c_uint = 1;
pub const _LFS64_STDIO: ::std::os::raw::c_uint = 1;
pub const _POSIX_SHARED_MEMORY_OBJECTS: ::std::os::raw::c_uint = 200809;
pub const _POSIX_CPUTIME: ::std::os::raw::c_uint = 0;
pub const _POSIX_THREAD_CPUTIME: ::std::os::raw::c_uint = 0;
pub const _POSIX_REGEXP: ::std::os::raw::c_uint = 1;
pub const _POSIX_READER_WRITER_LOCKS: ::std::os::raw::c_uint = 200809;
pub const _POSIX_SHELL: ::std::os::raw::c_uint = 1;
pub const _POSIX_TIMEOUTS: ::std::os::raw::c_uint = 200809;
pub const _POSIX_SPIN_LOCKS: ::std::os::raw::c_uint = 200809;
pub const _POSIX_SPAWN: ::std::os::raw::c_uint = 200809;
pub const _POSIX_TIMERS: ::std::os::raw::c_uint = 200809;
pub const _POSIX_BARRIERS: ::std::os::raw::c_uint = 200809;
pub const _POSIX_MESSAGE_PASSING: ::std::os::raw::c_uint = 200809;
pub const _POSIX_THREAD_PROCESS_SHARED: ::std::os::raw::c_uint = 200809;
pub const _POSIX_MONOTONIC_CLOCK: ::std::os::raw::c_uint = 0;
pub const _POSIX_CLOCK_SELECTION: ::std::os::raw::c_uint = 200809;
pub const _POSIX_ADVISORY_INFO: ::std::os::raw::c_uint = 200809;
pub const _POSIX_IPV6: ::std::os::raw::c_uint = 200809;
pub const _POSIX_RAW_SOCKETS: ::std::os::raw::c_uint = 200809;
pub const _POSIX2_CHAR_TERM: ::std::os::raw::c_uint = 200809;
pub const _POSIX_SPORADIC_SERVER: ::std::os::raw::c_int = -1;
pub const _POSIX_THREAD_SPORADIC_SERVER: ::std::os::raw::c_int = -1;
pub const _POSIX_TRACE: ::std::os::raw::c_int = -1;
pub const _POSIX_TRACE_EVENT_FILTER: ::std::os::raw::c_int = -1;
pub const _POSIX_TRACE_INHERIT: ::std::os::raw::c_int = -1;
pub const _POSIX_TRACE_LOG: ::std::os::raw::c_int = -1;
pub const _POSIX_TYPED_MEMORY_OBJECTS: ::std::os::raw::c_int = -1;
pub const _POSIX_V7_LPBIG_OFFBIG: ::std::os::raw::c_int = -1;
pub const _POSIX_V6_LPBIG_OFFBIG: ::std::os::raw::c_int = -1;
pub const _XBS5_LPBIG_OFFBIG: ::std::os::raw::c_int = -1;
pub const _POSIX_V7_LP64_OFF64: ::std::os::raw::c_uint = 1;
pub const _POSIX_V6_LP64_OFF64: ::std::os::raw::c_uint = 1;
pub const _XBS5_LP64_OFF64: ::std::os::raw::c_uint = 1;
pub const __ILP32_OFF32_CFLAGS: &'static [u8; 5usize] = b"-m32\x00";
pub const __ILP32_OFF32_LDFLAGS: &'static [u8; 5usize] = b"-m32\x00";
pub const __ILP32_OFFBIG_CFLAGS: &'static [u8; 48usize] =
    b"-m32 -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64\x00";
pub const __ILP32_OFFBIG_LDFLAGS: &'static [u8; 5usize] = b"-m32\x00";
pub const __LP64_OFF64_CFLAGS: &'static [u8; 5usize] = b"-m64\x00";
pub const __LP64_OFF64_LDFLAGS: &'static [u8; 5usize] = b"-m64\x00";
pub const STDIN_FILENO: ::std::os::raw::c_uint = 0;
pub const STDOUT_FILENO: ::std::os::raw::c_uint = 1;
pub const STDERR_FILENO: ::std::os::raw::c_uint = 2;
pub const R_OK: ::std::os::raw::c_uint = 4;
pub const W_OK: ::std::os::raw::c_uint = 2;
pub const X_OK: ::std::os::raw::c_uint = 1;
pub const F_OK: ::std::os::raw::c_uint = 0;
pub const L_SET: ::std::os::raw::c_uint = 0;
pub const L_INCR: ::std::os::raw::c_uint = 1;
pub const L_XTND: ::std::os::raw::c_uint = 2;
pub const F_ULOCK: ::std::os::raw::c_uint = 0;
pub const F_LOCK: ::std::os::raw::c_uint = 1;
pub const F_TLOCK: ::std::os::raw::c_uint = 2;
pub const F_TEST: ::std::os::raw::c_uint = 3;
pub const _SYS_TIME_H: ::std::os::raw::c_uint = 1;
pub const RPMERR_CHECK_ERRNO: ::std::os::raw::c_int = -32768;
pub const POPT_OPTION_DEPTH: ::std::os::raw::c_uint = 10;
pub const POPT_ARG_NONE: ::std::os::raw::c_uint = 0;
pub const POPT_ARG_STRING: ::std::os::raw::c_uint = 1;
pub const POPT_ARG_INT: ::std::os::raw::c_uint = 2;
pub const POPT_ARG_LONG: ::std::os::raw::c_uint = 3;
pub const POPT_ARG_INCLUDE_TABLE: ::std::os::raw::c_uint = 4;
pub const POPT_ARG_CALLBACK: ::std::os::raw::c_uint = 5;
pub const POPT_ARG_INTL_DOMAIN: ::std::os::raw::c_uint = 6;
pub const POPT_ARG_VAL: ::std::os::raw::c_uint = 7;
pub const POPT_ARG_FLOAT: ::std::os::raw::c_uint = 8;
pub const POPT_ARG_DOUBLE: ::std::os::raw::c_uint = 9;
pub const POPT_ARG_LONGLONG: ::std::os::raw::c_uint = 10;
pub const POPT_ARG_MAINCALL: ::std::os::raw::c_uint = 27;
pub const POPT_ARG_ARGV: ::std::os::raw::c_uint = 12;
pub const POPT_ARG_SHORT: ::std::os::raw::c_uint = 13;
pub const POPT_ARG_BITSET: ::std::os::raw::c_uint = 30;
pub const POPT_ARG_MASK: ::std::os::raw::c_uint = 255;
pub const POPT_GROUP_MASK: ::std::os::raw::c_uint = 65280;
pub const POPT_ARGFLAG_ONEDASH: ::std::os::raw::c_uint = 2147483648;
pub const POPT_ARGFLAG_DOC_HIDDEN: ::std::os::raw::c_uint = 1073741824;
pub const POPT_ARGFLAG_STRIP: ::std::os::raw::c_uint = 536870912;
pub const POPT_ARGFLAG_OPTIONAL: ::std::os::raw::c_uint = 268435456;
pub const POPT_ARGFLAG_OR: ::std::os::raw::c_uint = 134217728;
pub const POPT_ARGFLAG_NOR: ::std::os::raw::c_uint = 150994944;
pub const POPT_ARGFLAG_AND: ::std::os::raw::c_uint = 67108864;
pub const POPT_ARGFLAG_NAND: ::std::os::raw::c_uint = 83886080;
pub const POPT_ARGFLAG_XOR: ::std::os::raw::c_uint = 33554432;
pub const POPT_ARGFLAG_NOT: ::std::os::raw::c_uint = 16777216;
pub const POPT_ARGFLAG_LOGICALOPS: ::std::os::raw::c_uint = 234881024;
pub const POPT_BIT_SET: ::std::os::raw::c_uint = 134217735;
pub const POPT_BIT_CLR: ::std::os::raw::c_uint = 83886087;
pub const POPT_ARGFLAG_SHOW_DEFAULT: ::std::os::raw::c_uint = 8388608;
pub const POPT_ARGFLAG_RANDOM: ::std::os::raw::c_uint = 4194304;
pub const POPT_ARGFLAG_TOGGLE: ::std::os::raw::c_uint = 2097152;
pub const POPT_CBFLAG_PRE: ::std::os::raw::c_uint = 2147483648;
pub const POPT_CBFLAG_POST: ::std::os::raw::c_uint = 1073741824;
pub const POPT_CBFLAG_INC_DATA: ::std::os::raw::c_uint = 536870912;
pub const POPT_CBFLAG_SKIPOPTION: ::std::os::raw::c_uint = 268435456;
pub const POPT_CBFLAG_CONTINUE: ::std::os::raw::c_uint = 134217728;
pub const POPT_ERROR_NOARG: ::std::os::raw::c_int = -10;
pub const POPT_ERROR_BADOPT: ::std::os::raw::c_int = -11;
pub const POPT_ERROR_OPTSTOODEEP: ::std::os::raw::c_int = -13;
pub const POPT_ERROR_BADQUOTE: ::std::os::raw::c_int = -15;
pub const POPT_ERROR_ERRNO: ::std::os::raw::c_int = -16;
pub const POPT_ERROR_BADNUMBER: ::std::os::raw::c_int = -17;
pub const POPT_ERROR_OVERFLOW: ::std::os::raw::c_int = -18;
pub const POPT_ERROR_BADOPERATION: ::std::os::raw::c_int = -19;
pub const POPT_ERROR_NULLARG: ::std::os::raw::c_int = -20;
pub const POPT_ERROR_MALLOC: ::std::os::raw::c_int = -21;
pub const POPT_ERROR_BADCONFIG: ::std::os::raw::c_int = -22;
pub const POPT_BADOPTION_NOALIAS: ::std::os::raw::c_uint = 1;
pub const POPT_CONTEXT_NO_EXEC: ::std::os::raw::c_uint = 1;
pub const POPT_CONTEXT_KEEP_FIRST: ::std::os::raw::c_uint = 2;
pub const POPT_CONTEXT_POSIXMEHARDER: ::std::os::raw::c_uint = 4;
pub const POPT_CONTEXT_ARG_OPTS: ::std::os::raw::c_uint = 16;
pub const POPT_READFILE_TRIMNEWLINES: ::std::os::raw::c_uint = 1;
pub const _POPT_BITS_N: ::std::os::raw::c_uint = 1024;
pub const _POPT_BITS_M: ::std::os::raw::c_uint = 1536;
pub const _POPT_BITS_K: ::std::os::raw::c_uint = 16;
pub const _TIME_H: ::std::os::raw::c_uint = 1;
pub const _BITS_TIME_H: ::std::os::raw::c_uint = 1;
pub const CLOCK_REALTIME: ::std::os::raw::c_uint = 0;
pub const CLOCK_MONOTONIC: ::std::os::raw::c_uint = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: ::std::os::raw::c_uint = 2;
pub const CLOCK_THREAD_CPUTIME_ID: ::std::os::raw::c_uint = 3;
pub const CLOCK_MONOTONIC_RAW: ::std::os::raw::c_uint = 4;
pub const CLOCK_REALTIME_COARSE: ::std::os::raw::c_uint = 5;
pub const CLOCK_MONOTONIC_COARSE: ::std::os::raw::c_uint = 6;
pub const CLOCK_BOOTTIME: ::std::os::raw::c_uint = 7;
pub const CLOCK_REALTIME_ALARM: ::std::os::raw::c_uint = 8;
pub const CLOCK_BOOTTIME_ALARM: ::std::os::raw::c_uint = 9;
pub const CLOCK_TAI: ::std::os::raw::c_uint = 11;
pub const TIMER_ABSTIME: ::std::os::raw::c_uint = 1;
pub const TIME_UTC: ::std::os::raw::c_uint = 1;
pub const _XLOCALE_H: ::std::os::raw::c_uint = 1;
pub const RPMSENSE_SENSEMASK: ::std::os::raw::c_uint = 15;
pub const _STRING_H: ::std::os::raw::c_uint = 1;
pub const RPM_MACHTABLE_COUNT: ::std::os::raw::c_uint = 4;
pub const RMIL_DEFAULT: ::std::os::raw::c_int = -15;
pub const RMIL_MACROFILES: ::std::os::raw::c_int = -13;
pub const RMIL_RPMRC: ::std::os::raw::c_int = -11;
pub const RMIL_CMDLINE: ::std::os::raw::c_int = -7;
pub const RMIL_TARBALL: ::std::os::raw::c_int = -5;
pub const RMIL_SPEC: ::std::os::raw::c_int = -3;
pub const RMIL_OLDSPEC: ::std::os::raw::c_int = -1;
pub const RMIL_GLOBAL: ::std::os::raw::c_uint = 0;
pub const RPMFILEITERMAX: ::std::os::raw::c_uint = 6;
pub const RPMTRANS_FLAG_NOPAYLOAD: ::std::os::raw::c_uint = 0;
pub const RPMTRANS_FLAG_APPLYONLY: ::std::os::raw::c_uint = 0;
pub const RPMTRANS_FLAG_KEEPOBSOLETE: ::std::os::raw::c_uint = 0;
pub const RPMTRANS_FLAG_DIRSTASH: ::std::os::raw::c_uint = 0;
pub const RPMTRANS_FLAG_REPACKAGE: ::std::os::raw::c_uint = 0;
pub const RPMTRANS_FLAG_PKGCOMMIT: ::std::os::raw::c_uint = 0;
pub const RPMTRANS_FLAG_PKGUNDO: ::std::os::raw::c_uint = 0;
pub const RPMTRANS_FLAG_COMMIT: ::std::os::raw::c_uint = 0;
pub const RPMTRANS_FLAG_UNDO: ::std::os::raw::c_uint = 0;
pub const RPMTRANS_FLAG_REVERSE: ::std::os::raw::c_uint = 0;
pub const RPMTRANS_FLAG_NOSUGGEST: ::std::os::raw::c_uint = 0;
pub const RPMTRANS_FLAG_ADDINDEPS: ::std::os::raw::c_uint = 0;
pub const RPMCLI_POPT_NODEPS: ::std::os::raw::c_int = -1025;
pub const RPMCLI_POPT_FORCE: ::std::os::raw::c_int = -1026;
pub const RPMCLI_POPT_NOMD5: ::std::os::raw::c_int = -1027;
pub const RPMCLI_POPT_NOFILEDIGEST: ::std::os::raw::c_int = -1027;
pub const RPMCLI_POPT_NOSCRIPTS: ::std::os::raw::c_int = -1028;
pub const RPMCLI_POPT_NOSIGNATURE: ::std::os::raw::c_int = -1029;
pub const RPMCLI_POPT_NODIGEST: ::std::os::raw::c_int = -1030;
pub const RPMCLI_POPT_NOHDRCHK: ::std::os::raw::c_int = -1031;
pub const RPMCLI_POPT_NOCONTEXTS: ::std::os::raw::c_int = -1032;
pub const RPMBUILD_DEFAULT_LANG: &'static [u8; 2usize] = b"C\x00";
pub const H_RPMLOG: ::std::os::raw::c_uint = 1;
pub const RPMLOG_PRIMASK: ::std::os::raw::c_uint = 7;
pub const RPMLOG_NFACILITIES: ::std::os::raw::c_uint = 24;
pub const RPMLOG_FACMASK: ::std::os::raw::c_uint = 1016;
pub const RPMLOG_PID: ::std::os::raw::c_uint = 1;
pub const RPMLOG_CONS: ::std::os::raw::c_uint = 2;
pub const RPMLOG_ODELAY: ::std::os::raw::c_uint = 4;
pub const RPMLOG_NDELAY: ::std::os::raw::c_uint = 8;
pub const RPMLOG_NOWAIT: ::std::os::raw::c_uint = 16;
pub const RPMLOG_PERROR: ::std::os::raw::c_uint = 32;
pub const RPMLOG_DEFAULT: ::std::os::raw::c_uint = 1;
pub const RPMLOG_EXIT: ::std::os::raw::c_uint = 2;
pub const RPMPOL_TYPE_DEFAULT: &'static [u8; 8usize] = b"default\x00";
pub const _SIGSET_H_fns: ::std::os::raw::c_uint = 1;
pub const SIGHUP: ::std::os::raw::c_uint = 1;
pub const SIGINT: ::std::os::raw::c_uint = 2;
pub const SIGQUIT: ::std::os::raw::c_uint = 3;
pub const SIGILL: ::std::os::raw::c_uint = 4;
pub const SIGTRAP: ::std::os::raw::c_uint = 5;
pub const SIGABRT: ::std::os::raw::c_uint = 6;
pub const SIGIOT: ::std::os::raw::c_uint = 6;
pub const SIGBUS: ::std::os::raw::c_uint = 7;
pub const SIGFPE: ::std::os::raw::c_uint = 8;
pub const SIGKILL: ::std::os::raw::c_uint = 9;
pub const SIGUSR1: ::std::os::raw::c_uint = 10;
pub const SIGSEGV: ::std::os::raw::c_uint = 11;
pub const SIGUSR2: ::std::os::raw::c_uint = 12;
pub const SIGPIPE: ::std::os::raw::c_uint = 13;
pub const SIGALRM: ::std::os::raw::c_uint = 14;
pub const SIGTERM: ::std::os::raw::c_uint = 15;
pub const SIGSTKFLT: ::std::os::raw::c_uint = 16;
pub const SIGCHLD: ::std::os::raw::c_uint = 17;
pub const SIGCONT: ::std::os::raw::c_uint = 18;
pub const SIGSTOP: ::std::os::raw::c_uint = 19;
pub const SIGTSTP: ::std::os::raw::c_uint = 20;
pub const SIGTTIN: ::std::os::raw::c_uint = 21;
pub const SIGTTOU: ::std::os::raw::c_uint = 22;
pub const SIGURG: ::std::os::raw::c_uint = 23;
pub const SIGXCPU: ::std::os::raw::c_uint = 24;
pub const SIGXFSZ: ::std::os::raw::c_uint = 25;
pub const SIGVTALRM: ::std::os::raw::c_uint = 26;
pub const SIGPROF: ::std::os::raw::c_uint = 27;
pub const SIGWINCH: ::std::os::raw::c_uint = 28;
pub const SIGIO: ::std::os::raw::c_uint = 29;
pub const SIGPWR: ::std::os::raw::c_uint = 30;
pub const SIGSYS: ::std::os::raw::c_uint = 31;
pub const SIGUNUSED: ::std::os::raw::c_uint = 31;
pub const _NSIG: ::std::os::raw::c_uint = 65;
pub const __SIGRTMIN: ::std::os::raw::c_uint = 32;
pub const __SIGRTMAX: ::std::os::raw::c_uint = 64;
pub const __have_sigval_t: ::std::os::raw::c_uint = 1;
pub const __have_siginfo_t: ::std::os::raw::c_uint = 1;
pub const __SI_MAX_SIZE: ::std::os::raw::c_uint = 128;
pub const __have_sigevent_t: ::std::os::raw::c_uint = 1;
pub const __SIGEV_MAX_SIZE: ::std::os::raw::c_uint = 64;
pub const NSIG: ::std::os::raw::c_uint = 65;
pub const SA_NOCLDSTOP: ::std::os::raw::c_uint = 1;
pub const SA_NOCLDWAIT: ::std::os::raw::c_uint = 2;
pub const SA_SIGINFO: ::std::os::raw::c_uint = 4;
pub const SA_ONSTACK: ::std::os::raw::c_uint = 134217728;
pub const SA_RESTART: ::std::os::raw::c_uint = 268435456;
pub const SA_NODEFER: ::std::os::raw::c_uint = 1073741824;
pub const SA_RESETHAND: ::std::os::raw::c_uint = 2147483648;
pub const SA_INTERRUPT: ::std::os::raw::c_uint = 536870912;
pub const SA_NOMASK: ::std::os::raw::c_uint = 1073741824;
pub const SA_ONESHOT: ::std::os::raw::c_uint = 2147483648;
pub const SA_STACK: ::std::os::raw::c_uint = 134217728;
pub const SIG_BLOCK: ::std::os::raw::c_uint = 0;
pub const SIG_UNBLOCK: ::std::os::raw::c_uint = 1;
pub const SIG_SETMASK: ::std::os::raw::c_uint = 2;
pub const _BITS_SIGCONTEXT_H: ::std::os::raw::c_uint = 1;
pub const FP_XSTATE_MAGIC1: ::std::os::raw::c_uint = 1179670611;
pub const FP_XSTATE_MAGIC2: ::std::os::raw::c_uint = 1179670597;
pub const MINSIGSTKSZ: ::std::os::raw::c_uint = 2048;
pub const SIGSTKSZ: ::std::os::raw::c_uint = 8192;
pub const _SYS_UCONTEXT_H: ::std::os::raw::c_uint = 1;
pub const NGREG: ::std::os::raw::c_uint = 23;
pub const _BITS_SIGTHREAD_H: ::std::os::raw::c_uint = 1;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(::std::mem::size_of::<__fsid_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __fsid_t ) ));
    assert_eq! (::std::mem::align_of::<__fsid_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( __fsid_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __fsid_t ) ) . __val as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __fsid_t ) , "::" ,
                stringify ! ( __val ) ));
}
impl Clone for __fsid_t {
    fn clone(&self) -> Self { *self }
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __qaddr_t = *mut __quad_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub __pad1: *mut ::std::os::raw::c_void,
    pub __pad2: *mut ::std::os::raw::c_void,
    pub __pad3: *mut ::std::os::raw::c_void,
    pub __pad4: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(::std::mem::size_of::<_IO_FILE>() , 216usize , concat ! (
               "Size of: " , stringify ! ( _IO_FILE ) ));
    assert_eq! (::std::mem::align_of::<_IO_FILE>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _IO_FILE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _flags as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_read_ptr as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_read_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_read_end as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_read_end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_read_base as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_read_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_write_base as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_write_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_write_ptr as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_write_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_write_end as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_write_end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_buf_base as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_buf_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_buf_end as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_buf_end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_save_base as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_save_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_backup_base as * const
                _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_backup_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_save_end as * const _
                as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_save_end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _markers as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _markers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _chain as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _chain ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _fileno as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _fileno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _flags2 as * const _ as
                usize } , 116usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _flags2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _old_offset as * const _
                as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _old_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _cur_column as * const _
                as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _cur_column ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _vtable_offset as * const
                _ as usize } , 130usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _vtable_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _shortbuf as * const _ as
                usize } , 131usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _shortbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _lock as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _offset as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . __pad1 as * const _ as
                usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( __pad1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . __pad2 as * const _ as
                usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( __pad2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . __pad3 as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( __pad3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . __pad4 as * const _ as
                usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( __pad4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . __pad5 as * const _ as
                usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( __pad5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _mode as * const _ as
                usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _unused2 as * const _ as
                usize } , 196usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _unused2 ) ));
}
impl Clone for _IO_FILE {
    fn clone(&self) -> Self { *self }
}
pub type FILE = _IO_FILE;
pub type __FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __mbstate_t__bindgen_ty_1 {
    pub __wch: __BindgenUnionField<::std::os::raw::c_uint>,
    pub __wchb: __BindgenUnionField<[::std::os::raw::c_char; 4usize]>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<__mbstate_t__bindgen_ty_1>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( __mbstate_t__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<__mbstate_t__bindgen_ty_1>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( __mbstate_t__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t__bindgen_ty_1 ) ) . __wch as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __mbstate_t__bindgen_ty_1 ) , "::" , stringify ! ( __wch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t__bindgen_ty_1 ) ) . __wchb as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __mbstate_t__bindgen_ty_1 ) , "::" , stringify ! ( __wchb )
                ));
}
impl Clone for __mbstate_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(::std::mem::size_of::<__mbstate_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __mbstate_t ) ));
    assert_eq! (::std::mem::align_of::<__mbstate_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( __mbstate_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . __count as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( __count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . __value as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( __value ) ));
}
impl Clone for __mbstate_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    assert_eq!(::std::mem::size_of::<_G_fpos_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( _G_fpos_t ) ));
    assert_eq! (::std::mem::align_of::<_G_fpos_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _G_fpos_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _G_fpos_t ) ) . __pos as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _G_fpos_t ) , "::" ,
                stringify ! ( __pos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _G_fpos_t ) ) . __state as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _G_fpos_t ) , "::" ,
                stringify ! ( __state ) ));
}
impl Clone for _G_fpos_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    assert_eq!(::std::mem::size_of::<_G_fpos64_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( _G_fpos64_t ) ));
    assert_eq! (::std::mem::align_of::<_G_fpos64_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _G_fpos64_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _G_fpos64_t ) ) . __pos as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _G_fpos64_t ) , "::" ,
                stringify ! ( __pos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _G_fpos64_t ) ) . __state as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _G_fpos64_t ) , "::" ,
                stringify ! ( __state ) ));
}
impl Clone for _G_fpos64_t {
    fn clone(&self) -> Self { *self }
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_jump_t {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_marker {
    pub _next: *mut _IO_marker,
    pub _sbuf: *mut _IO_FILE,
    pub _pos: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__IO_marker() {
    assert_eq!(::std::mem::size_of::<_IO_marker>() , 24usize , concat ! (
               "Size of: " , stringify ! ( _IO_marker ) ));
    assert_eq! (::std::mem::align_of::<_IO_marker>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _IO_marker ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_marker ) ) . _next as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_marker ) , "::" ,
                stringify ! ( _next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_marker ) ) . _sbuf as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_marker ) , "::" ,
                stringify ! ( _sbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_marker ) ) . _pos as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_marker ) , "::" ,
                stringify ! ( _pos ) ));
}
impl Clone for _IO_marker {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum __codecvt_result {
    __codecvt_ok = 0,
    __codecvt_partial = 1,
    __codecvt_error = 2,
    __codecvt_noconv = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE_plus {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "_IO_2_1_stdin_"]
    pub static mut _IO_2_1_stdin_: _IO_FILE_plus;
}
extern "C" {
    #[link_name = "_IO_2_1_stdout_"]
    pub static mut _IO_2_1_stdout_: _IO_FILE_plus;
}
extern "C" {
    #[link_name = "_IO_2_1_stderr_"]
    pub static mut _IO_2_1_stderr_: _IO_FILE_plus;
}
pub type __io_read_fn =
    ::std::option::Option<unsafe extern "C" fn(__cookie:
                                                   *mut ::std::os::raw::c_void,
                                               __buf:
                                                   *mut ::std::os::raw::c_char,
                                               __nbytes: usize) -> __ssize_t>;
pub type __io_write_fn =
    ::std::option::Option<unsafe extern "C" fn(__cookie:
                                                   *mut ::std::os::raw::c_void,
                                               __buf:
                                                   *const ::std::os::raw::c_char,
                                               __n: usize) -> __ssize_t>;
pub type __io_seek_fn =
    ::std::option::Option<unsafe extern "C" fn(__cookie:
                                                   *mut ::std::os::raw::c_void,
                                               __pos: *mut __off64_t,
                                               __w: ::std::os::raw::c_int)
                              -> ::std::os::raw::c_int>;
pub type __io_close_fn =
    ::std::option::Option<unsafe extern "C" fn(__cookie:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
extern "C" {
    pub fn __underflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __uflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_getc(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_putc(__c: ::std::os::raw::c_int, __fp: *mut _IO_FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_feof(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_ferror(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_peekc_locked(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_flockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_funlockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_ftrylockfile(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_vfscanf(arg1: *mut _IO_FILE,
                       arg2: *const ::std::os::raw::c_char,
                       arg3: *mut __va_list_tag,
                       arg4: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_vfprintf(arg1: *mut _IO_FILE,
                        arg2: *const ::std::os::raw::c_char,
                        arg3: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_padn(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int,
                    arg3: __ssize_t) -> __ssize_t;
}
extern "C" {
    pub fn _IO_sgetn(arg1: *mut _IO_FILE, arg2: *mut ::std::os::raw::c_void,
                     arg3: usize) -> usize;
}
extern "C" {
    pub fn _IO_seekoff(arg1: *mut _IO_FILE, arg2: __off64_t,
                       arg3: ::std::os::raw::c_int,
                       arg4: ::std::os::raw::c_int) -> __off64_t;
}
extern "C" {
    pub fn _IO_seekpos(arg1: *mut _IO_FILE, arg2: __off64_t,
                       arg3: ::std::os::raw::c_int) -> __off64_t;
}
extern "C" {
    pub fn _IO_free_backup_area(arg1: *mut _IO_FILE);
}
pub type off_t = __off_t;
pub type fpos_t = _G_fpos_t;
extern "C" {
    #[link_name = "stdin"]
    pub static mut stdin: *mut _IO_FILE;
}
extern "C" {
    #[link_name = "stdout"]
    pub static mut stdout: *mut _IO_FILE;
}
extern "C" {
    #[link_name = "stderr"]
    pub static mut stderr: *mut _IO_FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(__old: *const ::std::os::raw::c_char,
                  __new: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(__oldfd: ::std::os::raw::c_int,
                    __old: *const ::std::os::raw::c_char,
                    __newfd: ::std::os::raw::c_int,
                    __new: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(__dir: *const ::std::os::raw::c_char,
                   __pfx: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(__filename: *const ::std::os::raw::c_char,
                 __modes: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn freopen(__filename: *const ::std::os::raw::c_char,
                   __modes: *const ::std::os::raw::c_char,
                   __stream: *mut FILE) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int,
                  __modes: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(__s: *mut ::std::os::raw::c_void, __len: usize,
                    __modes: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(__bufloc: *mut *mut ::std::os::raw::c_char,
                          __sizeloc: *mut usize) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char,
                   __modes: ::std::os::raw::c_int, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char,
                     __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(__stream: *mut FILE,
                   __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(__s: *mut ::std::os::raw::c_char,
                   __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(__s: *mut FILE, __format: *const ::std::os::raw::c_char,
                    __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(__format: *const ::std::os::raw::c_char,
                   __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(__s: *mut ::std::os::raw::c_char,
                    __format: *const ::std::os::raw::c_char,
                    __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(__s: *mut ::std::os::raw::c_char, __maxlen: usize,
                    __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(__s: *mut ::std::os::raw::c_char, __maxlen: usize,
                     __format: *const ::std::os::raw::c_char,
                     __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(__fd: ::std::os::raw::c_int,
                    __fmt: *const ::std::os::raw::c_char,
                    __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(__fd: ::std::os::raw::c_int,
                   __fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(__stream: *mut FILE,
                  __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(__s: *const ::std::os::raw::c_char,
                  __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_fscanf"]
    pub fn fscanf1(__stream: *mut FILE,
                   __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_sscanf"]
    pub fn sscanf1(__s: *const ::std::os::raw::c_char,
                   __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(__s: *mut FILE, __format: *const ::std::os::raw::c_char,
                   __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(__format: *const ::std::os::raw::c_char,
                  __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(__s: *const ::std::os::raw::c_char,
                   __format: *const ::std::os::raw::c_char,
                   __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_vfscanf"]
    pub fn vfscanf1(__s: *mut FILE, __format: *const ::std::os::raw::c_char,
                    __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_vscanf"]
    pub fn vscanf1(__format: *const ::std::os::raw::c_char,
                   __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_vsscanf"]
    pub fn vsscanf1(__s: *const ::std::os::raw::c_char,
                    __format: *const ::std::os::raw::c_char,
                    __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(__s: *mut ::std::os::raw::c_char, __n: ::std::os::raw::c_int,
                 __stream: *mut FILE) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(__lineptr: *mut *mut ::std::os::raw::c_char,
                      __n: *mut usize, __delimiter: ::std::os::raw::c_int,
                      __stream: *mut FILE) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(__lineptr: *mut *mut ::std::os::raw::c_char,
                    __n: *mut usize, __delimiter: ::std::os::raw::c_int,
                    __stream: *mut FILE) -> __ssize_t;
}
extern "C" {
    pub fn getline(__lineptr: *mut *mut ::std::os::raw::c_char,
                   __n: *mut usize, __stream: *mut FILE) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(__ptr: *mut ::std::os::raw::c_void, __size: usize,
                 __n: usize, __stream: *mut FILE) -> usize;
}
extern "C" {
    pub fn fwrite(__ptr: *const ::std::os::raw::c_void, __size: usize,
                  __n: usize, __s: *mut FILE) -> usize;
}
extern "C" {
    pub fn fread_unlocked(__ptr: *mut ::std::os::raw::c_void, __size: usize,
                          __n: usize, __stream: *mut FILE) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(__ptr: *const ::std::os::raw::c_void,
                           __size: usize, __n: usize, __stream: *mut FILE)
     -> usize;
}
extern "C" {
    pub fn fseek(__stream: *mut FILE, __off: ::std::os::raw::c_long,
                 __whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(__stream: *mut FILE, __off: __off_t,
                  __whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "sys_nerr"]
    pub static mut sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "sys_errlist"]
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(__command: *const ::std::os::raw::c_char,
                 __modes: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_long;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub type errmsg_t = *const ::std::os::raw::c_char;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct headerToken_s {
    _unused: [u8; 0],
}
pub type Header = *mut headerToken_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct headerIterator_s {
    _unused: [u8; 0],
}
pub type HeaderIterator = *mut headerIterator_s;
pub type rpm_tag_t = i32;
pub type rpm_tagtype_t = u32;
pub type rpm_count_t = u32;
pub type rpmTagVal = rpm_tag_t;
pub type rpmDbiTagVal = rpm_tag_t;
pub type rpm_data_t = *mut ::std::os::raw::c_void;
pub type rpm_constdata_t = *const ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rpmtd_s {
    pub tag: rpm_tag_t,
    pub type_: rpm_tagtype_t,
    pub count: rpm_count_t,
    pub data: rpm_data_t,
    pub flags: rpmtdFlags,
    pub ix: ::std::os::raw::c_int,
    pub size: rpm_count_t,
}
#[test]
fn bindgen_test_layout_rpmtd_s() {
    assert_eq!(::std::mem::size_of::<rpmtd_s>() , 40usize , concat ! (
               "Size of: " , stringify ! ( rpmtd_s ) ));
    assert_eq! (::std::mem::align_of::<rpmtd_s>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rpmtd_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rpmtd_s ) ) . tag as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rpmtd_s ) , "::" ,
                stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rpmtd_s ) ) . type_ as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rpmtd_s ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rpmtd_s ) ) . count as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rpmtd_s ) , "::" ,
                stringify ! ( count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rpmtd_s ) ) . data as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rpmtd_s ) , "::" ,
                stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rpmtd_s ) ) . flags as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rpmtd_s ) , "::" ,
                stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rpmtd_s ) ) . ix as * const _ as usize }
                , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( rpmtd_s ) , "::" ,
                stringify ! ( ix ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rpmtd_s ) ) . size as * const _ as usize
                } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rpmtd_s ) , "::" ,
                stringify ! ( size ) ));
}
impl Clone for rpmtd_s {
    fn clone(&self) -> Self { *self }
}
pub type rpmtd = *mut rpmtd_s;
pub type rpm_color_t = u32;
pub type rpm_flag_t = u32;
pub type rpm_tid_t = u32;
pub type rpmFlags = u32;
pub type rpm_off_t = u32;
pub type rpm_loff_t = u64;
pub type rpm_time_t = u32;
pub type rpm_mode_t = u16;
pub type rpm_rdev_t = u16;
pub type rpm_dev_t = u32;
pub type rpm_ino_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpmts_s {
    _unused: [u8; 0],
}
pub type rpmts = *mut rpmts_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpmte_s {
    _unused: [u8; 0],
}
pub type rpmte = *mut rpmte_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpmds_s {
    _unused: [u8; 0],
}
pub type rpmds = *mut rpmds_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpmfi_s {
    _unused: [u8; 0],
}
pub type rpmfi = *mut rpmfi_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpmfiles_s {
    _unused: [u8; 0],
}
pub type rpmfiles = *mut rpmfiles_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpmdb_s {
    _unused: [u8; 0],
}
pub type rpmdb = *mut rpmdb_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpmdbMatchIterator_s {
    _unused: [u8; 0],
}
pub type rpmdbMatchIterator = *mut rpmdbMatchIterator_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpmtsi_s {
    _unused: [u8; 0],
}
pub type rpmtsi = *mut rpmtsi_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpmps_s {
    _unused: [u8; 0],
}
pub type rpmps = *mut rpmps_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpmtxn_s {
    _unused: [u8; 0],
}
pub type rpmtxn = *mut rpmtxn_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpmdbIndexIterator_s {
    _unused: [u8; 0],
}
pub type rpmdbIndexIterator = *mut rpmdbIndexIterator_s;
pub type fnpyKey = *const ::std::os::raw::c_void;
pub type rpmCallbackData = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpmPubkey_s {
    _unused: [u8; 0],
}
pub type rpmPubkey = *mut rpmPubkey_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpmKeyring_s {
    _unused: [u8; 0],
}
pub type rpmKeyring = *mut rpmKeyring_s;
pub type rpmsid = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpmstrPool_s {
    _unused: [u8; 0],
}
pub type rpmstrPool = *mut rpmstrPool_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpmPlugin_s {
    _unused: [u8; 0],
}
pub type rpmPlugin = *mut rpmPlugin_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpmPlugins_s {
    _unused: [u8; 0],
}
pub type rpmPlugins = *mut rpmPlugins_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpmgi_s {
    _unused: [u8; 0],
}
pub type rpmgi = *mut rpmgi_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpmSpec_s {
    _unused: [u8; 0],
}
pub type rpmSpec = *mut rpmSpec_s;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rpmRelocation_s {
    pub oldPath: *mut ::std::os::raw::c_char,
    pub newPath: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_rpmRelocation_s() {
    assert_eq!(::std::mem::size_of::<rpmRelocation_s>() , 16usize , concat ! (
               "Size of: " , stringify ! ( rpmRelocation_s ) ));
    assert_eq! (::std::mem::align_of::<rpmRelocation_s>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( rpmRelocation_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rpmRelocation_s ) ) . oldPath as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rpmRelocation_s ) ,
                "::" , stringify ! ( oldPath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rpmRelocation_s ) ) . newPath as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rpmRelocation_s ) ,
                "::" , stringify ! ( newPath ) ));
}
impl Clone for rpmRelocation_s {
    fn clone(&self) -> Self { *self }
}
pub type rpmRelocation = rpmRelocation_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FD_s {
    _unused: [u8; 0],
}
pub type FD_t = *mut _FD_s;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rpmRC_e {
    RPMRC_OK = 0,
    RPMRC_NOTFOUND = 1,
    RPMRC_FAIL = 2,
    RPMRC_NOTTRUSTED = 3,
    RPMRC_NOKEY = 4,
}
pub use self::rpmRC_e as rpmRC;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rpmTag_e {
    RPMTAG_NOT_FOUND = -1,
    RPMTAG_HEADERIMAGE = 61,
    RPMTAG_HEADERSIGNATURES = 62,
    RPMTAG_HEADERIMMUTABLE = 63,
    RPMTAG_HEADERREGIONS = 64,
    RPMTAG_HEADERI18NTABLE = 100,
    RPMTAG_SIG_BASE = 256,
    RPMTAG_SIGSIZE = 257,
    RPMTAG_SIGLEMD5_1 = 258,
    RPMTAG_SIGPGP = 259,
    RPMTAG_SIGLEMD5_2 = 260,
    RPMTAG_SIGMD5 = 261,
    RPMTAG_SIGGPG = 262,
    RPMTAG_SIGPGP5 = 263,
    RPMTAG_BADSHA1_1 = 264,
    RPMTAG_BADSHA1_2 = 265,
    RPMTAG_PUBKEYS = 266,
    RPMTAG_DSAHEADER = 267,
    RPMTAG_RSAHEADER = 268,
    RPMTAG_SHA1HEADER = 269,
    RPMTAG_LONGSIGSIZE = 270,
    RPMTAG_LONGARCHIVESIZE = 271,
    RPMTAG_NAME = 1000,
    RPMTAG_VERSION = 1001,
    RPMTAG_RELEASE = 1002,
    RPMTAG_EPOCH = 1003,
    RPMTAG_SUMMARY = 1004,
    RPMTAG_DESCRIPTION = 1005,
    RPMTAG_BUILDTIME = 1006,
    RPMTAG_BUILDHOST = 1007,
    RPMTAG_INSTALLTIME = 1008,
    RPMTAG_SIZE = 1009,
    RPMTAG_DISTRIBUTION = 1010,
    RPMTAG_VENDOR = 1011,
    RPMTAG_GIF = 1012,
    RPMTAG_XPM = 1013,
    RPMTAG_LICENSE = 1014,
    RPMTAG_PACKAGER = 1015,
    RPMTAG_GROUP = 1016,
    RPMTAG_CHANGELOG = 1017,
    RPMTAG_SOURCE = 1018,
    RPMTAG_PATCH = 1019,
    RPMTAG_URL = 1020,
    RPMTAG_OS = 1021,
    RPMTAG_ARCH = 1022,
    RPMTAG_PREIN = 1023,
    RPMTAG_POSTIN = 1024,
    RPMTAG_PREUN = 1025,
    RPMTAG_POSTUN = 1026,
    RPMTAG_OLDFILENAMES = 1027,
    RPMTAG_FILESIZES = 1028,
    RPMTAG_FILESTATES = 1029,
    RPMTAG_FILEMODES = 1030,
    RPMTAG_FILEUIDS = 1031,
    RPMTAG_FILEGIDS = 1032,
    RPMTAG_FILERDEVS = 1033,
    RPMTAG_FILEMTIMES = 1034,
    RPMTAG_FILEDIGESTS = 1035,
    RPMTAG_FILELINKTOS = 1036,
    RPMTAG_FILEFLAGS = 1037,
    RPMTAG_ROOT = 1038,
    RPMTAG_FILEUSERNAME = 1039,
    RPMTAG_FILEGROUPNAME = 1040,
    RPMTAG_EXCLUDE = 1041,
    RPMTAG_EXCLUSIVE = 1042,
    RPMTAG_ICON = 1043,
    RPMTAG_SOURCERPM = 1044,
    RPMTAG_FILEVERIFYFLAGS = 1045,
    RPMTAG_ARCHIVESIZE = 1046,
    RPMTAG_PROVIDENAME = 1047,
    RPMTAG_REQUIREFLAGS = 1048,
    RPMTAG_REQUIRENAME = 1049,
    RPMTAG_REQUIREVERSION = 1050,
    RPMTAG_NOSOURCE = 1051,
    RPMTAG_NOPATCH = 1052,
    RPMTAG_CONFLICTFLAGS = 1053,
    RPMTAG_CONFLICTNAME = 1054,
    RPMTAG_CONFLICTVERSION = 1055,
    RPMTAG_DEFAULTPREFIX = 1056,
    RPMTAG_BUILDROOT = 1057,
    RPMTAG_INSTALLPREFIX = 1058,
    RPMTAG_EXCLUDEARCH = 1059,
    RPMTAG_EXCLUDEOS = 1060,
    RPMTAG_EXCLUSIVEARCH = 1061,
    RPMTAG_EXCLUSIVEOS = 1062,
    RPMTAG_AUTOREQPROV = 1063,
    RPMTAG_RPMVERSION = 1064,
    RPMTAG_TRIGGERSCRIPTS = 1065,
    RPMTAG_TRIGGERNAME = 1066,
    RPMTAG_TRIGGERVERSION = 1067,
    RPMTAG_TRIGGERFLAGS = 1068,
    RPMTAG_TRIGGERINDEX = 1069,
    RPMTAG_VERIFYSCRIPT = 1079,
    RPMTAG_CHANGELOGTIME = 1080,
    RPMTAG_CHANGELOGNAME = 1081,
    RPMTAG_CHANGELOGTEXT = 1082,
    RPMTAG_BROKENMD5 = 1083,
    RPMTAG_PREREQ = 1084,
    RPMTAG_PREINPROG = 1085,
    RPMTAG_POSTINPROG = 1086,
    RPMTAG_PREUNPROG = 1087,
    RPMTAG_POSTUNPROG = 1088,
    RPMTAG_BUILDARCHS = 1089,
    RPMTAG_OBSOLETENAME = 1090,
    RPMTAG_VERIFYSCRIPTPROG = 1091,
    RPMTAG_TRIGGERSCRIPTPROG = 1092,
    RPMTAG_DOCDIR = 1093,
    RPMTAG_COOKIE = 1094,
    RPMTAG_FILEDEVICES = 1095,
    RPMTAG_FILEINODES = 1096,
    RPMTAG_FILELANGS = 1097,
    RPMTAG_PREFIXES = 1098,
    RPMTAG_INSTPREFIXES = 1099,
    RPMTAG_TRIGGERIN = 1100,
    RPMTAG_TRIGGERUN = 1101,
    RPMTAG_TRIGGERPOSTUN = 1102,
    RPMTAG_AUTOREQ = 1103,
    RPMTAG_AUTOPROV = 1104,
    RPMTAG_CAPABILITY = 1105,
    RPMTAG_SOURCEPACKAGE = 1106,
    RPMTAG_OLDORIGFILENAMES = 1107,
    RPMTAG_BUILDPREREQ = 1108,
    RPMTAG_BUILDREQUIRES = 1109,
    RPMTAG_BUILDCONFLICTS = 1110,
    RPMTAG_BUILDMACROS = 1111,
    RPMTAG_PROVIDEFLAGS = 1112,
    RPMTAG_PROVIDEVERSION = 1113,
    RPMTAG_OBSOLETEFLAGS = 1114,
    RPMTAG_OBSOLETEVERSION = 1115,
    RPMTAG_DIRINDEXES = 1116,
    RPMTAG_BASENAMES = 1117,
    RPMTAG_DIRNAMES = 1118,
    RPMTAG_ORIGDIRINDEXES = 1119,
    RPMTAG_ORIGBASENAMES = 1120,
    RPMTAG_ORIGDIRNAMES = 1121,
    RPMTAG_OPTFLAGS = 1122,
    RPMTAG_DISTURL = 1123,
    RPMTAG_PAYLOADFORMAT = 1124,
    RPMTAG_PAYLOADCOMPRESSOR = 1125,
    RPMTAG_PAYLOADFLAGS = 1126,
    RPMTAG_INSTALLCOLOR = 1127,
    RPMTAG_INSTALLTID = 1128,
    RPMTAG_REMOVETID = 1129,
    RPMTAG_SHA1RHN = 1130,
    RPMTAG_RHNPLATFORM = 1131,
    RPMTAG_PLATFORM = 1132,
    RPMTAG_PATCHESNAME = 1133,
    RPMTAG_PATCHESFLAGS = 1134,
    RPMTAG_PATCHESVERSION = 1135,
    RPMTAG_CACHECTIME = 1136,
    RPMTAG_CACHEPKGPATH = 1137,
    RPMTAG_CACHEPKGSIZE = 1138,
    RPMTAG_CACHEPKGMTIME = 1139,
    RPMTAG_FILECOLORS = 1140,
    RPMTAG_FILECLASS = 1141,
    RPMTAG_CLASSDICT = 1142,
    RPMTAG_FILEDEPENDSX = 1143,
    RPMTAG_FILEDEPENDSN = 1144,
    RPMTAG_DEPENDSDICT = 1145,
    RPMTAG_SOURCEPKGID = 1146,
    RPMTAG_FILECONTEXTS = 1147,
    RPMTAG_FSCONTEXTS = 1148,
    RPMTAG_RECONTEXTS = 1149,
    RPMTAG_POLICIES = 1150,
    RPMTAG_PRETRANS = 1151,
    RPMTAG_POSTTRANS = 1152,
    RPMTAG_PRETRANSPROG = 1153,
    RPMTAG_POSTTRANSPROG = 1154,
    RPMTAG_DISTTAG = 1155,
    RPMTAG_OLDSUGGESTSNAME = 1156,
    RPMTAG_OLDSUGGESTSVERSION = 1157,
    RPMTAG_OLDSUGGESTSFLAGS = 1158,
    RPMTAG_OLDENHANCESNAME = 1159,
    RPMTAG_OLDENHANCESVERSION = 1160,
    RPMTAG_OLDENHANCESFLAGS = 1161,
    RPMTAG_PRIORITY = 1162,
    RPMTAG_CVSID = 1163,
    RPMTAG_BLINKPKGID = 1164,
    RPMTAG_BLINKHDRID = 1165,
    RPMTAG_BLINKNEVRA = 1166,
    RPMTAG_FLINKPKGID = 1167,
    RPMTAG_FLINKHDRID = 1168,
    RPMTAG_FLINKNEVRA = 1169,
    RPMTAG_PACKAGEORIGIN = 1170,
    RPMTAG_TRIGGERPREIN = 1171,
    RPMTAG_BUILDSUGGESTS = 1172,
    RPMTAG_BUILDENHANCES = 1173,
    RPMTAG_SCRIPTSTATES = 1174,
    RPMTAG_SCRIPTMETRICS = 1175,
    RPMTAG_BUILDCPUCLOCK = 1176,
    RPMTAG_FILEDIGESTALGOS = 1177,
    RPMTAG_VARIANTS = 1178,
    RPMTAG_XMAJOR = 1179,
    RPMTAG_XMINOR = 1180,
    RPMTAG_REPOTAG = 1181,
    RPMTAG_KEYWORDS = 1182,
    RPMTAG_BUILDPLATFORMS = 1183,
    RPMTAG_PACKAGECOLOR = 1184,
    RPMTAG_PACKAGEPREFCOLOR = 1185,
    RPMTAG_XATTRSDICT = 1186,
    RPMTAG_FILEXATTRSX = 1187,
    RPMTAG_DEPATTRSDICT = 1188,
    RPMTAG_CONFLICTATTRSX = 1189,
    RPMTAG_OBSOLETEATTRSX = 1190,
    RPMTAG_PROVIDEATTRSX = 1191,
    RPMTAG_REQUIREATTRSX = 1192,
    RPMTAG_BUILDPROVIDES = 1193,
    RPMTAG_BUILDOBSOLETES = 1194,
    RPMTAG_DBINSTANCE = 1195,
    RPMTAG_NVRA = 1196,
    RPMTAG_FILENAMES = 5000,
    RPMTAG_FILEPROVIDE = 5001,
    RPMTAG_FILEREQUIRE = 5002,
    RPMTAG_FSNAMES = 5003,
    RPMTAG_FSSIZES = 5004,
    RPMTAG_TRIGGERCONDS = 5005,
    RPMTAG_TRIGGERTYPE = 5006,
    RPMTAG_ORIGFILENAMES = 5007,
    RPMTAG_LONGFILESIZES = 5008,
    RPMTAG_LONGSIZE = 5009,
    RPMTAG_FILECAPS = 5010,
    RPMTAG_FILEDIGESTALGO = 5011,
    RPMTAG_BUGURL = 5012,
    RPMTAG_EVR = 5013,
    RPMTAG_NVR = 5014,
    RPMTAG_NEVR = 5015,
    RPMTAG_NEVRA = 5016,
    RPMTAG_HEADERCOLOR = 5017,
    RPMTAG_VERBOSE = 5018,
    RPMTAG_EPOCHNUM = 5019,
    RPMTAG_PREINFLAGS = 5020,
    RPMTAG_POSTINFLAGS = 5021,
    RPMTAG_PREUNFLAGS = 5022,
    RPMTAG_POSTUNFLAGS = 5023,
    RPMTAG_PRETRANSFLAGS = 5024,
    RPMTAG_POSTTRANSFLAGS = 5025,
    RPMTAG_VERIFYSCRIPTFLAGS = 5026,
    RPMTAG_TRIGGERSCRIPTFLAGS = 5027,
    RPMTAG_COLLECTIONS = 5029,
    RPMTAG_POLICYNAMES = 5030,
    RPMTAG_POLICYTYPES = 5031,
    RPMTAG_POLICYTYPESINDEXES = 5032,
    RPMTAG_POLICYFLAGS = 5033,
    RPMTAG_VCS = 5034,
    RPMTAG_ORDERNAME = 5035,
    RPMTAG_ORDERVERSION = 5036,
    RPMTAG_ORDERFLAGS = 5037,
    RPMTAG_MSSFMANIFEST = 5038,
    RPMTAG_MSSFDOMAIN = 5039,
    RPMTAG_INSTFILENAMES = 5040,
    RPMTAG_REQUIRENEVRS = 5041,
    RPMTAG_PROVIDENEVRS = 5042,
    RPMTAG_OBSOLETENEVRS = 5043,
    RPMTAG_CONFLICTNEVRS = 5044,
    RPMTAG_FILENLINKS = 5045,
    RPMTAG_RECOMMENDNAME = 5046,
    RPMTAG_RECOMMENDVERSION = 5047,
    RPMTAG_RECOMMENDFLAGS = 5048,
    RPMTAG_SUGGESTNAME = 5049,
    RPMTAG_SUGGESTVERSION = 5050,
    RPMTAG_SUGGESTFLAGS = 5051,
    RPMTAG_SUPPLEMENTNAME = 5052,
    RPMTAG_SUPPLEMENTVERSION = 5053,
    RPMTAG_SUPPLEMENTFLAGS = 5054,
    RPMTAG_ENHANCENAME = 5055,
    RPMTAG_ENHANCEVERSION = 5056,
    RPMTAG_ENHANCEFLAGS = 5057,
    RPMTAG_RECOMMENDNEVRS = 5058,
    RPMTAG_SUGGESTNEVRS = 5059,
    RPMTAG_SUPPLEMENTNEVRS = 5060,
    RPMTAG_ENHANCENEVRS = 5061,
    RPMTAG_ENCODING = 5062,
    RPMTAG_FILETRIGGERIN = 5063,
    RPMTAG_FILETRIGGERUN = 5064,
    RPMTAG_FILETRIGGERPOSTUN = 5065,
    RPMTAG_FILETRIGGERSCRIPTS = 5066,
    RPMTAG_FILETRIGGERSCRIPTPROG = 5067,
    RPMTAG_FILETRIGGERSCRIPTFLAGS = 5068,
    RPMTAG_FILETRIGGERNAME = 5069,
    RPMTAG_FILETRIGGERINDEX = 5070,
    RPMTAG_FILETRIGGERVERSION = 5071,
    RPMTAG_FILETRIGGERFLAGS = 5072,
    RPMTAG_TRANSFILETRIGGERIN = 5073,
    RPMTAG_TRANSFILETRIGGERUN = 5074,
    RPMTAG_TRANSFILETRIGGERPOSTUN = 5075,
    RPMTAG_TRANSFILETRIGGERSCRIPTS = 5076,
    RPMTAG_TRANSFILETRIGGERSCRIPTPROG = 5077,
    RPMTAG_TRANSFILETRIGGERSCRIPTFLAGS = 5078,
    RPMTAG_TRANSFILETRIGGERNAME = 5079,
    RPMTAG_TRANSFILETRIGGERINDEX = 5080,
    RPMTAG_TRANSFILETRIGGERVERSION = 5081,
    RPMTAG_TRANSFILETRIGGERFLAGS = 5082,
    RPMTAG_REMOVEPATHPOSTFIXES = 5083,
    RPMTAG_FILETRIGGERPRIORITIES = 5084,
    RPMTAG_TRANSFILETRIGGERPRIORITIES = 5085,
    RPMTAG_FILETRIGGERCONDS = 5086,
    RPMTAG_FILETRIGGERTYPE = 5087,
    RPMTAG_TRANSFILETRIGGERCONDS = 5088,
    RPMTAG_TRANSFILETRIGGERTYPE = 5089,
    RPMTAG_FILESIGNATURES = 5090,
    RPMTAG_FILESIGNATURELENGTH = 5091,
    RPMTAG_FIRSTFREE_TAG = 5092,
}
pub use self::rpmTag_e as rpmTag;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rpmDbiTag_e {
    RPMDBI_PACKAGES = 0,
    RPMDBI_LABEL = 2,
    RPMDBI_NAME = 1000,
    RPMDBI_BASENAMES = 1117,
    RPMDBI_GROUP = 1016,
    RPMDBI_REQUIRENAME = 1049,
    RPMDBI_PROVIDENAME = 1047,
    RPMDBI_CONFLICTNAME = 1054,
    RPMDBI_OBSOLETENAME = 1090,
    RPMDBI_TRIGGERNAME = 1066,
    RPMDBI_DIRNAMES = 1118,
    RPMDBI_INSTALLTID = 1128,
    RPMDBI_SIGMD5 = 261,
    RPMDBI_SHA1HEADER = 269,
    RPMDBI_INSTFILENAMES = 5040,
    RPMDBI_FILETRIGGERNAME = 5069,
    RPMDBI_TRANSFILETRIGGERNAME = 5079,
    RPMDBI_RECOMMENDNAME = 5046,
    RPMDBI_SUGGESTNAME = 5049,
    RPMDBI_SUPPLEMENTNAME = 5052,
    RPMDBI_ENHANCENAME = 5055,
}
pub use self::rpmDbiTag_e as rpmDbiTag;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rpmSigTag_e {
    RPMSIGTAG_SIZE = 1000,
    RPMSIGTAG_LEMD5_1 = 1001,
    RPMSIGTAG_PGP = 1002,
    RPMSIGTAG_LEMD5_2 = 1003,
    RPMSIGTAG_MD5 = 1004,
    RPMSIGTAG_GPG = 1005,
    RPMSIGTAG_PGP5 = 1006,
    RPMSIGTAG_PAYLOADSIZE = 1007,
    RPMSIGTAG_RESERVEDSPACE = 1008,
    RPMSIGTAG_BADSHA1_1 = 264,
    RPMSIGTAG_BADSHA1_2 = 265,
    RPMSIGTAG_SHA1 = 269,
    RPMSIGTAG_DSA = 267,
    RPMSIGTAG_RSA = 268,
    RPMSIGTAG_LONGSIZE = 270,
    RPMSIGTAG_LONGARCHIVESIZE = 271,
}
pub use self::rpmSigTag_e as rpmSigTag;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rpmTagType_e {
    RPM_NULL_TYPE = 0,
    RPM_CHAR_TYPE = 1,
    RPM_INT8_TYPE = 2,
    RPM_INT16_TYPE = 3,
    RPM_INT32_TYPE = 4,
    RPM_INT64_TYPE = 5,
    RPM_STRING_TYPE = 6,
    RPM_BIN_TYPE = 7,
    RPM_STRING_ARRAY_TYPE = 8,
    RPM_I18NSTRING_TYPE = 9,
}
pub use self::rpmTagType_e as rpmTagType;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rpmTagClass_e {
    RPM_NULL_CLASS = 0,
    RPM_NUMERIC_CLASS = 1,
    RPM_STRING_CLASS = 2,
    RPM_BINARY_CLASS = 3,
}
pub use self::rpmTagClass_e as rpmTagClass;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rpmSubTagType_e {
    RPM_REGION_TYPE = -10,
    RPM_BIN_ARRAY_TYPE = -11,
    RPM_XREF_TYPE = -12,
}
pub use self::rpmSubTagType_e as rpmSubTagType;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rpmTagReturnType_e {
    RPM_ANY_RETURN_TYPE = 0,
    RPM_SCALAR_RETURN_TYPE = 65536,
    RPM_ARRAY_RETURN_TYPE = 131072,
    RPM_MAPPING_RETURN_TYPE = 262144,
    RPM_MASK_RETURN_TYPE = 4294901760,
}
pub type rpmTagReturnType = rpmFlags;
extern "C" {
    pub fn rpmTagGetName(tag: rpmTagVal) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmTagGetType(tag: rpmTagVal) -> rpmTagType;
}
extern "C" {
    pub fn rpmTagGetTagType(tag: rpmTagVal) -> rpmTagType;
}
extern "C" {
    pub fn rpmTagGetReturnType(tag: rpmTagVal) -> rpmTagReturnType;
}
extern "C" {
    pub fn rpmTagGetClass(tag: rpmTagVal) -> rpmTagClass;
}
extern "C" {
    pub fn rpmTagGetValue(tagstr: *const ::std::os::raw::c_char) -> rpmTagVal;
}
extern "C" {
    pub fn rpmTagTypeGetClass(type_: rpmTagType) -> rpmTagClass;
}
extern "C" {
    pub fn rpmTagGetNames(tagnames: rpmtd, fullname: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
pub type ARGV_t = *mut *mut ::std::os::raw::c_char;
pub type ARGV_const_t = *const *const ::std::os::raw::c_char;
pub type ARGint_t = *mut ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ARGI_s {
    pub nvals: ::std::os::raw::c_uint,
    pub vals: ARGint_t,
}
#[test]
fn bindgen_test_layout_ARGI_s() {
    assert_eq!(::std::mem::size_of::<ARGI_s>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ARGI_s ) ));
    assert_eq! (::std::mem::align_of::<ARGI_s>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ARGI_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ARGI_s ) ) . nvals as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ARGI_s ) , "::" ,
                stringify ! ( nvals ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ARGI_s ) ) . vals as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ARGI_s ) , "::" ,
                stringify ! ( vals ) ));
}
impl Clone for ARGI_s {
    fn clone(&self) -> Self { *self }
}
pub type ARGI_t = *mut ARGI_s;
pub type ARGI_const_t = *const ARGI_s;
extern "C" {
    pub fn argvPrint(msg: *const ::std::os::raw::c_char, argv: ARGV_const_t,
                     fp: *mut FILE);
}
extern "C" {
    pub fn argiFree(argi: ARGI_t) -> ARGI_t;
}
extern "C" {
    pub fn argvNew() -> ARGV_t;
}
extern "C" {
    pub fn argvFree(argv: ARGV_t) -> ARGV_t;
}
extern "C" {
    pub fn argiCount(argi: ARGI_const_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn argiData(argi: ARGI_const_t) -> ARGint_t;
}
extern "C" {
    pub fn argvCount(argv: ARGV_const_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn argvData(argv: ARGV_t) -> ARGV_t;
}
extern "C" {
    pub fn argvCmp(a: *const ::std::os::raw::c_void,
                   b: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn argvSort(argv: ARGV_t,
                    compar:
                        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                       *const ::std::os::raw::c_void,
                                                                   arg2:
                                                                       *const ::std::os::raw::c_void)
                                                  -> ::std::os::raw::c_int>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn argvSearch(argv: ARGV_const_t, val: *const ::std::os::raw::c_char,
                      compar:
                          ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                         *const ::std::os::raw::c_void,
                                                                     arg2:
                                                                         *const ::std::os::raw::c_void)
                                                    -> ::std::os::raw::c_int>)
     -> ARGV_t;
}
extern "C" {
    pub fn argiAdd(argip: *mut ARGI_t, ix: ::std::os::raw::c_int,
                   val: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn argvAdd(argvp: *mut ARGV_t, val: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn argvAddNum(argvp: *mut ARGV_t, val: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn argvAppend(argvp: *mut ARGV_t, av: ARGV_const_t)
     -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum argvFlags_e { ARGV_NONE = 0, ARGV_SKIPEMPTY = 1, }
pub type argvFlags = rpmFlags;
extern "C" {
    pub fn argvSplitString(str: *const ::std::os::raw::c_char,
                           seps: *const ::std::os::raw::c_char,
                           flags: argvFlags) -> ARGV_t;
}
extern "C" {
    pub fn argvSplit(argvp: *mut ARGV_t, str: *const ::std::os::raw::c_char,
                     seps: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn argvJoin(argv: ARGV_const_t, sep: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type time_t = __time_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulong;
pub type register_t = ::std::os::raw::c_long;
pub type __sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(::std::mem::size_of::<__sigset_t>() , 128usize , concat ! (
               "Size of: " , stringify ! ( __sigset_t ) ));
    assert_eq! (::std::mem::align_of::<__sigset_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __sigset_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sigset_t ) ) . __val as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sigset_t ) , "::" ,
                stringify ! ( __val ) ));
}
impl Clone for __sigset_t {
    fn clone(&self) -> Self { *self }
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(::std::mem::size_of::<timespec>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timespec ) ));
    assert_eq! (::std::mem::align_of::<timespec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timespec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_nsec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_nsec ) ));
}
impl Clone for timespec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(::std::mem::size_of::<timeval>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timeval ) ));
    assert_eq! (::std::mem::align_of::<timeval>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timeval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_usec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_usec ) ));
}
impl Clone for timeval {
    fn clone(&self) -> Self { *self }
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(::std::mem::size_of::<fd_set>() , 128usize , concat ! (
               "Size of: " , stringify ! ( fd_set ) ));
    assert_eq! (::std::mem::align_of::<fd_set>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( fd_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fd_set ) ) . __fds_bits as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( fd_set ) , "::" ,
                stringify ! ( __fds_bits ) ));
}
impl Clone for fd_set {
    fn clone(&self) -> Self { *self }
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(__nfds: ::std::os::raw::c_int, __readfds: *mut fd_set,
                  __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                  __timeout: *mut timeval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(__nfds: ::std::os::raw::c_int, __readfds: *mut fd_set,
                   __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                   __timeout: *const timespec, __sigmask: *const __sigset_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnu_dev_major(__dev: ::std::os::raw::c_ulonglong)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnu_dev_minor(__dev: ::std::os::raw::c_ulonglong)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnu_dev_makedev(__major: ::std::os::raw::c_uint,
                           __minor: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_ulonglong;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_attr_t {
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 56usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_long>,
    pub bindgen_union_field: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(::std::mem::size_of::<pthread_attr_t>() , 56usize , concat ! (
               "Size of: " , stringify ! ( pthread_attr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_attr_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_attr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_attr_t ) ) . __size as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_attr_t ) , "::"
                , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_attr_t ) ) . __align as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_attr_t ) , "::"
                , stringify ! ( __align ) ));
}
impl Clone for pthread_attr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(::std::mem::size_of::<__pthread_internal_list>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( __pthread_internal_list ) ));
    assert_eq! (::std::mem::align_of::<__pthread_internal_list>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( __pthread_internal_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_internal_list ) ) . __prev as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_internal_list
                ) , "::" , stringify ! ( __prev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_internal_list ) ) . __next as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_internal_list
                ) , "::" , stringify ! ( __next ) ));
}
impl Clone for __pthread_internal_list {
    fn clone(&self) -> Self { *self }
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_mutex_t {
    pub __data: __BindgenUnionField<pthread_mutex_t___pthread_mutex_s>,
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 40usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_long>,
    pub bindgen_union_field: [u64; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_mutex_t___pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t___pthread_mutex_s() {
    assert_eq!(::std::mem::size_of::<pthread_mutex_t___pthread_mutex_s>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( pthread_mutex_t___pthread_mutex_s )
               ));
    assert_eq! (::std::mem::align_of::<pthread_mutex_t___pthread_mutex_s>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __lock as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __count as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __owner as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __owner ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __nusers as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __nusers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __kind as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __kind ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __spins as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __spins ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __elision as * const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __elision ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __list as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __list ) ));
}
impl Clone for pthread_mutex_t___pthread_mutex_s {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(::std::mem::size_of::<pthread_mutex_t>() , 40usize , concat ! (
               "Size of: " , stringify ! ( pthread_mutex_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_mutex_t>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( pthread_mutex_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t ) ) . __data as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutex_t ) ,
                "::" , stringify ! ( __data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t ) ) . __size as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutex_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t ) ) . __align as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutex_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_mutex_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_mutexattr_t {
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 4usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_int>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_mutexattr_t>() , 4usize , concat
               ! ( "Size of: " , stringify ! ( pthread_mutexattr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_mutexattr_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( pthread_mutexattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutexattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutexattr_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutexattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutexattr_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_mutexattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_cond_t {
    pub __data: __BindgenUnionField<pthread_cond_t__bindgen_ty_1>,
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 48usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_longlong>,
    pub bindgen_union_field: [u64; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_cond_t__bindgen_ty_1 {
    pub __lock: ::std::os::raw::c_int,
    pub __futex: ::std::os::raw::c_uint,
    pub __total_seq: ::std::os::raw::c_ulonglong,
    pub __wakeup_seq: ::std::os::raw::c_ulonglong,
    pub __woken_seq: ::std::os::raw::c_ulonglong,
    pub __mutex: *mut ::std::os::raw::c_void,
    pub __nwaiters: ::std::os::raw::c_uint,
    pub __broadcast_seq: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_pthread_cond_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<pthread_cond_t__bindgen_ty_1>() , 48usize
               , concat ! (
               "Size of: " , stringify ! ( pthread_cond_t__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<pthread_cond_t__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_cond_t__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) . __lock
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __lock )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __futex as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __futex
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __total_seq as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __total_seq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __wakeup_seq as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __wakeup_seq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __woken_seq as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __woken_seq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __mutex as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __mutex
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __nwaiters as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __nwaiters ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __broadcast_seq as * const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __broadcast_seq ) ));
}
impl Clone for pthread_cond_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(::std::mem::size_of::<pthread_cond_t>() , 48usize , concat ! (
               "Size of: " , stringify ! ( pthread_cond_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_cond_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_cond_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t ) ) . __data as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_cond_t ) , "::"
                , stringify ! ( __data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t ) ) . __size as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_cond_t ) , "::"
                , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t ) ) . __align as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_cond_t ) , "::"
                , stringify ! ( __align ) ));
}
impl Clone for pthread_cond_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_condattr_t {
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 4usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_int>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_condattr_t>() , 4usize , concat !
               ( "Size of: " , stringify ! ( pthread_condattr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_condattr_t>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( pthread_condattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_condattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_condattr_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_condattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_condattr_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_condattr_t {
    fn clone(&self) -> Self { *self }
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_rwlock_t {
    pub __data: __BindgenUnionField<pthread_rwlock_t__bindgen_ty_1>,
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 56usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_long>,
    pub bindgen_union_field: [u64; 7usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_rwlock_t__bindgen_ty_1 {
    pub __lock: ::std::os::raw::c_int,
    pub __nr_readers: ::std::os::raw::c_uint,
    pub __readers_wakeup: ::std::os::raw::c_uint,
    pub __writer_wakeup: ::std::os::raw::c_uint,
    pub __nr_readers_queued: ::std::os::raw::c_uint,
    pub __nr_writers_queued: ::std::os::raw::c_uint,
    pub __writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<pthread_rwlock_t__bindgen_ty_1>() ,
               56usize , concat ! (
               "Size of: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<pthread_rwlock_t__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_rwlock_t__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __lock as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __lock
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __nr_readers as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __nr_readers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __readers_wakeup as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __readers_wakeup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __writer_wakeup as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __writer_wakeup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __nr_readers_queued as * const _ as usize } , 16usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __nr_readers_queued ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __nr_writers_queued as * const _ as usize } , 20usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __nr_writers_queued ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __writer as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __writer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __shared as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __shared ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __rwelision as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __rwelision ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __pad1 as * const _ as usize } , 33usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __pad1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __pad2 as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __pad2
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __flags as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __flags ) ));
}
impl Clone for pthread_rwlock_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(::std::mem::size_of::<pthread_rwlock_t>() , 56usize , concat !
               ( "Size of: " , stringify ! ( pthread_rwlock_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_rwlock_t>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( pthread_rwlock_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t ) ) . __data as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlock_t ) ,
                "::" , stringify ! ( __data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t ) ) . __size as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlock_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t ) ) . __align as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlock_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_rwlock_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_rwlockattr_t {
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 8usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_long>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_rwlockattr_t>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( pthread_rwlockattr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_rwlockattr_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( pthread_rwlockattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlockattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlockattr_t )
                , "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlockattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlockattr_t )
                , "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_rwlockattr_t {
    fn clone(&self) -> Self { *self }
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_barrier_t {
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 32usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_long>,
    pub bindgen_union_field: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(::std::mem::size_of::<pthread_barrier_t>() , 32usize , concat !
               ( "Size of: " , stringify ! ( pthread_barrier_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_barrier_t>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( pthread_barrier_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrier_t ) ) . __size as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrier_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrier_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrier_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_barrier_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_barrierattr_t {
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 4usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_int>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_barrierattr_t>() , 4usize ,
               concat ! ( "Size of: " , stringify ! ( pthread_barrierattr_t )
               ));
    assert_eq! (::std::mem::align_of::<pthread_barrierattr_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( pthread_barrierattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrierattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrierattr_t )
                , "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrierattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrierattr_t )
                , "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_barrierattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct stat {
    pub st_dev: __dev_t,
    pub st_ino: __ino_t,
    pub st_nlink: __nlink_t,
    pub st_mode: __mode_t,
    pub st_uid: __uid_t,
    pub st_gid: __gid_t,
    pub __pad0: ::std::os::raw::c_int,
    pub st_rdev: __dev_t,
    pub st_size: __off_t,
    pub st_blksize: __blksize_t,
    pub st_blocks: __blkcnt_t,
    pub st_atim: timespec,
    pub st_mtim: timespec,
    pub st_ctim: timespec,
    pub __glibc_reserved: [__syscall_slong_t; 3usize],
}
#[test]
fn bindgen_test_layout_stat() {
    assert_eq!(::std::mem::size_of::<stat>() , 144usize , concat ! (
               "Size of: " , stringify ! ( stat ) ));
    assert_eq! (::std::mem::align_of::<stat>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( stat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . st_dev as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( st_dev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . st_ino as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( st_ino ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . st_nlink as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( st_nlink ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . st_mode as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( st_mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . st_uid as * const _ as usize }
                , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( st_uid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . st_gid as * const _ as usize }
                , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( st_gid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . __pad0 as * const _ as usize }
                , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( __pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . st_rdev as * const _ as usize
                } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( st_rdev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . st_size as * const _ as usize
                } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( st_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . st_blksize as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( st_blksize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . st_blocks as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( st_blocks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . st_atim as * const _ as usize
                } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( st_atim ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . st_mtim as * const _ as usize
                } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( st_mtim ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . st_ctim as * const _ as usize
                } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( st_ctim ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . __glibc_reserved as * const _
                as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( __glibc_reserved ) ));
}
impl Clone for stat {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn stat(__file: *const ::std::os::raw::c_char, __buf: *mut stat)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fstat(__fd: ::std::os::raw::c_int, __buf: *mut stat)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fstatat(__fd: ::std::os::raw::c_int,
                   __file: *const ::std::os::raw::c_char, __buf: *mut stat,
                   __flag: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lstat(__file: *const ::std::os::raw::c_char, __buf: *mut stat)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chmod(__file: *const ::std::os::raw::c_char, __mode: __mode_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lchmod(__file: *const ::std::os::raw::c_char, __mode: __mode_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchmod(__fd: ::std::os::raw::c_int, __mode: __mode_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchmodat(__fd: ::std::os::raw::c_int,
                    __file: *const ::std::os::raw::c_char, __mode: __mode_t,
                    __flag: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn umask(__mask: __mode_t) -> __mode_t;
}
extern "C" {
    pub fn mkdir(__path: *const ::std::os::raw::c_char, __mode: __mode_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdirat(__fd: ::std::os::raw::c_int,
                   __path: *const ::std::os::raw::c_char, __mode: __mode_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mknod(__path: *const ::std::os::raw::c_char, __mode: __mode_t,
                 __dev: __dev_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mknodat(__fd: ::std::os::raw::c_int,
                   __path: *const ::std::os::raw::c_char, __mode: __mode_t,
                   __dev: __dev_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkfifo(__path: *const ::std::os::raw::c_char, __mode: __mode_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkfifoat(__fd: ::std::os::raw::c_int,
                    __path: *const ::std::os::raw::c_char, __mode: __mode_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn utimensat(__fd: ::std::os::raw::c_int,
                     __path: *const ::std::os::raw::c_char,
                     __times: *const timespec, __flags: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn futimens(__fd: ::std::os::raw::c_int, __times: *const timespec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __fxstat(__ver: ::std::os::raw::c_int,
                    __fildes: ::std::os::raw::c_int, __stat_buf: *mut stat)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __xstat(__ver: ::std::os::raw::c_int,
                   __filename: *const ::std::os::raw::c_char,
                   __stat_buf: *mut stat) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __lxstat(__ver: ::std::os::raw::c_int,
                    __filename: *const ::std::os::raw::c_char,
                    __stat_buf: *mut stat) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __fxstatat(__ver: ::std::os::raw::c_int,
                      __fildes: ::std::os::raw::c_int,
                      __filename: *const ::std::os::raw::c_char,
                      __stat_buf: *mut stat, __flag: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __xmknod(__ver: ::std::os::raw::c_int,
                    __path: *const ::std::os::raw::c_char, __mode: __mode_t,
                    __dev: *mut __dev_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __xmknodat(__ver: ::std::os::raw::c_int,
                      __fd: ::std::os::raw::c_int,
                      __path: *const ::std::os::raw::c_char, __mode: __mode_t,
                      __dev: *mut __dev_t) -> ::std::os::raw::c_int;
}
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct wait {
    pub w_status: __BindgenUnionField<::std::os::raw::c_int>,
    pub __wait_terminated: __BindgenUnionField<wait__bindgen_ty_1>,
    pub __wait_stopped: __BindgenUnionField<wait__bindgen_ty_2>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct wait__bindgen_ty_1 {
    pub _bitfield_1: [u16; 2usize],
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<wait__bindgen_ty_1>() , 4usize , concat !
               ( "Size of: " , stringify ! ( wait__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<wait__bindgen_ty_1>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( wait__bindgen_ty_1 ) ));
}
impl Clone for wait__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl wait__bindgen_ty_1 {
    #[inline]
    pub fn __w_termsig(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 127u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___w_termsig(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 127u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn __w_coredump(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 128u64 as u32;
        let val = (unit_field_val & mask) >> 7usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___w_coredump(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 128u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 7usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn __w_retcode(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 65280u64 as u32;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___w_retcode(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 65280u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(__w_termsig: ::std::os::raw::c_uint,
                          __w_coredump: ::std::os::raw::c_uint,
                          __w_retcode: ::std::os::raw::c_uint) -> u32 {
        ({
             ({
                  ({ 0 } |
                       ((__w_termsig as u32 as u32) << 0usize) &
                           (127u64 as u32))
              } | ((__w_coredump as u32 as u32) << 7usize) & (128u64 as u32))
         } | ((__w_retcode as u32 as u32) << 8usize) & (65280u64 as u32))
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct wait__bindgen_ty_2 {
    pub _bitfield_1: [u16; 2usize],
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<wait__bindgen_ty_2>() , 4usize , concat !
               ( "Size of: " , stringify ! ( wait__bindgen_ty_2 ) ));
    assert_eq! (::std::mem::align_of::<wait__bindgen_ty_2>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( wait__bindgen_ty_2 ) ));
}
impl Clone for wait__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl wait__bindgen_ty_2 {
    #[inline]
    pub fn __w_stopval(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 255u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___w_stopval(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 255u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn __w_stopsig(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 65280u64 as u32;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___w_stopsig(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 65280u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(__w_stopval: ::std::os::raw::c_uint,
                          __w_stopsig: ::std::os::raw::c_uint) -> u32 {
        ({
             ({ 0 } |
                  ((__w_stopval as u32 as u32) << 0usize) & (255u64 as u32))
         } | ((__w_stopsig as u32 as u32) << 8usize) & (65280u64 as u32))
    }
}
#[test]
fn bindgen_test_layout_wait() {
    assert_eq!(::std::mem::size_of::<wait>() , 4usize , concat ! (
               "Size of: " , stringify ! ( wait ) ));
    assert_eq! (::std::mem::align_of::<wait>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( wait ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const wait ) ) . w_status as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( wait ) , "::" ,
                stringify ! ( w_status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const wait ) ) . __wait_terminated as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( wait ) , "::" ,
                stringify ! ( __wait_terminated ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const wait ) ) . __wait_stopped as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( wait ) , "::" ,
                stringify ! ( __wait_stopped ) ));
}
impl Clone for wait {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __WAIT_STATUS {
    pub __uptr: __BindgenUnionField<*mut wait>,
    pub __iptr: __BindgenUnionField<*mut ::std::os::raw::c_int>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout___WAIT_STATUS() {
    assert_eq!(::std::mem::size_of::<__WAIT_STATUS>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __WAIT_STATUS ) ));
    assert_eq! (::std::mem::align_of::<__WAIT_STATUS>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __WAIT_STATUS ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __WAIT_STATUS ) ) . __uptr as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __WAIT_STATUS ) , "::"
                , stringify ! ( __uptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __WAIT_STATUS ) ) . __iptr as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __WAIT_STATUS ) , "::"
                , stringify ! ( __iptr ) ));
}
impl Clone for __WAIT_STATUS {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(::std::mem::size_of::<div_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( div_t ) ));
    assert_eq! (::std::mem::align_of::<div_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( div_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const div_t ) ) . quot as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( div_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const div_t ) ) . rem as * const _ as usize } ,
                4usize , concat ! (
                "Alignment of field: " , stringify ! ( div_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for div_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(::std::mem::size_of::<ldiv_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ldiv_t ) ));
    assert_eq! (::std::mem::align_of::<ldiv_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ldiv_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ldiv_t ) ) . quot as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ldiv_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ldiv_t ) ) . rem as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ldiv_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for ldiv_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(::std::mem::size_of::<lldiv_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( lldiv_t ) ));
    assert_eq! (::std::mem::align_of::<lldiv_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lldiv_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lldiv_t ) ) . quot as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lldiv_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lldiv_t ) ) . rem as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lldiv_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for lldiv_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn strtof(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn strtold(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn strtol(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char,
                  __base: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char,
                   __base: ::std::os::raw::c_int) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char,
                  __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char,
                   __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char,
                   __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(__nptr: *const ::std::os::raw::c_char,
                    __endptr: *mut *mut ::std::os::raw::c_char,
                    __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(__seed: ::std::os::raw::c_uint,
                     __statebuf: *mut ::std::os::raw::c_char,
                     __statelen: usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    assert_eq!(::std::mem::size_of::<random_data>() , 48usize , concat ! (
               "Size of: " , stringify ! ( random_data ) ));
    assert_eq! (::std::mem::align_of::<random_data>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( random_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . fptr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( fptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . rptr as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( rptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . state as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . rand_type as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( rand_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . rand_deg as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( rand_deg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . rand_sep as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( rand_sep ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . end_ptr as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( end_ptr ) ));
}
impl Clone for random_data {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(__seed: ::std::os::raw::c_uint, __buf: *mut random_data)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(__seed: ::std::os::raw::c_uint,
                       __statebuf: *mut ::std::os::raw::c_char,
                       __statelen: usize, __buf: *mut random_data)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(__statebuf: *mut ::std::os::raw::c_char,
                      __buf: *mut random_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort)
     -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    assert_eq!(::std::mem::size_of::<drand48_data>() , 24usize , concat ! (
               "Size of: " , stringify ! ( drand48_data ) ));
    assert_eq! (::std::mem::align_of::<drand48_data>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( drand48_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __x as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __old_x as * const _
                as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __old_x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __c as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __c ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __init as * const _ as
                usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __init ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __a as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __a ) ));
}
impl Clone for drand48_data {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(__xsubi: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut drand48_data, __result: *mut f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(__buffer: *mut drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(__xsubi: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(__buffer: *mut drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(__xsubi: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(__seedval: ::std::os::raw::c_long,
                     __buffer: *mut drand48_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(__seed16v: *mut ::std::os::raw::c_ushort,
                    __buffer: *mut drand48_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(__param: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut drand48_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(__nmemb: usize, __size: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(__ptr: *mut ::std::os::raw::c_void, __size: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn cfree(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn alloca(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(__memptr: *mut *mut ::std::os::raw::c_void,
                          __alignment: usize, __size: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(__alignment: usize, __size: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(__func:
                             ::std::option::Option<unsafe extern "C" fn()>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(__func:
                       ::std::option::Option<unsafe extern "C" fn(__status:
                                                                      ::std::os::raw::c_int,
                                                                  __arg:
                                                                      *mut ::std::os::raw::c_void)>,
                   __arg: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(__name: *const ::std::os::raw::c_char,
                  __value: *const ::std::os::raw::c_char,
                  __replace: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(__template: *mut ::std::os::raw::c_char,
                    __suffixlen: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(__name: *const ::std::os::raw::c_char,
                    __resolved: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *const ::std::os::raw::c_void,
                                               arg2:
                                                   *const ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
extern "C" {
    pub fn bsearch(__key: *const ::std::os::raw::c_void,
                   __base: *const ::std::os::raw::c_void, __nmemb: usize,
                   __size: usize, __compar: __compar_fn_t)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(__base: *mut ::std::os::raw::c_void, __nmemb: usize,
                 __size: usize, __compar: __compar_fn_t);
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int)
     -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long,
                __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(__numer: ::std::os::raw::c_longlong,
                 __denom: ::std::os::raw::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                __decpt: *mut ::std::os::raw::c_int,
                __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                __decpt: *mut ::std::os::raw::c_int,
                __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                __buf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                 __decpt: *mut ::std::os::raw::c_int,
                 __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                 __decpt: *mut ::std::os::raw::c_int,
                 __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                 __buf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(__value: f64, __ndigit: ::std::os::raw::c_int,
                  __decpt: *mut ::std::os::raw::c_int,
                  __sign: *mut ::std::os::raw::c_int,
                  __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(__value: f64, __ndigit: ::std::os::raw::c_int,
                  __decpt: *mut ::std::os::raw::c_int,
                  __sign: *mut ::std::os::raw::c_int,
                  __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(__value: f64, __ndigit: ::std::os::raw::c_int,
                   __decpt: *mut ::std::os::raw::c_int,
                   __sign: *mut ::std::os::raw::c_int,
                   __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(__value: f64, __ndigit: ::std::os::raw::c_int,
                   __decpt: *mut ::std::os::raw::c_int,
                   __sign: *mut ::std::os::raw::c_int,
                   __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(__pwc: *mut wchar_t, __s: *const ::std::os::raw::c_char,
                  __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char,
                    __n: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t,
                    __n: usize) -> usize;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(__optionp: *mut *mut ::std::os::raw::c_char,
                     __tokens: *const *const ::std::os::raw::c_char,
                     __valuep: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
pub type useconds_t = __useconds_t;
pub type socklen_t = __socklen_t;
extern "C" {
    pub fn access(__name: *const ::std::os::raw::c_char,
                  __type: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faccessat(__fd: ::std::os::raw::c_int,
                     __file: *const ::std::os::raw::c_char,
                     __type: ::std::os::raw::c_int,
                     __flag: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lseek(__fd: ::std::os::raw::c_int, __offset: __off_t,
                 __whence: ::std::os::raw::c_int) -> __off_t;
}
extern "C" {
    pub fn close(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn read(__fd: ::std::os::raw::c_int,
                __buf: *mut ::std::os::raw::c_void, __nbytes: usize) -> isize;
}
extern "C" {
    pub fn write(__fd: ::std::os::raw::c_int,
                 __buf: *const ::std::os::raw::c_void, __n: usize) -> isize;
}
extern "C" {
    pub fn pread(__fd: ::std::os::raw::c_int,
                 __buf: *mut ::std::os::raw::c_void, __nbytes: usize,
                 __offset: __off_t) -> isize;
}
extern "C" {
    pub fn pwrite(__fd: ::std::os::raw::c_int,
                  __buf: *const ::std::os::raw::c_void, __n: usize,
                  __offset: __off_t) -> isize;
}
extern "C" {
    pub fn pipe(__pipedes: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alarm(__seconds: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn sleep(__seconds: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn ualarm(__value: __useconds_t, __interval: __useconds_t)
     -> __useconds_t;
}
extern "C" {
    pub fn usleep(__useconds: __useconds_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pause() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chown(__file: *const ::std::os::raw::c_char, __owner: __uid_t,
                 __group: __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchown(__fd: ::std::os::raw::c_int, __owner: __uid_t,
                  __group: __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lchown(__file: *const ::std::os::raw::c_char, __owner: __uid_t,
                  __group: __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchownat(__fd: ::std::os::raw::c_int,
                    __file: *const ::std::os::raw::c_char, __owner: __uid_t,
                    __group: __gid_t, __flag: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chdir(__path: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchdir(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getcwd(__buf: *mut ::std::os::raw::c_char, __size: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getwd(__buf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn dup(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dup2(__fd: ::std::os::raw::c_int, __fd2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__environ"]
    pub static mut __environ: *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn execve(__path: *const ::std::os::raw::c_char,
                  __argv: *const *const ::std::os::raw::c_char,
                  __envp: *const *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fexecve(__fd: ::std::os::raw::c_int,
                   __argv: *const *const ::std::os::raw::c_char,
                   __envp: *const *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execv(__path: *const ::std::os::raw::c_char,
                 __argv: *const *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execle(__path: *const ::std::os::raw::c_char,
                  __arg: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execl(__path: *const ::std::os::raw::c_char,
                 __arg: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execvp(__file: *const ::std::os::raw::c_char,
                  __argv: *const *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execlp(__file: *const ::std::os::raw::c_char,
                  __arg: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nice(__inc: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _exit(__status: ::std::os::raw::c_int);
}
pub const _PC_LINK_MAX: _bindgen_ty_1 = _bindgen_ty_1::_PC_LINK_MAX;
pub const _PC_MAX_CANON: _bindgen_ty_1 = _bindgen_ty_1::_PC_MAX_CANON;
pub const _PC_MAX_INPUT: _bindgen_ty_1 = _bindgen_ty_1::_PC_MAX_INPUT;
pub const _PC_NAME_MAX: _bindgen_ty_1 = _bindgen_ty_1::_PC_NAME_MAX;
pub const _PC_PATH_MAX: _bindgen_ty_1 = _bindgen_ty_1::_PC_PATH_MAX;
pub const _PC_PIPE_BUF: _bindgen_ty_1 = _bindgen_ty_1::_PC_PIPE_BUF;
pub const _PC_CHOWN_RESTRICTED: _bindgen_ty_1 =
    _bindgen_ty_1::_PC_CHOWN_RESTRICTED;
pub const _PC_NO_TRUNC: _bindgen_ty_1 = _bindgen_ty_1::_PC_NO_TRUNC;
pub const _PC_VDISABLE: _bindgen_ty_1 = _bindgen_ty_1::_PC_VDISABLE;
pub const _PC_SYNC_IO: _bindgen_ty_1 = _bindgen_ty_1::_PC_SYNC_IO;
pub const _PC_ASYNC_IO: _bindgen_ty_1 = _bindgen_ty_1::_PC_ASYNC_IO;
pub const _PC_PRIO_IO: _bindgen_ty_1 = _bindgen_ty_1::_PC_PRIO_IO;
pub const _PC_SOCK_MAXBUF: _bindgen_ty_1 = _bindgen_ty_1::_PC_SOCK_MAXBUF;
pub const _PC_FILESIZEBITS: _bindgen_ty_1 = _bindgen_ty_1::_PC_FILESIZEBITS;
pub const _PC_REC_INCR_XFER_SIZE: _bindgen_ty_1 =
    _bindgen_ty_1::_PC_REC_INCR_XFER_SIZE;
pub const _PC_REC_MAX_XFER_SIZE: _bindgen_ty_1 =
    _bindgen_ty_1::_PC_REC_MAX_XFER_SIZE;
pub const _PC_REC_MIN_XFER_SIZE: _bindgen_ty_1 =
    _bindgen_ty_1::_PC_REC_MIN_XFER_SIZE;
pub const _PC_REC_XFER_ALIGN: _bindgen_ty_1 =
    _bindgen_ty_1::_PC_REC_XFER_ALIGN;
pub const _PC_ALLOC_SIZE_MIN: _bindgen_ty_1 =
    _bindgen_ty_1::_PC_ALLOC_SIZE_MIN;
pub const _PC_SYMLINK_MAX: _bindgen_ty_1 = _bindgen_ty_1::_PC_SYMLINK_MAX;
pub const _PC_2_SYMLINKS: _bindgen_ty_1 = _bindgen_ty_1::_PC_2_SYMLINKS;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_1 {
    _PC_LINK_MAX = 0,
    _PC_MAX_CANON = 1,
    _PC_MAX_INPUT = 2,
    _PC_NAME_MAX = 3,
    _PC_PATH_MAX = 4,
    _PC_PIPE_BUF = 5,
    _PC_CHOWN_RESTRICTED = 6,
    _PC_NO_TRUNC = 7,
    _PC_VDISABLE = 8,
    _PC_SYNC_IO = 9,
    _PC_ASYNC_IO = 10,
    _PC_PRIO_IO = 11,
    _PC_SOCK_MAXBUF = 12,
    _PC_FILESIZEBITS = 13,
    _PC_REC_INCR_XFER_SIZE = 14,
    _PC_REC_MAX_XFER_SIZE = 15,
    _PC_REC_MIN_XFER_SIZE = 16,
    _PC_REC_XFER_ALIGN = 17,
    _PC_ALLOC_SIZE_MIN = 18,
    _PC_SYMLINK_MAX = 19,
    _PC_2_SYMLINKS = 20,
}
pub const _SC_ARG_MAX: _bindgen_ty_2 = _bindgen_ty_2::_SC_ARG_MAX;
pub const _SC_CHILD_MAX: _bindgen_ty_2 = _bindgen_ty_2::_SC_CHILD_MAX;
pub const _SC_CLK_TCK: _bindgen_ty_2 = _bindgen_ty_2::_SC_CLK_TCK;
pub const _SC_NGROUPS_MAX: _bindgen_ty_2 = _bindgen_ty_2::_SC_NGROUPS_MAX;
pub const _SC_OPEN_MAX: _bindgen_ty_2 = _bindgen_ty_2::_SC_OPEN_MAX;
pub const _SC_STREAM_MAX: _bindgen_ty_2 = _bindgen_ty_2::_SC_STREAM_MAX;
pub const _SC_TZNAME_MAX: _bindgen_ty_2 = _bindgen_ty_2::_SC_TZNAME_MAX;
pub const _SC_JOB_CONTROL: _bindgen_ty_2 = _bindgen_ty_2::_SC_JOB_CONTROL;
pub const _SC_SAVED_IDS: _bindgen_ty_2 = _bindgen_ty_2::_SC_SAVED_IDS;
pub const _SC_REALTIME_SIGNALS: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_REALTIME_SIGNALS;
pub const _SC_PRIORITY_SCHEDULING: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_PRIORITY_SCHEDULING;
pub const _SC_TIMERS: _bindgen_ty_2 = _bindgen_ty_2::_SC_TIMERS;
pub const _SC_ASYNCHRONOUS_IO: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_ASYNCHRONOUS_IO;
pub const _SC_PRIORITIZED_IO: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_PRIORITIZED_IO;
pub const _SC_SYNCHRONIZED_IO: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_SYNCHRONIZED_IO;
pub const _SC_FSYNC: _bindgen_ty_2 = _bindgen_ty_2::_SC_FSYNC;
pub const _SC_MAPPED_FILES: _bindgen_ty_2 = _bindgen_ty_2::_SC_MAPPED_FILES;
pub const _SC_MEMLOCK: _bindgen_ty_2 = _bindgen_ty_2::_SC_MEMLOCK;
pub const _SC_MEMLOCK_RANGE: _bindgen_ty_2 = _bindgen_ty_2::_SC_MEMLOCK_RANGE;
pub const _SC_MEMORY_PROTECTION: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_MEMORY_PROTECTION;
pub const _SC_MESSAGE_PASSING: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_MESSAGE_PASSING;
pub const _SC_SEMAPHORES: _bindgen_ty_2 = _bindgen_ty_2::_SC_SEMAPHORES;
pub const _SC_SHARED_MEMORY_OBJECTS: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_SHARED_MEMORY_OBJECTS;
pub const _SC_AIO_LISTIO_MAX: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_AIO_LISTIO_MAX;
pub const _SC_AIO_MAX: _bindgen_ty_2 = _bindgen_ty_2::_SC_AIO_MAX;
pub const _SC_AIO_PRIO_DELTA_MAX: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_AIO_PRIO_DELTA_MAX;
pub const _SC_DELAYTIMER_MAX: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_DELAYTIMER_MAX;
pub const _SC_MQ_OPEN_MAX: _bindgen_ty_2 = _bindgen_ty_2::_SC_MQ_OPEN_MAX;
pub const _SC_MQ_PRIO_MAX: _bindgen_ty_2 = _bindgen_ty_2::_SC_MQ_PRIO_MAX;
pub const _SC_VERSION: _bindgen_ty_2 = _bindgen_ty_2::_SC_VERSION;
pub const _SC_PAGESIZE: _bindgen_ty_2 = _bindgen_ty_2::_SC_PAGESIZE;
pub const _SC_RTSIG_MAX: _bindgen_ty_2 = _bindgen_ty_2::_SC_RTSIG_MAX;
pub const _SC_SEM_NSEMS_MAX: _bindgen_ty_2 = _bindgen_ty_2::_SC_SEM_NSEMS_MAX;
pub const _SC_SEM_VALUE_MAX: _bindgen_ty_2 = _bindgen_ty_2::_SC_SEM_VALUE_MAX;
pub const _SC_SIGQUEUE_MAX: _bindgen_ty_2 = _bindgen_ty_2::_SC_SIGQUEUE_MAX;
pub const _SC_TIMER_MAX: _bindgen_ty_2 = _bindgen_ty_2::_SC_TIMER_MAX;
pub const _SC_BC_BASE_MAX: _bindgen_ty_2 = _bindgen_ty_2::_SC_BC_BASE_MAX;
pub const _SC_BC_DIM_MAX: _bindgen_ty_2 = _bindgen_ty_2::_SC_BC_DIM_MAX;
pub const _SC_BC_SCALE_MAX: _bindgen_ty_2 = _bindgen_ty_2::_SC_BC_SCALE_MAX;
pub const _SC_BC_STRING_MAX: _bindgen_ty_2 = _bindgen_ty_2::_SC_BC_STRING_MAX;
pub const _SC_COLL_WEIGHTS_MAX: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_COLL_WEIGHTS_MAX;
pub const _SC_EQUIV_CLASS_MAX: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_EQUIV_CLASS_MAX;
pub const _SC_EXPR_NEST_MAX: _bindgen_ty_2 = _bindgen_ty_2::_SC_EXPR_NEST_MAX;
pub const _SC_LINE_MAX: _bindgen_ty_2 = _bindgen_ty_2::_SC_LINE_MAX;
pub const _SC_RE_DUP_MAX: _bindgen_ty_2 = _bindgen_ty_2::_SC_RE_DUP_MAX;
pub const _SC_CHARCLASS_NAME_MAX: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_CHARCLASS_NAME_MAX;
pub const _SC_2_VERSION: _bindgen_ty_2 = _bindgen_ty_2::_SC_2_VERSION;
pub const _SC_2_C_BIND: _bindgen_ty_2 = _bindgen_ty_2::_SC_2_C_BIND;
pub const _SC_2_C_DEV: _bindgen_ty_2 = _bindgen_ty_2::_SC_2_C_DEV;
pub const _SC_2_FORT_DEV: _bindgen_ty_2 = _bindgen_ty_2::_SC_2_FORT_DEV;
pub const _SC_2_FORT_RUN: _bindgen_ty_2 = _bindgen_ty_2::_SC_2_FORT_RUN;
pub const _SC_2_SW_DEV: _bindgen_ty_2 = _bindgen_ty_2::_SC_2_SW_DEV;
pub const _SC_2_LOCALEDEF: _bindgen_ty_2 = _bindgen_ty_2::_SC_2_LOCALEDEF;
pub const _SC_PII: _bindgen_ty_2 = _bindgen_ty_2::_SC_PII;
pub const _SC_PII_XTI: _bindgen_ty_2 = _bindgen_ty_2::_SC_PII_XTI;
pub const _SC_PII_SOCKET: _bindgen_ty_2 = _bindgen_ty_2::_SC_PII_SOCKET;
pub const _SC_PII_INTERNET: _bindgen_ty_2 = _bindgen_ty_2::_SC_PII_INTERNET;
pub const _SC_PII_OSI: _bindgen_ty_2 = _bindgen_ty_2::_SC_PII_OSI;
pub const _SC_POLL: _bindgen_ty_2 = _bindgen_ty_2::_SC_POLL;
pub const _SC_SELECT: _bindgen_ty_2 = _bindgen_ty_2::_SC_SELECT;
pub const _SC_UIO_MAXIOV: _bindgen_ty_2 = _bindgen_ty_2::_SC_UIO_MAXIOV;
pub const _SC_IOV_MAX: _bindgen_ty_2 = _bindgen_ty_2::_SC_UIO_MAXIOV;
pub const _SC_PII_INTERNET_STREAM: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_PII_INTERNET_STREAM;
pub const _SC_PII_INTERNET_DGRAM: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_PII_INTERNET_DGRAM;
pub const _SC_PII_OSI_COTS: _bindgen_ty_2 = _bindgen_ty_2::_SC_PII_OSI_COTS;
pub const _SC_PII_OSI_CLTS: _bindgen_ty_2 = _bindgen_ty_2::_SC_PII_OSI_CLTS;
pub const _SC_PII_OSI_M: _bindgen_ty_2 = _bindgen_ty_2::_SC_PII_OSI_M;
pub const _SC_T_IOV_MAX: _bindgen_ty_2 = _bindgen_ty_2::_SC_T_IOV_MAX;
pub const _SC_THREADS: _bindgen_ty_2 = _bindgen_ty_2::_SC_THREADS;
pub const _SC_THREAD_SAFE_FUNCTIONS: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_THREAD_SAFE_FUNCTIONS;
pub const _SC_GETGR_R_SIZE_MAX: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_GETGR_R_SIZE_MAX;
pub const _SC_GETPW_R_SIZE_MAX: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_GETPW_R_SIZE_MAX;
pub const _SC_LOGIN_NAME_MAX: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_LOGIN_NAME_MAX;
pub const _SC_TTY_NAME_MAX: _bindgen_ty_2 = _bindgen_ty_2::_SC_TTY_NAME_MAX;
pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_THREAD_DESTRUCTOR_ITERATIONS;
pub const _SC_THREAD_KEYS_MAX: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_THREAD_KEYS_MAX;
pub const _SC_THREAD_STACK_MIN: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_THREAD_STACK_MIN;
pub const _SC_THREAD_THREADS_MAX: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_THREAD_THREADS_MAX;
pub const _SC_THREAD_ATTR_STACKADDR: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_THREAD_ATTR_STACKADDR;
pub const _SC_THREAD_ATTR_STACKSIZE: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_THREAD_ATTR_STACKSIZE;
pub const _SC_THREAD_PRIORITY_SCHEDULING: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_THREAD_PRIORITY_SCHEDULING;
pub const _SC_THREAD_PRIO_INHERIT: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_THREAD_PRIO_INHERIT;
pub const _SC_THREAD_PRIO_PROTECT: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_THREAD_PRIO_PROTECT;
pub const _SC_THREAD_PROCESS_SHARED: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_THREAD_PROCESS_SHARED;
pub const _SC_NPROCESSORS_CONF: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_NPROCESSORS_CONF;
pub const _SC_NPROCESSORS_ONLN: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_NPROCESSORS_ONLN;
pub const _SC_PHYS_PAGES: _bindgen_ty_2 = _bindgen_ty_2::_SC_PHYS_PAGES;
pub const _SC_AVPHYS_PAGES: _bindgen_ty_2 = _bindgen_ty_2::_SC_AVPHYS_PAGES;
pub const _SC_ATEXIT_MAX: _bindgen_ty_2 = _bindgen_ty_2::_SC_ATEXIT_MAX;
pub const _SC_PASS_MAX: _bindgen_ty_2 = _bindgen_ty_2::_SC_PASS_MAX;
pub const _SC_XOPEN_VERSION: _bindgen_ty_2 = _bindgen_ty_2::_SC_XOPEN_VERSION;
pub const _SC_XOPEN_XCU_VERSION: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_XOPEN_XCU_VERSION;
pub const _SC_XOPEN_UNIX: _bindgen_ty_2 = _bindgen_ty_2::_SC_XOPEN_UNIX;
pub const _SC_XOPEN_CRYPT: _bindgen_ty_2 = _bindgen_ty_2::_SC_XOPEN_CRYPT;
pub const _SC_XOPEN_ENH_I18N: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_XOPEN_ENH_I18N;
pub const _SC_XOPEN_SHM: _bindgen_ty_2 = _bindgen_ty_2::_SC_XOPEN_SHM;
pub const _SC_2_CHAR_TERM: _bindgen_ty_2 = _bindgen_ty_2::_SC_2_CHAR_TERM;
pub const _SC_2_C_VERSION: _bindgen_ty_2 = _bindgen_ty_2::_SC_2_C_VERSION;
pub const _SC_2_UPE: _bindgen_ty_2 = _bindgen_ty_2::_SC_2_UPE;
pub const _SC_XOPEN_XPG2: _bindgen_ty_2 = _bindgen_ty_2::_SC_XOPEN_XPG2;
pub const _SC_XOPEN_XPG3: _bindgen_ty_2 = _bindgen_ty_2::_SC_XOPEN_XPG3;
pub const _SC_XOPEN_XPG4: _bindgen_ty_2 = _bindgen_ty_2::_SC_XOPEN_XPG4;
pub const _SC_CHAR_BIT: _bindgen_ty_2 = _bindgen_ty_2::_SC_CHAR_BIT;
pub const _SC_CHAR_MAX: _bindgen_ty_2 = _bindgen_ty_2::_SC_CHAR_MAX;
pub const _SC_CHAR_MIN: _bindgen_ty_2 = _bindgen_ty_2::_SC_CHAR_MIN;
pub const _SC_INT_MAX: _bindgen_ty_2 = _bindgen_ty_2::_SC_INT_MAX;
pub const _SC_INT_MIN: _bindgen_ty_2 = _bindgen_ty_2::_SC_INT_MIN;
pub const _SC_LONG_BIT: _bindgen_ty_2 = _bindgen_ty_2::_SC_LONG_BIT;
pub const _SC_WORD_BIT: _bindgen_ty_2 = _bindgen_ty_2::_SC_WORD_BIT;
pub const _SC_MB_LEN_MAX: _bindgen_ty_2 = _bindgen_ty_2::_SC_MB_LEN_MAX;
pub const _SC_NZERO: _bindgen_ty_2 = _bindgen_ty_2::_SC_NZERO;
pub const _SC_SSIZE_MAX: _bindgen_ty_2 = _bindgen_ty_2::_SC_SSIZE_MAX;
pub const _SC_SCHAR_MAX: _bindgen_ty_2 = _bindgen_ty_2::_SC_SCHAR_MAX;
pub const _SC_SCHAR_MIN: _bindgen_ty_2 = _bindgen_ty_2::_SC_SCHAR_MIN;
pub const _SC_SHRT_MAX: _bindgen_ty_2 = _bindgen_ty_2::_SC_SHRT_MAX;
pub const _SC_SHRT_MIN: _bindgen_ty_2 = _bindgen_ty_2::_SC_SHRT_MIN;
pub const _SC_UCHAR_MAX: _bindgen_ty_2 = _bindgen_ty_2::_SC_UCHAR_MAX;
pub const _SC_UINT_MAX: _bindgen_ty_2 = _bindgen_ty_2::_SC_UINT_MAX;
pub const _SC_ULONG_MAX: _bindgen_ty_2 = _bindgen_ty_2::_SC_ULONG_MAX;
pub const _SC_USHRT_MAX: _bindgen_ty_2 = _bindgen_ty_2::_SC_USHRT_MAX;
pub const _SC_NL_ARGMAX: _bindgen_ty_2 = _bindgen_ty_2::_SC_NL_ARGMAX;
pub const _SC_NL_LANGMAX: _bindgen_ty_2 = _bindgen_ty_2::_SC_NL_LANGMAX;
pub const _SC_NL_MSGMAX: _bindgen_ty_2 = _bindgen_ty_2::_SC_NL_MSGMAX;
pub const _SC_NL_NMAX: _bindgen_ty_2 = _bindgen_ty_2::_SC_NL_NMAX;
pub const _SC_NL_SETMAX: _bindgen_ty_2 = _bindgen_ty_2::_SC_NL_SETMAX;
pub const _SC_NL_TEXTMAX: _bindgen_ty_2 = _bindgen_ty_2::_SC_NL_TEXTMAX;
pub const _SC_XBS5_ILP32_OFF32: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_XBS5_ILP32_OFF32;
pub const _SC_XBS5_ILP32_OFFBIG: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_XBS5_ILP32_OFFBIG;
pub const _SC_XBS5_LP64_OFF64: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_XBS5_LP64_OFF64;
pub const _SC_XBS5_LPBIG_OFFBIG: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_XBS5_LPBIG_OFFBIG;
pub const _SC_XOPEN_LEGACY: _bindgen_ty_2 = _bindgen_ty_2::_SC_XOPEN_LEGACY;
pub const _SC_XOPEN_REALTIME: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_XOPEN_REALTIME;
pub const _SC_XOPEN_REALTIME_THREADS: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_XOPEN_REALTIME_THREADS;
pub const _SC_ADVISORY_INFO: _bindgen_ty_2 = _bindgen_ty_2::_SC_ADVISORY_INFO;
pub const _SC_BARRIERS: _bindgen_ty_2 = _bindgen_ty_2::_SC_BARRIERS;
pub const _SC_BASE: _bindgen_ty_2 = _bindgen_ty_2::_SC_BASE;
pub const _SC_C_LANG_SUPPORT: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_C_LANG_SUPPORT;
pub const _SC_C_LANG_SUPPORT_R: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_C_LANG_SUPPORT_R;
pub const _SC_CLOCK_SELECTION: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_CLOCK_SELECTION;
pub const _SC_CPUTIME: _bindgen_ty_2 = _bindgen_ty_2::_SC_CPUTIME;
pub const _SC_THREAD_CPUTIME: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_THREAD_CPUTIME;
pub const _SC_DEVICE_IO: _bindgen_ty_2 = _bindgen_ty_2::_SC_DEVICE_IO;
pub const _SC_DEVICE_SPECIFIC: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_DEVICE_SPECIFIC;
pub const _SC_DEVICE_SPECIFIC_R: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_DEVICE_SPECIFIC_R;
pub const _SC_FD_MGMT: _bindgen_ty_2 = _bindgen_ty_2::_SC_FD_MGMT;
pub const _SC_FIFO: _bindgen_ty_2 = _bindgen_ty_2::_SC_FIFO;
pub const _SC_PIPE: _bindgen_ty_2 = _bindgen_ty_2::_SC_PIPE;
pub const _SC_FILE_ATTRIBUTES: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_FILE_ATTRIBUTES;
pub const _SC_FILE_LOCKING: _bindgen_ty_2 = _bindgen_ty_2::_SC_FILE_LOCKING;
pub const _SC_FILE_SYSTEM: _bindgen_ty_2 = _bindgen_ty_2::_SC_FILE_SYSTEM;
pub const _SC_MONOTONIC_CLOCK: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_MONOTONIC_CLOCK;
pub const _SC_MULTI_PROCESS: _bindgen_ty_2 = _bindgen_ty_2::_SC_MULTI_PROCESS;
pub const _SC_SINGLE_PROCESS: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_SINGLE_PROCESS;
pub const _SC_NETWORKING: _bindgen_ty_2 = _bindgen_ty_2::_SC_NETWORKING;
pub const _SC_READER_WRITER_LOCKS: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_READER_WRITER_LOCKS;
pub const _SC_SPIN_LOCKS: _bindgen_ty_2 = _bindgen_ty_2::_SC_SPIN_LOCKS;
pub const _SC_REGEXP: _bindgen_ty_2 = _bindgen_ty_2::_SC_REGEXP;
pub const _SC_REGEX_VERSION: _bindgen_ty_2 = _bindgen_ty_2::_SC_REGEX_VERSION;
pub const _SC_SHELL: _bindgen_ty_2 = _bindgen_ty_2::_SC_SHELL;
pub const _SC_SIGNALS: _bindgen_ty_2 = _bindgen_ty_2::_SC_SIGNALS;
pub const _SC_SPAWN: _bindgen_ty_2 = _bindgen_ty_2::_SC_SPAWN;
pub const _SC_SPORADIC_SERVER: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_SPORADIC_SERVER;
pub const _SC_THREAD_SPORADIC_SERVER: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_THREAD_SPORADIC_SERVER;
pub const _SC_SYSTEM_DATABASE: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_SYSTEM_DATABASE;
pub const _SC_SYSTEM_DATABASE_R: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_SYSTEM_DATABASE_R;
pub const _SC_TIMEOUTS: _bindgen_ty_2 = _bindgen_ty_2::_SC_TIMEOUTS;
pub const _SC_TYPED_MEMORY_OBJECTS: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_TYPED_MEMORY_OBJECTS;
pub const _SC_USER_GROUPS: _bindgen_ty_2 = _bindgen_ty_2::_SC_USER_GROUPS;
pub const _SC_USER_GROUPS_R: _bindgen_ty_2 = _bindgen_ty_2::_SC_USER_GROUPS_R;
pub const _SC_2_PBS: _bindgen_ty_2 = _bindgen_ty_2::_SC_2_PBS;
pub const _SC_2_PBS_ACCOUNTING: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_2_PBS_ACCOUNTING;
pub const _SC_2_PBS_LOCATE: _bindgen_ty_2 = _bindgen_ty_2::_SC_2_PBS_LOCATE;
pub const _SC_2_PBS_MESSAGE: _bindgen_ty_2 = _bindgen_ty_2::_SC_2_PBS_MESSAGE;
pub const _SC_2_PBS_TRACK: _bindgen_ty_2 = _bindgen_ty_2::_SC_2_PBS_TRACK;
pub const _SC_SYMLOOP_MAX: _bindgen_ty_2 = _bindgen_ty_2::_SC_SYMLOOP_MAX;
pub const _SC_STREAMS: _bindgen_ty_2 = _bindgen_ty_2::_SC_STREAMS;
pub const _SC_2_PBS_CHECKPOINT: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_2_PBS_CHECKPOINT;
pub const _SC_V6_ILP32_OFF32: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_V6_ILP32_OFF32;
pub const _SC_V6_ILP32_OFFBIG: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_V6_ILP32_OFFBIG;
pub const _SC_V6_LP64_OFF64: _bindgen_ty_2 = _bindgen_ty_2::_SC_V6_LP64_OFF64;
pub const _SC_V6_LPBIG_OFFBIG: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_V6_LPBIG_OFFBIG;
pub const _SC_HOST_NAME_MAX: _bindgen_ty_2 = _bindgen_ty_2::_SC_HOST_NAME_MAX;
pub const _SC_TRACE: _bindgen_ty_2 = _bindgen_ty_2::_SC_TRACE;
pub const _SC_TRACE_EVENT_FILTER: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_TRACE_EVENT_FILTER;
pub const _SC_TRACE_INHERIT: _bindgen_ty_2 = _bindgen_ty_2::_SC_TRACE_INHERIT;
pub const _SC_TRACE_LOG: _bindgen_ty_2 = _bindgen_ty_2::_SC_TRACE_LOG;
pub const _SC_LEVEL1_ICACHE_SIZE: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_LEVEL1_ICACHE_SIZE;
pub const _SC_LEVEL1_ICACHE_ASSOC: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_LEVEL1_ICACHE_ASSOC;
pub const _SC_LEVEL1_ICACHE_LINESIZE: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_LEVEL1_ICACHE_LINESIZE;
pub const _SC_LEVEL1_DCACHE_SIZE: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_LEVEL1_DCACHE_SIZE;
pub const _SC_LEVEL1_DCACHE_ASSOC: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_LEVEL1_DCACHE_ASSOC;
pub const _SC_LEVEL1_DCACHE_LINESIZE: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_LEVEL1_DCACHE_LINESIZE;
pub const _SC_LEVEL2_CACHE_SIZE: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_LEVEL2_CACHE_SIZE;
pub const _SC_LEVEL2_CACHE_ASSOC: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_LEVEL2_CACHE_ASSOC;
pub const _SC_LEVEL2_CACHE_LINESIZE: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_LEVEL2_CACHE_LINESIZE;
pub const _SC_LEVEL3_CACHE_SIZE: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_LEVEL3_CACHE_SIZE;
pub const _SC_LEVEL3_CACHE_ASSOC: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_LEVEL3_CACHE_ASSOC;
pub const _SC_LEVEL3_CACHE_LINESIZE: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_LEVEL3_CACHE_LINESIZE;
pub const _SC_LEVEL4_CACHE_SIZE: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_LEVEL4_CACHE_SIZE;
pub const _SC_LEVEL4_CACHE_ASSOC: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_LEVEL4_CACHE_ASSOC;
pub const _SC_LEVEL4_CACHE_LINESIZE: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_LEVEL4_CACHE_LINESIZE;
pub const _SC_IPV6: _bindgen_ty_2 = _bindgen_ty_2::_SC_IPV6;
pub const _SC_RAW_SOCKETS: _bindgen_ty_2 = _bindgen_ty_2::_SC_RAW_SOCKETS;
pub const _SC_V7_ILP32_OFF32: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_V7_ILP32_OFF32;
pub const _SC_V7_ILP32_OFFBIG: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_V7_ILP32_OFFBIG;
pub const _SC_V7_LP64_OFF64: _bindgen_ty_2 = _bindgen_ty_2::_SC_V7_LP64_OFF64;
pub const _SC_V7_LPBIG_OFFBIG: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_V7_LPBIG_OFFBIG;
pub const _SC_SS_REPL_MAX: _bindgen_ty_2 = _bindgen_ty_2::_SC_SS_REPL_MAX;
pub const _SC_TRACE_EVENT_NAME_MAX: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_TRACE_EVENT_NAME_MAX;
pub const _SC_TRACE_NAME_MAX: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_TRACE_NAME_MAX;
pub const _SC_TRACE_SYS_MAX: _bindgen_ty_2 = _bindgen_ty_2::_SC_TRACE_SYS_MAX;
pub const _SC_TRACE_USER_EVENT_MAX: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_TRACE_USER_EVENT_MAX;
pub const _SC_XOPEN_STREAMS: _bindgen_ty_2 = _bindgen_ty_2::_SC_XOPEN_STREAMS;
pub const _SC_THREAD_ROBUST_PRIO_INHERIT: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_THREAD_ROBUST_PRIO_INHERIT;
pub const _SC_THREAD_ROBUST_PRIO_PROTECT: _bindgen_ty_2 =
    _bindgen_ty_2::_SC_THREAD_ROBUST_PRIO_PROTECT;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_2 {
    _SC_ARG_MAX = 0,
    _SC_CHILD_MAX = 1,
    _SC_CLK_TCK = 2,
    _SC_NGROUPS_MAX = 3,
    _SC_OPEN_MAX = 4,
    _SC_STREAM_MAX = 5,
    _SC_TZNAME_MAX = 6,
    _SC_JOB_CONTROL = 7,
    _SC_SAVED_IDS = 8,
    _SC_REALTIME_SIGNALS = 9,
    _SC_PRIORITY_SCHEDULING = 10,
    _SC_TIMERS = 11,
    _SC_ASYNCHRONOUS_IO = 12,
    _SC_PRIORITIZED_IO = 13,
    _SC_SYNCHRONIZED_IO = 14,
    _SC_FSYNC = 15,
    _SC_MAPPED_FILES = 16,
    _SC_MEMLOCK = 17,
    _SC_MEMLOCK_RANGE = 18,
    _SC_MEMORY_PROTECTION = 19,
    _SC_MESSAGE_PASSING = 20,
    _SC_SEMAPHORES = 21,
    _SC_SHARED_MEMORY_OBJECTS = 22,
    _SC_AIO_LISTIO_MAX = 23,
    _SC_AIO_MAX = 24,
    _SC_AIO_PRIO_DELTA_MAX = 25,
    _SC_DELAYTIMER_MAX = 26,
    _SC_MQ_OPEN_MAX = 27,
    _SC_MQ_PRIO_MAX = 28,
    _SC_VERSION = 29,
    _SC_PAGESIZE = 30,
    _SC_RTSIG_MAX = 31,
    _SC_SEM_NSEMS_MAX = 32,
    _SC_SEM_VALUE_MAX = 33,
    _SC_SIGQUEUE_MAX = 34,
    _SC_TIMER_MAX = 35,
    _SC_BC_BASE_MAX = 36,
    _SC_BC_DIM_MAX = 37,
    _SC_BC_SCALE_MAX = 38,
    _SC_BC_STRING_MAX = 39,
    _SC_COLL_WEIGHTS_MAX = 40,
    _SC_EQUIV_CLASS_MAX = 41,
    _SC_EXPR_NEST_MAX = 42,
    _SC_LINE_MAX = 43,
    _SC_RE_DUP_MAX = 44,
    _SC_CHARCLASS_NAME_MAX = 45,
    _SC_2_VERSION = 46,
    _SC_2_C_BIND = 47,
    _SC_2_C_DEV = 48,
    _SC_2_FORT_DEV = 49,
    _SC_2_FORT_RUN = 50,
    _SC_2_SW_DEV = 51,
    _SC_2_LOCALEDEF = 52,
    _SC_PII = 53,
    _SC_PII_XTI = 54,
    _SC_PII_SOCKET = 55,
    _SC_PII_INTERNET = 56,
    _SC_PII_OSI = 57,
    _SC_POLL = 58,
    _SC_SELECT = 59,
    _SC_UIO_MAXIOV = 60,
    _SC_PII_INTERNET_STREAM = 61,
    _SC_PII_INTERNET_DGRAM = 62,
    _SC_PII_OSI_COTS = 63,
    _SC_PII_OSI_CLTS = 64,
    _SC_PII_OSI_M = 65,
    _SC_T_IOV_MAX = 66,
    _SC_THREADS = 67,
    _SC_THREAD_SAFE_FUNCTIONS = 68,
    _SC_GETGR_R_SIZE_MAX = 69,
    _SC_GETPW_R_SIZE_MAX = 70,
    _SC_LOGIN_NAME_MAX = 71,
    _SC_TTY_NAME_MAX = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS = 73,
    _SC_THREAD_KEYS_MAX = 74,
    _SC_THREAD_STACK_MIN = 75,
    _SC_THREAD_THREADS_MAX = 76,
    _SC_THREAD_ATTR_STACKADDR = 77,
    _SC_THREAD_ATTR_STACKSIZE = 78,
    _SC_THREAD_PRIORITY_SCHEDULING = 79,
    _SC_THREAD_PRIO_INHERIT = 80,
    _SC_THREAD_PRIO_PROTECT = 81,
    _SC_THREAD_PROCESS_SHARED = 82,
    _SC_NPROCESSORS_CONF = 83,
    _SC_NPROCESSORS_ONLN = 84,
    _SC_PHYS_PAGES = 85,
    _SC_AVPHYS_PAGES = 86,
    _SC_ATEXIT_MAX = 87,
    _SC_PASS_MAX = 88,
    _SC_XOPEN_VERSION = 89,
    _SC_XOPEN_XCU_VERSION = 90,
    _SC_XOPEN_UNIX = 91,
    _SC_XOPEN_CRYPT = 92,
    _SC_XOPEN_ENH_I18N = 93,
    _SC_XOPEN_SHM = 94,
    _SC_2_CHAR_TERM = 95,
    _SC_2_C_VERSION = 96,
    _SC_2_UPE = 97,
    _SC_XOPEN_XPG2 = 98,
    _SC_XOPEN_XPG3 = 99,
    _SC_XOPEN_XPG4 = 100,
    _SC_CHAR_BIT = 101,
    _SC_CHAR_MAX = 102,
    _SC_CHAR_MIN = 103,
    _SC_INT_MAX = 104,
    _SC_INT_MIN = 105,
    _SC_LONG_BIT = 106,
    _SC_WORD_BIT = 107,
    _SC_MB_LEN_MAX = 108,
    _SC_NZERO = 109,
    _SC_SSIZE_MAX = 110,
    _SC_SCHAR_MAX = 111,
    _SC_SCHAR_MIN = 112,
    _SC_SHRT_MAX = 113,
    _SC_SHRT_MIN = 114,
    _SC_UCHAR_MAX = 115,
    _SC_UINT_MAX = 116,
    _SC_ULONG_MAX = 117,
    _SC_USHRT_MAX = 118,
    _SC_NL_ARGMAX = 119,
    _SC_NL_LANGMAX = 120,
    _SC_NL_MSGMAX = 121,
    _SC_NL_NMAX = 122,
    _SC_NL_SETMAX = 123,
    _SC_NL_TEXTMAX = 124,
    _SC_XBS5_ILP32_OFF32 = 125,
    _SC_XBS5_ILP32_OFFBIG = 126,
    _SC_XBS5_LP64_OFF64 = 127,
    _SC_XBS5_LPBIG_OFFBIG = 128,
    _SC_XOPEN_LEGACY = 129,
    _SC_XOPEN_REALTIME = 130,
    _SC_XOPEN_REALTIME_THREADS = 131,
    _SC_ADVISORY_INFO = 132,
    _SC_BARRIERS = 133,
    _SC_BASE = 134,
    _SC_C_LANG_SUPPORT = 135,
    _SC_C_LANG_SUPPORT_R = 136,
    _SC_CLOCK_SELECTION = 137,
    _SC_CPUTIME = 138,
    _SC_THREAD_CPUTIME = 139,
    _SC_DEVICE_IO = 140,
    _SC_DEVICE_SPECIFIC = 141,
    _SC_DEVICE_SPECIFIC_R = 142,
    _SC_FD_MGMT = 143,
    _SC_FIFO = 144,
    _SC_PIPE = 145,
    _SC_FILE_ATTRIBUTES = 146,
    _SC_FILE_LOCKING = 147,
    _SC_FILE_SYSTEM = 148,
    _SC_MONOTONIC_CLOCK = 149,
    _SC_MULTI_PROCESS = 150,
    _SC_SINGLE_PROCESS = 151,
    _SC_NETWORKING = 152,
    _SC_READER_WRITER_LOCKS = 153,
    _SC_SPIN_LOCKS = 154,
    _SC_REGEXP = 155,
    _SC_REGEX_VERSION = 156,
    _SC_SHELL = 157,
    _SC_SIGNALS = 158,
    _SC_SPAWN = 159,
    _SC_SPORADIC_SERVER = 160,
    _SC_THREAD_SPORADIC_SERVER = 161,
    _SC_SYSTEM_DATABASE = 162,
    _SC_SYSTEM_DATABASE_R = 163,
    _SC_TIMEOUTS = 164,
    _SC_TYPED_MEMORY_OBJECTS = 165,
    _SC_USER_GROUPS = 166,
    _SC_USER_GROUPS_R = 167,
    _SC_2_PBS = 168,
    _SC_2_PBS_ACCOUNTING = 169,
    _SC_2_PBS_LOCATE = 170,
    _SC_2_PBS_MESSAGE = 171,
    _SC_2_PBS_TRACK = 172,
    _SC_SYMLOOP_MAX = 173,
    _SC_STREAMS = 174,
    _SC_2_PBS_CHECKPOINT = 175,
    _SC_V6_ILP32_OFF32 = 176,
    _SC_V6_ILP32_OFFBIG = 177,
    _SC_V6_LP64_OFF64 = 178,
    _SC_V6_LPBIG_OFFBIG = 179,
    _SC_HOST_NAME_MAX = 180,
    _SC_TRACE = 181,
    _SC_TRACE_EVENT_FILTER = 182,
    _SC_TRACE_INHERIT = 183,
    _SC_TRACE_LOG = 184,
    _SC_LEVEL1_ICACHE_SIZE = 185,
    _SC_LEVEL1_ICACHE_ASSOC = 186,
    _SC_LEVEL1_ICACHE_LINESIZE = 187,
    _SC_LEVEL1_DCACHE_SIZE = 188,
    _SC_LEVEL1_DCACHE_ASSOC = 189,
    _SC_LEVEL1_DCACHE_LINESIZE = 190,
    _SC_LEVEL2_CACHE_SIZE = 191,
    _SC_LEVEL2_CACHE_ASSOC = 192,
    _SC_LEVEL2_CACHE_LINESIZE = 193,
    _SC_LEVEL3_CACHE_SIZE = 194,
    _SC_LEVEL3_CACHE_ASSOC = 195,
    _SC_LEVEL3_CACHE_LINESIZE = 196,
    _SC_LEVEL4_CACHE_SIZE = 197,
    _SC_LEVEL4_CACHE_ASSOC = 198,
    _SC_LEVEL4_CACHE_LINESIZE = 199,
    _SC_IPV6 = 235,
    _SC_RAW_SOCKETS = 236,
    _SC_V7_ILP32_OFF32 = 237,
    _SC_V7_ILP32_OFFBIG = 238,
    _SC_V7_LP64_OFF64 = 239,
    _SC_V7_LPBIG_OFFBIG = 240,
    _SC_SS_REPL_MAX = 241,
    _SC_TRACE_EVENT_NAME_MAX = 242,
    _SC_TRACE_NAME_MAX = 243,
    _SC_TRACE_SYS_MAX = 244,
    _SC_TRACE_USER_EVENT_MAX = 245,
    _SC_XOPEN_STREAMS = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT = 248,
}
pub const _CS_PATH: _bindgen_ty_3 = _bindgen_ty_3::_CS_PATH;
pub const _CS_V6_WIDTH_RESTRICTED_ENVS: _bindgen_ty_3 =
    _bindgen_ty_3::_CS_V6_WIDTH_RESTRICTED_ENVS;
pub const _CS_GNU_LIBC_VERSION: _bindgen_ty_3 =
    _bindgen_ty_3::_CS_GNU_LIBC_VERSION;
pub const _CS_GNU_LIBPTHREAD_VERSION: _bindgen_ty_3 =
    _bindgen_ty_3::_CS_GNU_LIBPTHREAD_VERSION;
pub const _CS_V5_WIDTH_RESTRICTED_ENVS: _bindgen_ty_3 =
    _bindgen_ty_3::_CS_V5_WIDTH_RESTRICTED_ENVS;
pub const _CS_V7_WIDTH_RESTRICTED_ENVS: _bindgen_ty_3 =
    _bindgen_ty_3::_CS_V7_WIDTH_RESTRICTED_ENVS;
pub const _CS_LFS_CFLAGS: _bindgen_ty_3 = _bindgen_ty_3::_CS_LFS_CFLAGS;
pub const _CS_LFS_LDFLAGS: _bindgen_ty_3 = _bindgen_ty_3::_CS_LFS_LDFLAGS;
pub const _CS_LFS_LIBS: _bindgen_ty_3 = _bindgen_ty_3::_CS_LFS_LIBS;
pub const _CS_LFS_LINTFLAGS: _bindgen_ty_3 = _bindgen_ty_3::_CS_LFS_LINTFLAGS;
pub const _CS_LFS64_CFLAGS: _bindgen_ty_3 = _bindgen_ty_3::_CS_LFS64_CFLAGS;
pub const _CS_LFS64_LDFLAGS: _bindgen_ty_3 = _bindgen_ty_3::_CS_LFS64_LDFLAGS;
pub const _CS_LFS64_LIBS: _bindgen_ty_3 = _bindgen_ty_3::_CS_LFS64_LIBS;
pub const _CS_LFS64_LINTFLAGS: _bindgen_ty_3 =
    _bindgen_ty_3::_CS_LFS64_LINTFLAGS;
pub const _CS_XBS5_ILP32_OFF32_CFLAGS: _bindgen_ty_3 =
    _bindgen_ty_3::_CS_XBS5_ILP32_OFF32_CFLAGS;
pub const _CS_XBS5_ILP32_OFF32_LDFLAGS: _bindgen_ty_3 =
    _bindgen_ty_3::_CS_XBS5_ILP32_OFF32_LDFLAGS;
pub const _CS_XBS5_ILP32_OFF32_LIBS: _bindgen_ty_3 =
    _bindgen_ty_3::_CS_XBS5_ILP32_OFF32_LIBS;
pub const _CS_XBS5_ILP32_OFF32_LINTFLAGS: _bindgen_ty_3 =
    _bindgen_ty_3::_CS_XBS5_ILP32_OFF32_LINTFLAGS;
pub const _CS_XBS5_ILP32_OFFBIG_CFLAGS: _bindgen_ty_3 =
    _bindgen_ty_3::_CS_XBS5_ILP32_OFFBIG_CFLAGS;
pub const _CS_XBS5_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_3 =
    _bindgen_ty_3::_CS_XBS5_ILP32_OFFBIG_LDFLAGS;
pub const _CS_XBS5_ILP32_OFFBIG_LIBS: _bindgen_ty_3 =
    _bindgen_ty_3::_CS_XBS5_ILP32_OFFBIG_LIBS;
pub const _CS_XBS5_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_3 =
    _bindgen_ty_3::_CS_XBS5_ILP32_OFFBIG_LINTFLAGS;
pub const _CS_XBS5_LP64_OFF64_CFLAGS: _bindgen_ty_3 =
    _bindgen_ty_3::_CS_XBS5_LP64_OFF64_CFLAGS;
pub const _CS_XBS5_LP64_OFF64_LDFLAGS: _bindgen_ty_3 =
    _bindgen_ty_3::_CS_XBS5_LP64_OFF64_LDFLAGS;
pub const _CS_XBS5_LP64_OFF64_LIBS: _bindgen_ty_3 =
    _bindgen_ty_3::_CS_XBS5_LP64_OFF64_LIBS;
pub const _CS_XBS5_LP64_OFF64_LINTFLAGS: _bindgen_ty_3 =
    _bindgen_ty_3::_CS_XBS5_LP64_OFF64_LINTFLAGS;
pub const _CS_XBS5_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_3 =
    _bindgen_ty_3::_CS_XBS5_LPBIG_OFFBIG_CFLAGS;
pub const _CS_XBS5_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_3 =
    _bindgen_ty_3::_CS_XBS5_LPBIG_OFFBIG_LDFLAGS;
pub const _CS_XBS5_LPBIG_OFFBIG_LIBS: _bindgen_ty_3 =
    _bindgen_ty_3::_CS_XBS5_LPBIG_OFFBIG_LIBS;
pub const _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_3 =
    _bindgen_ty_3::_CS_XBS5_LPBIG_OFFBIG_LINTFLAGS;
pub const _CS_POSIX_V6_ILP32_OFF32_CFLAGS: _bindgen_ty_3 =
    _bindgen_ty_3::_CS_POSIX_V6_ILP32_OFF32_CFLAGS;
pub const _CS_POSIX_V6_ILP32_OFF32_LDFLAGS: _bindgen_ty_3 =
    _bindgen_ty_3::_CS_POSIX_V6_ILP32_OFF32_LDFLAGS;
pub const _CS_POSIX_V6_ILP32_OFF32_LIBS: _bindgen_ty_3 =
    _bindgen_ty_3::_CS_POSIX_V6_ILP32_OFF32_LIBS;
pub const _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS: _bindgen_ty_3 =
    _bindgen_ty_3::_CS_POSIX_V6_ILP32_OFF32_LINTFLAGS;
pub const _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS: _bindgen_ty_3 =
    _bindgen_ty_3::_CS_POSIX_V6_ILP32_OFFBIG_CFLAGS;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_3 =
    _bindgen_ty_3::_CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LIBS: _bindgen_ty_3 =
    _bindgen_ty_3::_CS_POSIX_V6_ILP32_OFFBIG_LIBS;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_3 =
    _bindgen_ty_3::_CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS;
pub const _CS_POSIX_V6_LP64_OFF64_CFLAGS: _bindgen_ty_3 =
    _bindgen_ty_3::_CS_POSIX_V6_LP64_OFF64_CFLAGS;
pub const _CS_POSIX_V6_LP64_OFF64_LDFLAGS: _bindgen_ty_3 =
    _bindgen_ty_3::_CS_POSIX_V6_LP64_OFF64_LDFLAGS;
pub const _CS_POSIX_V6_LP64_OFF64_LIBS: _bindgen_ty_3 =
    _bindgen_ty_3::_CS_POSIX_V6_LP64_OFF64_LIBS;
pub const _CS_POSIX_V6_LP64_OFF64_LINTFLAGS: _bindgen_ty_3 =
    _bindgen_ty_3::_CS_POSIX_V6_LP64_OFF64_LINTFLAGS;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_3 =
    _bindgen_ty_3::_CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_3 =
    _bindgen_ty_3::_CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LIBS: _bindgen_ty_3 =
    _bindgen_ty_3::_CS_POSIX_V6_LPBIG_OFFBIG_LIBS;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_3 =
    _bindgen_ty_3::_CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS;
pub const _CS_POSIX_V7_ILP32_OFF32_CFLAGS: _bindgen_ty_3 =
    _bindgen_ty_3::_CS_POSIX_V7_ILP32_OFF32_CFLAGS;
pub const _CS_POSIX_V7_ILP32_OFF32_LDFLAGS: _bindgen_ty_3 =
    _bindgen_ty_3::_CS_POSIX_V7_ILP32_OFF32_LDFLAGS;
pub const _CS_POSIX_V7_ILP32_OFF32_LIBS: _bindgen_ty_3 =
    _bindgen_ty_3::_CS_POSIX_V7_ILP32_OFF32_LIBS;
pub const _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS: _bindgen_ty_3 =
    _bindgen_ty_3::_CS_POSIX_V7_ILP32_OFF32_LINTFLAGS;
pub const _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS: _bindgen_ty_3 =
    _bindgen_ty_3::_CS_POSIX_V7_ILP32_OFFBIG_CFLAGS;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_3 =
    _bindgen_ty_3::_CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LIBS: _bindgen_ty_3 =
    _bindgen_ty_3::_CS_POSIX_V7_ILP32_OFFBIG_LIBS;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_3 =
    _bindgen_ty_3::_CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS;
pub const _CS_POSIX_V7_LP64_OFF64_CFLAGS: _bindgen_ty_3 =
    _bindgen_ty_3::_CS_POSIX_V7_LP64_OFF64_CFLAGS;
pub const _CS_POSIX_V7_LP64_OFF64_LDFLAGS: _bindgen_ty_3 =
    _bindgen_ty_3::_CS_POSIX_V7_LP64_OFF64_LDFLAGS;
pub const _CS_POSIX_V7_LP64_OFF64_LIBS: _bindgen_ty_3 =
    _bindgen_ty_3::_CS_POSIX_V7_LP64_OFF64_LIBS;
pub const _CS_POSIX_V7_LP64_OFF64_LINTFLAGS: _bindgen_ty_3 =
    _bindgen_ty_3::_CS_POSIX_V7_LP64_OFF64_LINTFLAGS;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_3 =
    _bindgen_ty_3::_CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_3 =
    _bindgen_ty_3::_CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LIBS: _bindgen_ty_3 =
    _bindgen_ty_3::_CS_POSIX_V7_LPBIG_OFFBIG_LIBS;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_3 =
    _bindgen_ty_3::_CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS;
pub const _CS_V6_ENV: _bindgen_ty_3 = _bindgen_ty_3::_CS_V6_ENV;
pub const _CS_V7_ENV: _bindgen_ty_3 = _bindgen_ty_3::_CS_V7_ENV;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_3 {
    _CS_PATH = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS = 1,
    _CS_GNU_LIBC_VERSION = 2,
    _CS_GNU_LIBPTHREAD_VERSION = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS = 5,
    _CS_LFS_CFLAGS = 1000,
    _CS_LFS_LDFLAGS = 1001,
    _CS_LFS_LIBS = 1002,
    _CS_LFS_LINTFLAGS = 1003,
    _CS_LFS64_CFLAGS = 1004,
    _CS_LFS64_LDFLAGS = 1005,
    _CS_LFS64_LIBS = 1006,
    _CS_LFS64_LINTFLAGS = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS = 1109,
    _CS_XBS5_LP64_OFF64_LIBS = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS = 1147,
    _CS_V6_ENV = 1148,
    _CS_V7_ENV = 1149,
}
extern "C" {
    pub fn pathconf(__path: *const ::std::os::raw::c_char,
                    __name: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn fpathconf(__fd: ::std::os::raw::c_int,
                     __name: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn sysconf(__name: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn confstr(__name: ::std::os::raw::c_int,
                   __buf: *mut ::std::os::raw::c_char, __len: usize) -> usize;
}
extern "C" {
    pub fn getpid() -> __pid_t;
}
extern "C" {
    pub fn getppid() -> __pid_t;
}
extern "C" {
    pub fn getpgrp() -> __pid_t;
}
extern "C" {
    pub fn __getpgid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn getpgid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn setpgid(__pid: __pid_t, __pgid: __pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setpgrp() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setsid() -> __pid_t;
}
extern "C" {
    pub fn getsid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn getuid() -> __uid_t;
}
extern "C" {
    pub fn geteuid() -> __uid_t;
}
extern "C" {
    pub fn getgid() -> __gid_t;
}
extern "C" {
    pub fn getegid() -> __gid_t;
}
extern "C" {
    pub fn getgroups(__size: ::std::os::raw::c_int, __list: *mut __gid_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setuid(__uid: __uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setreuid(__ruid: __uid_t, __euid: __uid_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seteuid(__uid: __uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setgid(__gid: __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setregid(__rgid: __gid_t, __egid: __gid_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setegid(__gid: __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fork() -> __pid_t;
}
extern "C" {
    pub fn vfork() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ttyname(__fd: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ttyname_r(__fd: ::std::os::raw::c_int,
                     __buf: *mut ::std::os::raw::c_char, __buflen: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isatty(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ttyslot() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn link(__from: *const ::std::os::raw::c_char,
                __to: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn linkat(__fromfd: ::std::os::raw::c_int,
                  __from: *const ::std::os::raw::c_char,
                  __tofd: ::std::os::raw::c_int,
                  __to: *const ::std::os::raw::c_char,
                  __flags: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn symlink(__from: *const ::std::os::raw::c_char,
                   __to: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn readlink(__path: *const ::std::os::raw::c_char,
                    __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> isize;
}
extern "C" {
    pub fn symlinkat(__from: *const ::std::os::raw::c_char,
                     __tofd: ::std::os::raw::c_int,
                     __to: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn readlinkat(__fd: ::std::os::raw::c_int,
                      __path: *const ::std::os::raw::c_char,
                      __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> isize;
}
extern "C" {
    pub fn unlink(__name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unlinkat(__fd: ::std::os::raw::c_int,
                    __name: *const ::std::os::raw::c_char,
                    __flag: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rmdir(__path: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tcgetpgrp(__fd: ::std::os::raw::c_int) -> __pid_t;
}
extern "C" {
    pub fn tcsetpgrp(__fd: ::std::os::raw::c_int, __pgrp_id: __pid_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getlogin() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getlogin_r(__name: *mut ::std::os::raw::c_char, __name_len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setlogin(__name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "optarg"]
    pub static mut optarg: *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "optind"]
    pub static mut optind: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "opterr"]
    pub static mut opterr: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "optopt"]
    pub static mut optopt: ::std::os::raw::c_int;
}
extern "C" {
    pub fn getopt(___argc: ::std::os::raw::c_int,
                  ___argv: *const *const ::std::os::raw::c_char,
                  __shortopts: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostname(__name: *mut ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sethostname(__name: *const ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sethostid(__id: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdomainname(__name: *mut ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setdomainname(__name: *const ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vhangup() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn revoke(__file: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn profil(__sample_buffer: *mut ::std::os::raw::c_ushort,
                  __size: usize, __offset: usize,
                  __scale: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acct(__name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getusershell() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn endusershell();
}
extern "C" {
    pub fn setusershell();
}
extern "C" {
    pub fn daemon(__nochdir: ::std::os::raw::c_int,
                  __noclose: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chroot(__path: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpass(__prompt: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fsync(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostid() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn sync();
}
extern "C" {
    pub fn getpagesize() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdtablesize() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn truncate(__file: *const ::std::os::raw::c_char, __length: __off_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftruncate(__fd: ::std::os::raw::c_int, __length: __off_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn brk(__addr: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sbrk(__delta: isize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn syscall(__sysno: ::std::os::raw::c_long, ...)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lockf(__fd: ::std::os::raw::c_int, __cmd: ::std::os::raw::c_int,
                 __len: __off_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fdatasync(__fildes: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timezone {
    pub tz_minuteswest: ::std::os::raw::c_int,
    pub tz_dsttime: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_timezone() {
    assert_eq!(::std::mem::size_of::<timezone>() , 8usize , concat ! (
               "Size of: " , stringify ! ( timezone ) ));
    assert_eq! (::std::mem::align_of::<timezone>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( timezone ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timezone ) ) . tz_minuteswest as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timezone ) , "::" ,
                stringify ! ( tz_minuteswest ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timezone ) ) . tz_dsttime as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( timezone ) , "::" ,
                stringify ! ( tz_dsttime ) ));
}
impl Clone for timezone {
    fn clone(&self) -> Self { *self }
}
pub type __timezone_ptr_t = *mut timezone;
extern "C" {
    pub fn gettimeofday(__tv: *mut timeval, __tz: __timezone_ptr_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn settimeofday(__tv: *const timeval, __tz: *const timezone)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn adjtime(__delta: *const timeval, __olddelta: *mut timeval)
     -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum __itimer_which {
    ITIMER_REAL = 0,
    ITIMER_VIRTUAL = 1,
    ITIMER_PROF = 2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
#[test]
fn bindgen_test_layout_itimerval() {
    assert_eq!(::std::mem::size_of::<itimerval>() , 32usize , concat ! (
               "Size of: " , stringify ! ( itimerval ) ));
    assert_eq! (::std::mem::align_of::<itimerval>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( itimerval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerval ) ) . it_interval as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerval ) , "::" ,
                stringify ! ( it_interval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerval ) ) . it_value as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerval ) , "::" ,
                stringify ! ( it_value ) ));
}
impl Clone for itimerval {
    fn clone(&self) -> Self { *self }
}
pub type __itimer_which_t = ::std::os::raw::c_int;
extern "C" {
    pub fn getitimer(__which: __itimer_which_t, __value: *mut itimerval)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setitimer(__which: __itimer_which_t, __new: *const itimerval,
                     __old: *mut itimerval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn utimes(__file: *const ::std::os::raw::c_char,
                  __tvp: *const timeval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lutimes(__file: *const ::std::os::raw::c_char,
                   __tvp: *const timeval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn futimes(__fd: ::std::os::raw::c_int, __tvp: *const timeval)
     -> ::std::os::raw::c_int;
}
pub type rpmtime_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rpmsw_s {
    pub u: rpmsw_s__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rpmsw_s__bindgen_ty_1 {
    pub tv: __BindgenUnionField<timeval>,
    pub ticks: __BindgenUnionField<::std::os::raw::c_ulonglong>,
    pub tocks: __BindgenUnionField<[::std::os::raw::c_ulong; 2usize]>,
    pub bindgen_union_field: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_rpmsw_s__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rpmsw_s__bindgen_ty_1>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( rpmsw_s__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<rpmsw_s__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rpmsw_s__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rpmsw_s__bindgen_ty_1 ) ) . tv as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rpmsw_s__bindgen_ty_1 )
                , "::" , stringify ! ( tv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rpmsw_s__bindgen_ty_1 ) ) . ticks as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rpmsw_s__bindgen_ty_1 )
                , "::" , stringify ! ( ticks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rpmsw_s__bindgen_ty_1 ) ) . tocks as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rpmsw_s__bindgen_ty_1 )
                , "::" , stringify ! ( tocks ) ));
}
impl Clone for rpmsw_s__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_rpmsw_s() {
    assert_eq!(::std::mem::size_of::<rpmsw_s>() , 16usize , concat ! (
               "Size of: " , stringify ! ( rpmsw_s ) ));
    assert_eq! (::std::mem::align_of::<rpmsw_s>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rpmsw_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rpmsw_s ) ) . u as * const _ as usize } ,
                0usize , concat ! (
                "Alignment of field: " , stringify ! ( rpmsw_s ) , "::" ,
                stringify ! ( u ) ));
}
impl Clone for rpmsw_s {
    fn clone(&self) -> Self { *self }
}
pub type rpmsw = *mut rpmsw_s;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rpmop_s {
    pub begin: rpmsw_s,
    pub count: ::std::os::raw::c_int,
    pub bytes: usize,
    pub usecs: rpmtime_t,
}
#[test]
fn bindgen_test_layout_rpmop_s() {
    assert_eq!(::std::mem::size_of::<rpmop_s>() , 40usize , concat ! (
               "Size of: " , stringify ! ( rpmop_s ) ));
    assert_eq! (::std::mem::align_of::<rpmop_s>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rpmop_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rpmop_s ) ) . begin as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rpmop_s ) , "::" ,
                stringify ! ( begin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rpmop_s ) ) . count as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rpmop_s ) , "::" ,
                stringify ! ( count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rpmop_s ) ) . bytes as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rpmop_s ) , "::" ,
                stringify ! ( bytes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rpmop_s ) ) . usecs as * const _ as usize
                } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rpmop_s ) , "::" ,
                stringify ! ( usecs ) ));
}
impl Clone for rpmop_s {
    fn clone(&self) -> Self { *self }
}
pub type rpmop = *mut rpmop_s;
extern "C" {
    pub fn rpmswNow(sw: rpmsw) -> rpmsw;
}
extern "C" {
    pub fn rpmswDiff(end: rpmsw, begin: rpmsw) -> rpmtime_t;
}
extern "C" {
    pub fn rpmswInit() -> rpmtime_t;
}
extern "C" {
    pub fn rpmswEnter(op: rpmop, rc: isize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmswExit(op: rpmop, rc: isize) -> rpmtime_t;
}
extern "C" {
    pub fn rpmswAdd(to: rpmop, from: rpmop) -> rpmtime_t;
}
extern "C" {
    pub fn rpmswSub(to: rpmop, from: rpmop) -> rpmtime_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FDIO_s {
    _unused: [u8; 0],
}
pub type FDIO_t = *const FDIO_s;
extern "C" {
    pub fn Fstrerror(fd: FD_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn Fread(buf: *mut ::std::os::raw::c_void, size: usize, nmemb: usize,
                 fd: FD_t) -> isize;
}
extern "C" {
    pub fn Fwrite(buf: *const ::std::os::raw::c_void, size: usize,
                  nmemb: usize, fd: FD_t) -> isize;
}
extern "C" {
    pub fn Fseek(fd: FD_t, offset: off_t, whence: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Ftell(fd: FD_t) -> off_t;
}
extern "C" {
    pub fn Fclose(fd: FD_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Fdopen(ofd: FD_t, fmode: *const ::std::os::raw::c_char) -> FD_t;
}
extern "C" {
    pub fn Fopen(path: *const ::std::os::raw::c_char,
                 fmode: *const ::std::os::raw::c_char) -> FD_t;
}
extern "C" {
    pub fn Fflush(fd: FD_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Ferror(fd: FD_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Fileno(fd: FD_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Fcntl(fd: FD_t, op: ::std::os::raw::c_int,
                 lip: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Fdescr(fd: FD_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn fdSize(fd: FD_t) -> off_t;
}
extern "C" {
    pub fn fdDup(fdno: ::std::os::raw::c_int) -> FD_t;
}
extern "C" {
    pub fn fdLink(fd: FD_t) -> FD_t;
}
extern "C" {
    pub fn fdFree(fd: FD_t) -> FD_t;
}
extern "C" {
    pub fn ufdCopy(sfd: FD_t, tfd: FD_t) -> off_t;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum fdOpX_e {
    FDSTAT_READ = 0,
    FDSTAT_WRITE = 1,
    FDSTAT_SEEK = 2,
    FDSTAT_CLOSE = 3,
    FDSTAT_DIGEST = 4,
    FDSTAT_MAX = 5,
}
pub use self::fdOpX_e as fdOpX;
extern "C" {
    pub fn fdOp(fd: FD_t, opx: fdOpX) -> rpmop;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rpmtdFlags_e {
    RPMTD_NONE = 0,
    RPMTD_ALLOCED = 1,
    RPMTD_PTR_ALLOCED = 2,
    RPMTD_IMMUTABLE = 4,
    RPMTD_ARGV = 8,
    RPMTD_INVALID = 16,
}
pub type rpmtdFlags = rpmFlags;
extern "C" {
    pub fn rpmtdNew() -> rpmtd;
}
extern "C" {
    pub fn rpmtdFree(td: rpmtd) -> rpmtd;
}
extern "C" {
    pub fn rpmtdReset(td: rpmtd);
}
extern "C" {
    pub fn rpmtdFreeData(td: rpmtd);
}
extern "C" {
    pub fn rpmtdCount(td: rpmtd) -> rpm_count_t;
}
extern "C" {
    pub fn rpmtdSize(td: rpmtd) -> rpm_count_t;
}
extern "C" {
    pub fn rpmtdTag(td: rpmtd) -> rpmTagVal;
}
extern "C" {
    pub fn rpmtdType(td: rpmtd) -> rpmTagType;
}
extern "C" {
    pub fn rpmtdClass(td: rpmtd) -> rpmTagClass;
}
extern "C" {
    pub fn rpmtdGetFlags(td: rpmtd) -> rpmtdFlags;
}
extern "C" {
    pub fn rpmtdGetIndex(td: rpmtd) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmtdSetIndex(td: rpmtd, index: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmtdInit(td: rpmtd) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmtdNext(td: rpmtd) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmtdNextUint32(td: rpmtd) -> *mut u32;
}
extern "C" {
    pub fn rpmtdNextUint64(td: rpmtd) -> *mut u64;
}
extern "C" {
    pub fn rpmtdNextString(td: rpmtd) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmtdGetChar(td: rpmtd) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmtdGetUint16(td: rpmtd) -> *mut u16;
}
extern "C" {
    pub fn rpmtdGetUint32(td: rpmtd) -> *mut u32;
}
extern "C" {
    pub fn rpmtdGetUint64(td: rpmtd) -> *mut u64;
}
extern "C" {
    pub fn rpmtdGetString(td: rpmtd) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmtdGetNumber(td: rpmtd) -> u64;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rpmtdFormats_e {
    RPMTD_FORMAT_STRING = 0,
    RPMTD_FORMAT_ARMOR = 1,
    RPMTD_FORMAT_BASE64 = 2,
    RPMTD_FORMAT_PGPSIG = 3,
    RPMTD_FORMAT_DEPFLAGS = 4,
    RPMTD_FORMAT_FFLAGS = 5,
    RPMTD_FORMAT_PERMS = 6,
    RPMTD_FORMAT_TRIGGERTYPE = 7,
    RPMTD_FORMAT_XML = 8,
    RPMTD_FORMAT_OCTAL = 9,
    RPMTD_FORMAT_HEX = 10,
    RPMTD_FORMAT_DATE = 11,
    RPMTD_FORMAT_DAY = 12,
    RPMTD_FORMAT_SHESCAPE = 13,
    RPMTD_FORMAT_ARRAYSIZE = 14,
    RPMTD_FORMAT_DEPTYPE = 15,
    RPMTD_FORMAT_FSTATE = 16,
    RPMTD_FORMAT_VFLAGS = 17,
    RPMTD_FORMAT_EXPAND = 18,
    RPMTD_FORMAT_FSTATUS = 19,
}
pub use self::rpmtdFormats_e as rpmtdFormats;
extern "C" {
    pub fn rpmtdFormat(td: rpmtd, fmt: rpmtdFormats,
                       errmsg: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmtdSetTag(td: rpmtd, tag: rpmTagVal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmtdFromUint8(td: rpmtd, tag: rpmTagVal, data: *mut u8,
                          count: rpm_count_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmtdFromUint16(td: rpmtd, tag: rpmTagVal, data: *mut u16,
                           count: rpm_count_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmtdFromUint32(td: rpmtd, tag: rpmTagVal, data: *mut u32,
                           count: rpm_count_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmtdFromUint64(td: rpmtd, tag: rpmTagVal, data: *mut u64,
                           count: rpm_count_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmtdFromString(td: rpmtd, tag: rpmTagVal,
                           data: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmtdFromStringArray(td: rpmtd, tag: rpmTagVal,
                                data: *mut *const ::std::os::raw::c_char,
                                count: rpm_count_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmtdFromArgv(td: rpmtd, tag: rpmTagVal, argv: ARGV_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmtdFromArgi(td: rpmtd, tag: rpmTagVal, argi: ARGI_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmtdDup(td: rpmtd) -> rpmtd;
}
extern "C" {
    pub fn rpmtdToPool(td: rpmtd, pool: rpmstrPool) -> *mut rpmsid;
}
extern "C" {
    pub fn rmalloc(size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn rcalloc(nmemb: usize, size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn rrealloc(ptr: *mut ::std::os::raw::c_void, size: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn rstrdup(str: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rfree(ptr: *mut ::std::os::raw::c_void)
     -> *mut ::std::os::raw::c_void;
}
pub type rpmMemFailFunc =
    ::std::option::Option<unsafe extern "C" fn(size: usize,
                                               data:
                                                   *mut ::std::os::raw::c_void)
                              -> *mut ::std::os::raw::c_void>;
extern "C" {
    pub fn rpmSetMemFail(func: rpmMemFailFunc,
                         data: *mut ::std::os::raw::c_void) -> rpmMemFailFunc;
}
extern "C" {
    #[link_name = "rpm_header_magic"]
    pub static mut rpm_header_magic: [::std::os::raw::c_uchar; 8usize];
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hMagic { HEADER_MAGIC_NO = 0, HEADER_MAGIC_YES = 1, }
extern "C" {
    pub fn headerNew() -> Header;
}
extern "C" {
    pub fn headerFree(h: Header) -> Header;
}
extern "C" {
    pub fn headerLink(h: Header) -> Header;
}
extern "C" {
    pub fn headerSort(h: Header);
}
extern "C" {
    pub fn headerUnsort(h: Header);
}
extern "C" {
    pub fn headerSizeof(h: Header, magicp: ::std::os::raw::c_int)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn headerVerifyInfo(il: ::std::os::raw::c_int,
                            dl: ::std::os::raw::c_int,
                            pev: *const ::std::os::raw::c_void,
                            iv: *mut ::std::os::raw::c_void,
                            negate: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn headerUnload(h: Header) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn headerExport(h: Header, bsize: *mut ::std::os::raw::c_uint)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn headerReload(h: Header, tag: rpmTagVal) -> Header;
}
extern "C" {
    pub fn headerCopy(h: Header) -> Header;
}
extern "C" {
    pub fn headerLoad(uh: *mut ::std::os::raw::c_void) -> Header;
}
extern "C" {
    pub fn headerCopyLoad(uh: *const ::std::os::raw::c_void) -> Header;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum headerImportFlags_e { HEADERIMPORT_COPY = 1, HEADERIMPORT_FAST = 2, }
pub type headerImportFlags = rpmFlags;
extern "C" {
    pub fn headerImport(blob: *mut ::std::os::raw::c_void,
                        bsize: ::std::os::raw::c_uint,
                        flags: headerImportFlags) -> Header;
}
extern "C" {
    pub fn headerRead(fd: FD_t, magicp: ::std::os::raw::c_int) -> Header;
}
extern "C" {
    pub fn headerWrite(fd: FD_t, h: Header, magicp: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn headerIsEntry(h: Header, tag: rpmTagVal) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum headerGetFlags_e {
    HEADERGET_DEFAULT = 0,
    HEADERGET_MINMEM = 1,
    HEADERGET_EXT = 2,
    HEADERGET_RAW = 4,
    HEADERGET_ALLOC = 8,
    HEADERGET_ARGV = 16,
}
pub type headerGetFlags = rpmFlags;
extern "C" {
    pub fn headerGet(h: Header, tag: rpmTagVal, td: rpmtd,
                     flags: headerGetFlags) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum headerPutFlags_e { HEADERPUT_DEFAULT = 0, HEADERPUT_APPEND = 1, }
pub type headerPutFlags = rpmFlags;
extern "C" {
    pub fn headerPut(h: Header, td: rpmtd, flags: headerPutFlags)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn headerPutBin(h: Header, tag: rpmTagVal, val: *const u8,
                        size: rpm_count_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn headerPutString(h: Header, tag: rpmTagVal,
                           val: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn headerPutStringArray(h: Header, tag: rpmTagVal,
                                val: *mut *const ::std::os::raw::c_char,
                                size: rpm_count_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn headerPutChar(h: Header, tag: rpmTagVal,
                         val: *const ::std::os::raw::c_char,
                         size: rpm_count_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn headerPutUint8(h: Header, tag: rpmTagVal, val: *const u8,
                          size: rpm_count_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn headerPutUint16(h: Header, tag: rpmTagVal, val: *const u16,
                           size: rpm_count_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn headerPutUint32(h: Header, tag: rpmTagVal, val: *const u32,
                           size: rpm_count_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn headerPutUint64(h: Header, tag: rpmTagVal, val: *const u64,
                           size: rpm_count_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn headerAddI18NString(h: Header, tag: rpmTagVal,
                               string: *const ::std::os::raw::c_char,
                               lang: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn headerMod(h: Header, td: rpmtd) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn headerDel(h: Header, tag: rpmTagVal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn headerFormat(h: Header, fmt: *const ::std::os::raw::c_char,
                        errmsg: *mut errmsg_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn headerCopyTags(headerFrom: Header, headerTo: Header,
                          tagstocopy: *const rpmTagVal);
}
extern "C" {
    pub fn headerFreeIterator(hi: HeaderIterator) -> HeaderIterator;
}
extern "C" {
    pub fn headerInitIterator(h: Header) -> HeaderIterator;
}
extern "C" {
    pub fn headerNext(hi: HeaderIterator, td: rpmtd) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn headerNextTag(hi: HeaderIterator) -> rpmTagVal;
}
extern "C" {
    pub fn headerNVR(h: Header, np: *mut *const ::std::os::raw::c_char,
                     vp: *mut *const ::std::os::raw::c_char,
                     rp: *mut *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn headerNEVRA(h: Header, np: *mut *const ::std::os::raw::c_char,
                       ep: *mut *mut u32,
                       vp: *mut *const ::std::os::raw::c_char,
                       rp: *mut *const ::std::os::raw::c_char,
                       ap: *mut *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn headerGetNEVR(h: Header, np: *mut *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn headerGetNEVRA(h: Header, np: *mut *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn headerGetEVR(h: Header, np: *mut *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn headerGetAsString(h: Header, tag: rpmTagVal)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn headerGetString(h: Header, tag: rpmTagVal)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn headerGetNumber(h: Header, tag: rpmTagVal) -> u64;
}
extern "C" {
    pub fn headerGetColor(h: Header) -> rpm_color_t;
}
extern "C" {
    pub fn headerIsSource(h: Header) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn headerGetInstance(h: Header) -> ::std::os::raw::c_uint;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum headerConvOps_e {
    HEADERCONV_EXPANDFILELIST = 0,
    HEADERCONV_COMPRESSFILELIST = 1,
    HEADERCONV_RETROFIT_V3 = 2,
}
pub use self::headerConvOps_e as headerConvOps;
extern "C" {
    pub fn headerConvert(h: Header, op: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rpmfilesErrorCodes {
    RPMERR_ITER_END = -1,
    RPMERR_BAD_MAGIC = -2,
    RPMERR_BAD_HEADER = -3,
    RPMERR_HDR_SIZE = -4,
    RPMERR_UNKNOWN_FILETYPE = -5,
    RPMERR_MISSING_FILE = -6,
    RPMERR_DIGEST_MISMATCH = -7,
    RPMERR_INTERNAL = -8,
    RPMERR_UNMAPPED_FILE = -9,
    RPMERR_ENOENT = -10,
    RPMERR_ENOTEMPTY = -11,
    RPMERR_FILE_SIZE = -12,
    RPMERR_ITER_SKIP = -13,
    RPMERR_OPEN_FAILED = -32768,
    RPMERR_CHMOD_FAILED = -32769,
    RPMERR_CHOWN_FAILED = -32770,
    RPMERR_WRITE_FAILED = -32771,
    RPMERR_UTIME_FAILED = -32772,
    RPMERR_UNLINK_FAILED = -32773,
    RPMERR_RENAME_FAILED = -32774,
    RPMERR_SYMLINK_FAILED = -32775,
    RPMERR_STAT_FAILED = -32776,
    RPMERR_LSTAT_FAILED = -32777,
    RPMERR_MKDIR_FAILED = -32778,
    RPMERR_RMDIR_FAILED = -32779,
    RPMERR_MKNOD_FAILED = -32780,
    RPMERR_MKFIFO_FAILED = -32781,
    RPMERR_LINK_FAILED = -32782,
    RPMERR_READLINK_FAILED = -32783,
    RPMERR_READ_FAILED = -32784,
    RPMERR_COPY_FAILED = -32785,
    RPMERR_LSETFCON_FAILED = -32786,
    RPMERR_SETCAP_FAILED = -32787,
}
extern "C" {
    pub fn rpmfileStrerror(rc: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmfiNewArchiveWriter(fd: FD_t, files: rpmfiles) -> rpmfi;
}
extern "C" {
    pub fn rpmfiNewArchiveReader(fd: FD_t, files: rpmfiles,
                                 itype: ::std::os::raw::c_int) -> rpmfi;
}
extern "C" {
    pub fn rpmfiArchiveClose(fi: rpmfi) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmfiArchiveTell(fi: rpmfi) -> rpm_loff_t;
}
extern "C" {
    pub fn rpmfiArchiveWrite(fi: rpmfi, buf: *const ::std::os::raw::c_void,
                             size: usize) -> usize;
}
extern "C" {
    pub fn rpmfiArchiveWriteFile(fi: rpmfi, fd: FD_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmfiArchiveRead(fi: rpmfi, buf: *mut ::std::os::raw::c_void,
                            size: usize) -> usize;
}
extern "C" {
    pub fn rpmfiArchiveHasContent(fi: rpmfi) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmfiArchiveReadToFile(fi: rpmfi, fd: FD_t,
                                  nodigest: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmBase64Encode(data: *const ::std::os::raw::c_void, len: usize,
                           linelen: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmBase64Decode(in_: *const ::std::os::raw::c_char,
                           out: *mut *mut ::std::os::raw::c_void,
                           outlen: *mut usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmBase64CRC(data: *const ::std::os::raw::c_uchar, len: usize)
     -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct poptOption {
    pub longName: *const ::std::os::raw::c_char,
    pub shortName: ::std::os::raw::c_char,
    pub argInfo: ::std::os::raw::c_uint,
    pub arg: *mut ::std::os::raw::c_void,
    pub val: ::std::os::raw::c_int,
    pub descrip: *const ::std::os::raw::c_char,
    pub argDescrip: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_poptOption() {
    assert_eq!(::std::mem::size_of::<poptOption>() , 48usize , concat ! (
               "Size of: " , stringify ! ( poptOption ) ));
    assert_eq! (::std::mem::align_of::<poptOption>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( poptOption ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const poptOption ) ) . longName as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( poptOption ) , "::" ,
                stringify ! ( longName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const poptOption ) ) . shortName as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( poptOption ) , "::" ,
                stringify ! ( shortName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const poptOption ) ) . argInfo as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( poptOption ) , "::" ,
                stringify ! ( argInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const poptOption ) ) . arg as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( poptOption ) , "::" ,
                stringify ! ( arg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const poptOption ) ) . val as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( poptOption ) , "::" ,
                stringify ! ( val ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const poptOption ) ) . descrip as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( poptOption ) , "::" ,
                stringify ! ( descrip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const poptOption ) ) . argDescrip as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( poptOption ) , "::" ,
                stringify ! ( argDescrip ) ));
}
impl Clone for poptOption {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct poptAlias {
    pub longName: *const ::std::os::raw::c_char,
    pub shortName: ::std::os::raw::c_char,
    pub argc: ::std::os::raw::c_int,
    pub argv: *mut *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_poptAlias() {
    assert_eq!(::std::mem::size_of::<poptAlias>() , 24usize , concat ! (
               "Size of: " , stringify ! ( poptAlias ) ));
    assert_eq! (::std::mem::align_of::<poptAlias>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( poptAlias ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const poptAlias ) ) . longName as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( poptAlias ) , "::" ,
                stringify ! ( longName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const poptAlias ) ) . shortName as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( poptAlias ) , "::" ,
                stringify ! ( shortName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const poptAlias ) ) . argc as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( poptAlias ) , "::" ,
                stringify ! ( argc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const poptAlias ) ) . argv as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( poptAlias ) , "::" ,
                stringify ! ( argv ) ));
}
impl Clone for poptAlias {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct poptItem_s {
    pub option: poptOption,
    pub argc: ::std::os::raw::c_int,
    pub argv: *mut *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_poptItem_s() {
    assert_eq!(::std::mem::size_of::<poptItem_s>() , 64usize , concat ! (
               "Size of: " , stringify ! ( poptItem_s ) ));
    assert_eq! (::std::mem::align_of::<poptItem_s>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( poptItem_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const poptItem_s ) ) . option as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( poptItem_s ) , "::" ,
                stringify ! ( option ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const poptItem_s ) ) . argc as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( poptItem_s ) , "::" ,
                stringify ! ( argc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const poptItem_s ) ) . argv as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( poptItem_s ) , "::" ,
                stringify ! ( argv ) ));
}
impl Clone for poptItem_s {
    fn clone(&self) -> Self { *self }
}
pub type poptItem = *mut poptItem_s;
extern "C" {
    #[link_name = "poptAliasOptions"]
    pub static mut poptAliasOptions: [poptOption; 0usize];
}
extern "C" {
    #[link_name = "poptHelpOptions"]
    pub static mut poptHelpOptions: [poptOption; 0usize];
}
extern "C" {
    #[link_name = "poptHelpOptionsI18N"]
    pub static mut poptHelpOptionsI18N: *mut poptOption;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct poptContext_s {
    _unused: [u8; 0],
}
pub type poptContext = *mut poptContext_s;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum poptCallbackReason {
    POPT_CALLBACK_REASON_PRE = 0,
    POPT_CALLBACK_REASON_POST = 1,
    POPT_CALLBACK_REASON_OPTION = 2,
}
pub type poptCallbackType =
    ::std::option::Option<unsafe extern "C" fn(con: poptContext,
                                               reason: poptCallbackReason,
                                               opt: *const poptOption,
                                               arg:
                                                   *const ::std::os::raw::c_char,
                                               data:
                                                   *const ::std::os::raw::c_void)>;
extern "C" {
    pub fn poptFreeContext(con: poptContext) -> poptContext;
}
extern "C" {
    pub fn poptGetContext(name: *const ::std::os::raw::c_char,
                          argc: ::std::os::raw::c_int,
                          argv: *mut *const ::std::os::raw::c_char,
                          options: *const poptOption,
                          flags: ::std::os::raw::c_uint) -> poptContext;
}
extern "C" {
    pub fn poptFini(con: poptContext) -> poptContext;
}
extern "C" {
    pub fn poptInit(argc: ::std::os::raw::c_int,
                    argv: *mut *const ::std::os::raw::c_char,
                    options: *const poptOption,
                    configPaths: *const ::std::os::raw::c_char)
     -> poptContext;
}
extern "C" {
    pub fn poptResetContext(con: poptContext);
}
extern "C" {
    pub fn poptGetNextOpt(con: poptContext) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn poptGetOptArg(con: poptContext) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn poptGetArg(con: poptContext) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn poptPeekArg(con: poptContext) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn poptGetArgs(con: poptContext)
     -> *mut *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn poptBadOption(con: poptContext, flags: ::std::os::raw::c_uint)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn poptStuffArgs(con: poptContext,
                         argv: *mut *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn poptAddAlias(con: poptContext, alias: poptAlias,
                        flags: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn poptAddItem(con: poptContext, newItem: poptItem,
                       flags: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn poptSaneFile(fn_: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn poptReadFile(fn_: *const ::std::os::raw::c_char,
                        bp: *mut *mut ::std::os::raw::c_char, nbp: *mut usize,
                        flags: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn poptReadConfigFile(con: poptContext,
                              fn_: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn poptReadConfigFiles(con: poptContext,
                               paths: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn poptReadDefaultConfig(con: poptContext,
                                 useEnv: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn poptDupArgv(argc: ::std::os::raw::c_int,
                       argv: *mut *const ::std::os::raw::c_char,
                       argcPtr: *mut ::std::os::raw::c_int,
                       argvPtr: *mut *mut *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn poptParseArgvString(s: *const ::std::os::raw::c_char,
                               argcPtr: *mut ::std::os::raw::c_int,
                               argvPtr:
                                   *mut *mut *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn poptConfigFileToString(fp: *mut FILE,
                                  argstrp: *mut *mut ::std::os::raw::c_char,
                                  flags: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn poptStrerror(error: ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn poptSetExecPath(con: poptContext,
                           path: *const ::std::os::raw::c_char,
                           allowAbsolute: ::std::os::raw::c_int);
}
extern "C" {
    pub fn poptPrintHelp(con: poptContext, fp: *mut FILE,
                         flags: ::std::os::raw::c_int);
}
extern "C" {
    pub fn poptPrintUsage(con: poptContext, fp: *mut FILE,
                          flags: ::std::os::raw::c_int);
}
extern "C" {
    pub fn poptSetOtherOptionHelp(con: poptContext,
                                  text: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn poptGetInvocationName(con: poptContext)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn poptStrippedArgv(con: poptContext, argc: ::std::os::raw::c_int,
                            argv: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn poptSaveString(argvp: *mut *mut *const ::std::os::raw::c_char,
                          argInfo: ::std::os::raw::c_uint,
                          val: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn poptSaveLongLong(arg: *mut ::std::os::raw::c_longlong,
                            argInfo: ::std::os::raw::c_uint,
                            aLongLong: ::std::os::raw::c_longlong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn poptSaveLong(arg: *mut ::std::os::raw::c_long,
                        argInfo: ::std::os::raw::c_uint,
                        aLong: ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn poptSaveShort(arg: *mut ::std::os::raw::c_short,
                         argInfo: ::std::os::raw::c_uint,
                         aLong: ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn poptSaveInt(arg: *mut ::std::os::raw::c_int,
                       argInfo: ::std::os::raw::c_uint,
                       aLong: ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct poptBits_s {
    pub bits: [::std::os::raw::c_uint; 1usize],
}
#[test]
fn bindgen_test_layout_poptBits_s() {
    assert_eq!(::std::mem::size_of::<poptBits_s>() , 4usize , concat ! (
               "Size of: " , stringify ! ( poptBits_s ) ));
    assert_eq! (::std::mem::align_of::<poptBits_s>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( poptBits_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const poptBits_s ) ) . bits as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( poptBits_s ) , "::" ,
                stringify ! ( bits ) ));
}
impl Clone for poptBits_s {
    fn clone(&self) -> Self { *self }
}
pub type poptBits = *mut poptBits_s;
extern "C" {
    #[link_name = "_poptBitsN"]
    pub static mut _poptBitsN: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "_poptBitsM"]
    pub static mut _poptBitsM: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "_poptBitsK"]
    pub static mut _poptBitsK: ::std::os::raw::c_uint;
}
extern "C" {
    pub fn poptBitsAdd(bits: poptBits, s: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn poptBitsChk(bits: poptBits, s: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn poptBitsClr(bits: poptBits) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn poptBitsDel(bits: poptBits, s: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn poptBitsIntersect(ap: *mut poptBits, b: poptBits)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn poptBitsUnion(ap: *mut poptBits, b: poptBits)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn poptBitsArgs(con: poptContext, ap: *mut poptBits)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn poptSaveBits(bitsp: *mut poptBits, argInfo: ::std::os::raw::c_uint,
                        s: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(::std::mem::size_of::<tm>() , 56usize , concat ! (
               "Size of: " , stringify ! ( tm ) ));
    assert_eq! (::std::mem::align_of::<tm>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( tm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_sec as * const _ as usize } ,
                0usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_min as * const _ as usize } ,
                4usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_min ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_hour as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_hour ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_mday as * const _ as usize }
                , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_mday ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_mon as * const _ as usize } ,
                16usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_mon ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_year as * const _ as usize }
                , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_year ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_wday as * const _ as usize }
                , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_wday ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_yday as * const _ as usize }
                , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_yday ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_isdst as * const _ as usize }
                , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_isdst ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_gmtoff as * const _ as usize
                } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_gmtoff ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_zone as * const _ as usize }
                , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_zone ) ));
}
impl Clone for tm {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(::std::mem::size_of::<itimerspec>() , 32usize , concat ! (
               "Size of: " , stringify ! ( itimerspec ) ));
    assert_eq! (::std::mem::align_of::<itimerspec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( itimerspec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerspec ) ) . it_interval as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerspec ) , "::" ,
                stringify ! ( it_interval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerspec ) ) . it_value as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerspec ) , "::" ,
                stringify ! ( it_value ) ));
}
impl Clone for itimerspec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sigevent {
    pub sigev_value: sigval_t,
    pub sigev_signo: ::std::os::raw::c_int,
    pub sigev_notify: ::std::os::raw::c_int,
    pub _sigev_un: sigevent__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sigevent__bindgen_ty_1 {
    pub _pad: __BindgenUnionField<[::std::os::raw::c_int; 12usize]>,
    pub _tid: __BindgenUnionField<__pid_t>,
    pub _sigev_thread: __BindgenUnionField<sigevent__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: [u64; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sigevent__bindgen_ty_1__bindgen_ty_1 {
    pub _function: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                  sigval_t)>,
    pub _attribute: *mut pthread_attr_t,
}
#[test]
fn bindgen_test_layout_sigevent__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<sigevent__bindgen_ty_1__bindgen_ty_1>() ,
               16usize , concat ! (
               "Size of: " , stringify ! (
               sigevent__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<sigevent__bindgen_ty_1__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                sigevent__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent__bindgen_ty_1__bindgen_ty_1 ) )
                . _function as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                sigevent__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! (
                _function ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent__bindgen_ty_1__bindgen_ty_1 ) )
                . _attribute as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                sigevent__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! (
                _attribute ) ));
}
impl Clone for sigevent__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_sigevent__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<sigevent__bindgen_ty_1>() , 48usize ,
               concat ! ( "Size of: " , stringify ! ( sigevent__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<sigevent__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( sigevent__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent__bindgen_ty_1 ) ) . _pad as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigevent__bindgen_ty_1
                ) , "::" , stringify ! ( _pad ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent__bindgen_ty_1 ) ) . _tid as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigevent__bindgen_ty_1
                ) , "::" , stringify ! ( _tid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent__bindgen_ty_1 ) ) .
                _sigev_thread as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigevent__bindgen_ty_1
                ) , "::" , stringify ! ( _sigev_thread ) ));
}
impl Clone for sigevent__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_sigevent() {
    assert_eq!(::std::mem::size_of::<sigevent>() , 64usize , concat ! (
               "Size of: " , stringify ! ( sigevent ) ));
    assert_eq! (::std::mem::align_of::<sigevent>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sigevent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent ) ) . sigev_value as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigevent ) , "::" ,
                stringify ! ( sigev_value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent ) ) . sigev_signo as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sigevent ) , "::" ,
                stringify ! ( sigev_signo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent ) ) . sigev_notify as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( sigevent ) , "::" ,
                stringify ! ( sigev_notify ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent ) ) . _sigev_un as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( sigevent ) , "::" ,
                stringify ! ( _sigev_un ) ));
}
impl Clone for sigevent {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(__s: *mut ::std::os::raw::c_char, __maxsize: usize,
                    __format: *const ::std::os::raw::c_char, __tp: *const tm)
     -> usize;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(::std::mem::size_of::<__locale_struct>() , 232usize , concat !
               ( "Size of: " , stringify ! ( __locale_struct ) ));
    assert_eq! (::std::mem::align_of::<__locale_struct>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( __locale_struct ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __locale_struct ) ) . __locales as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __locales ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __locale_struct ) ) . __ctype_b as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __ctype_b ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __locale_struct ) ) . __ctype_tolower as
                * const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __ctype_tolower ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __locale_struct ) ) . __ctype_toupper as
                * const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __ctype_toupper ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __locale_struct ) ) . __names as * const
                _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __names ) ));
}
impl Clone for __locale_struct {
    fn clone(&self) -> Self { *self }
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strftime_l(__s: *mut ::std::os::raw::c_char, __maxsize: usize,
                      __format: *const ::std::os::raw::c_char,
                      __tp: *const tm, __loc: __locale_t) -> usize;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asctime_r(__tp: *const tm, __buf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(__timer: *const time_t, __buf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "__tzname"]
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    #[link_name = "__daylight"]
    pub static mut __daylight: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__timezone"]
    pub static mut __timezone: ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "tzname"]
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    #[link_name = "daylight"]
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "timezone"]
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub fn stime(__when: *const time_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nanosleep(__requested_time: *const timespec,
                     __remaining: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_nanosleep(__clock_id: clockid_t,
                           __flags: ::std::os::raw::c_int,
                           __req: *const timespec, __rem: *mut timespec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_create(__clock_id: clockid_t, __evp: *mut sigevent,
                        __timerid: *mut timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_settime(__timerid: timer_t, __flags: ::std::os::raw::c_int,
                         __value: *const itimerspec,
                         __ovalue: *mut itimerspec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_get(__ts: *mut timespec, __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpmProblem_s {
    _unused: [u8; 0],
}
pub type rpmProblem = *mut rpmProblem_s;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rpmprobFilterFlags_e {
    RPMPROB_FILTER_NONE = 0,
    RPMPROB_FILTER_IGNOREOS = 1,
    RPMPROB_FILTER_IGNOREARCH = 2,
    RPMPROB_FILTER_REPLACEPKG = 4,
    RPMPROB_FILTER_FORCERELOCATE = 8,
    RPMPROB_FILTER_REPLACENEWFILES = 16,
    RPMPROB_FILTER_REPLACEOLDFILES = 32,
    RPMPROB_FILTER_OLDPACKAGE = 64,
    RPMPROB_FILTER_DISKSPACE = 128,
    RPMPROB_FILTER_DISKNODES = 256,
}
pub type rpmprobFilterFlags = rpmFlags;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rpmProblemType_e {
    RPMPROB_BADARCH = 0,
    RPMPROB_BADOS = 1,
    RPMPROB_PKG_INSTALLED = 2,
    RPMPROB_BADRELOCATE = 3,
    RPMPROB_REQUIRES = 4,
    RPMPROB_CONFLICT = 5,
    RPMPROB_NEW_FILE_CONFLICT = 6,
    RPMPROB_FILE_CONFLICT = 7,
    RPMPROB_OLDPACKAGE = 8,
    RPMPROB_DISKSPACE = 9,
    RPMPROB_DISKNODES = 10,
    RPMPROB_OBSOLETES = 11,
}
pub use self::rpmProblemType_e as rpmProblemType;
extern "C" {
    pub fn rpmProblemCreate(type_: rpmProblemType,
                            pkgNEVR: *const ::std::os::raw::c_char,
                            key: fnpyKey,
                            altNEVR: *const ::std::os::raw::c_char,
                            str: *const ::std::os::raw::c_char, number: u64)
     -> rpmProblem;
}
extern "C" {
    pub fn rpmProblemFree(prob: rpmProblem) -> rpmProblem;
}
extern "C" {
    pub fn rpmProblemLink(prob: rpmProblem) -> rpmProblem;
}
extern "C" {
    pub fn rpmProblemCompare(ap: rpmProblem, bp: rpmProblem)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmProblemGetPkgNEVR(prob: rpmProblem)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmProblemGetAltNEVR(prob: rpmProblem)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmProblemGetType(prob: rpmProblem) -> rpmProblemType;
}
extern "C" {
    pub fn rpmProblemGetKey(prob: rpmProblem) -> fnpyKey;
}
extern "C" {
    pub fn rpmProblemGetStr(prob: rpmProblem)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmProblemGetDiskNeed(prob: rpmProblem) -> rpm_loff_t;
}
extern "C" {
    pub fn rpmProblemString(prob: rpmProblem) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpmpsi_s {
    _unused: [u8; 0],
}
pub type rpmpsi = *mut rpmpsi_s;
extern "C" {
    pub fn rpmpsLink(ps: rpmps) -> rpmps;
}
extern "C" {
    pub fn rpmpsNumProblems(ps: rpmps) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmpsInitIterator(ps: rpmps) -> rpmpsi;
}
extern "C" {
    pub fn rpmpsFreeIterator(psi: rpmpsi) -> rpmpsi;
}
extern "C" {
    pub fn rpmpsiNext(psi: rpmpsi) -> rpmProblem;
}
extern "C" {
    pub fn rpmpsNextIterator(psi: rpmpsi) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmpsGetProblem(psi: rpmpsi) -> rpmProblem;
}
extern "C" {
    pub fn rpmpsCreate() -> rpmps;
}
extern "C" {
    pub fn rpmpsFree(ps: rpmps) -> rpmps;
}
extern "C" {
    pub fn rpmpsPrint(fp: *mut FILE, ps: rpmps);
}
extern "C" {
    pub fn rpmpsAppendProblem(ps: rpmps, prob: rpmProblem);
}
extern "C" {
    pub fn rpmpsMerge(dest: rpmps, src: rpmps) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_rpmds_nopromote"]
    pub static mut _rpmds_nopromote: ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rpmsenseFlags_e {
    RPMSENSE_ANY = 0,
    RPMSENSE_LESS = 2,
    RPMSENSE_GREATER = 4,
    RPMSENSE_EQUAL = 8,
    RPMSENSE_POSTTRANS = 32,
    RPMSENSE_PREREQ = 64,
    RPMSENSE_PRETRANS = 128,
    RPMSENSE_INTERP = 256,
    RPMSENSE_SCRIPT_PRE = 512,
    RPMSENSE_SCRIPT_POST = 1024,
    RPMSENSE_SCRIPT_PREUN = 2048,
    RPMSENSE_SCRIPT_POSTUN = 4096,
    RPMSENSE_SCRIPT_VERIFY = 8192,
    RPMSENSE_FIND_REQUIRES = 16384,
    RPMSENSE_FIND_PROVIDES = 32768,
    RPMSENSE_TRIGGERIN = 65536,
    RPMSENSE_TRIGGERUN = 131072,
    RPMSENSE_TRIGGERPOSTUN = 262144,
    RPMSENSE_MISSINGOK = 524288,
    RPMSENSE_RPMLIB = 16777216,
    RPMSENSE_TRIGGERPREIN = 33554432,
    RPMSENSE_KEYRING = 67108864,
    RPMSENSE_CONFIG = 268435456,
}
pub type rpmsenseFlags = rpmFlags;
extern "C" {
    pub fn rpmSanitizeDSFlags(tagN: rpmTagVal, Flags: rpmsenseFlags)
     -> rpmsenseFlags;
}
extern "C" {
    pub fn rpmParseDSFlags(str: *const ::std::os::raw::c_char, len: usize)
     -> rpmsenseFlags;
}
extern "C" {
    pub fn rpmdsLink(ds: rpmds) -> rpmds;
}
extern "C" {
    pub fn rpmdsFree(ds: rpmds) -> rpmds;
}
extern "C" {
    pub fn rpmdsNew(h: Header, tagN: rpmTagVal, flags: ::std::os::raw::c_int)
     -> rpmds;
}
extern "C" {
    pub fn rpmdsNewDNEVR(dspfx: *const ::std::os::raw::c_char, ds: rpmds)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmdsThis(h: Header, tagN: rpmTagVal, Flags: rpmsenseFlags)
     -> rpmds;
}
extern "C" {
    pub fn rpmdsSingle(tagN: rpmTagVal, N: *const ::std::os::raw::c_char,
                       EVR: *const ::std::os::raw::c_char,
                       Flags: rpmsenseFlags) -> rpmds;
}
extern "C" {
    pub fn rpmdsCurrent(ds: rpmds) -> rpmds;
}
extern "C" {
    pub fn rpmdsPutToHeader(ds: rpmds, h: Header) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmdsCount(ds: rpmds) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmdsIx(ds: rpmds) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmdsSetIx(ds: rpmds, ix: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmdsDNEVR(ds: rpmds) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmdsD(ds: rpmds) -> ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmdsDToTagN(deptype: ::std::os::raw::c_char) -> rpmTagVal;
}
extern "C" {
    pub fn rpmdsN(ds: rpmds) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmdsEVR(ds: rpmds) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmdsTi(ds: rpmds) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmdsFlags(ds: rpmds) -> rpmsenseFlags;
}
extern "C" {
    pub fn rpmdsTagN(ds: rpmds) -> rpmTagVal;
}
extern "C" {
    pub fn rpmdsTagEVR(ds: rpmds) -> rpmTagVal;
}
extern "C" {
    pub fn rpmdsTagF(ds: rpmds) -> rpmTagVal;
}
extern "C" {
    pub fn rpmdsTagTi(ds: rpmds) -> rpmTagVal;
}
extern "C" {
    pub fn rpmdsInstance(ds: rpmds) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rpmdsNoPromote(ds: rpmds) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmdsSetNoPromote(ds: rpmds, nopromote: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmdsColor(ds: rpmds) -> rpm_color_t;
}
extern "C" {
    pub fn rpmdsSetColor(ds: rpmds, color: rpm_color_t) -> rpm_color_t;
}
extern "C" {
    pub fn rpmdsNotify(ds: rpmds, where_: *const ::std::os::raw::c_char,
                       rc: ::std::os::raw::c_int);
}
extern "C" {
    pub fn rpmdsNext(ds: rpmds) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmdsInit(ds: rpmds) -> rpmds;
}
extern "C" {
    pub fn rpmdsFind(ds: rpmds, ods: rpmds) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmdsMerge(dsp: *mut rpmds, ods: rpmds) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmdsSearch(ds: rpmds, ods: rpmds) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmdsCompare(A: rpmds, B: rpmds) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmdsAnyMatchesDep(h: Header, req: rpmds,
                              nopromote: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmdsMatchesDep(h: Header, ix: ::std::os::raw::c_int, req: rpmds,
                           nopromote: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmdsNVRMatchesDep(h: Header, req: rpmds,
                              nopromote: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmdsRpmlib(dsp: *mut rpmds, tblp: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmdsNewPool(pool: rpmstrPool, h: Header, tagN: rpmTagVal,
                        flags: ::std::os::raw::c_int) -> rpmds;
}
extern "C" {
    pub fn rpmdsThisPool(pool: rpmstrPool, h: Header, tagN: rpmTagVal,
                         Flags: rpmsenseFlags) -> rpmds;
}
extern "C" {
    pub fn rpmdsSinglePool(pool: rpmstrPool, tagN: rpmTagVal,
                           N: *const ::std::os::raw::c_char,
                           EVR: *const ::std::os::raw::c_char,
                           Flags: rpmsenseFlags) -> rpmds;
}
extern "C" {
    pub fn rpmdsSinglePoolTix(pool: rpmstrPool, tagN: rpmTagVal,
                              N: *const ::std::os::raw::c_char,
                              EVR: *const ::std::os::raw::c_char,
                              Flags: rpmsenseFlags,
                              triggerIndex: ::std::os::raw::c_int) -> rpmds;
}
extern "C" {
    pub fn rpmdsRpmlibPool(pool: rpmstrPool, dsp: *mut rpmds,
                           tblp: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rpmrichOp_e {
    RPMRICHOP_SINGLE = 1,
    RPMRICHOP_AND = 2,
    RPMRICHOP_OR = 3,
    RPMRICHOP_IF = 4,
    RPMRICHOP_ELSE = 5,
    RPMRICHOP_WITH = 6,
    RPMRICHOP_WITHOUT = 7,
    RPMRICHOP_UNLESS = 8,
}
pub use self::rpmrichOp_e as rpmrichOp;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rpmrichParseType_e {
    RPMRICH_PARSE_SIMPLE = 1,
    RPMRICH_PARSE_ENTER = 2,
    RPMRICH_PARSE_LEAVE = 3,
    RPMRICH_PARSE_OP = 4,
}
pub use self::rpmrichParseType_e as rpmrichParseType;
pub type rpmrichParseFunction =
    ::std::option::Option<unsafe extern "C" fn(cbdata:
                                                   *mut ::std::os::raw::c_void,
                                               type_: rpmrichParseType,
                                               n:
                                                   *const ::std::os::raw::c_char,
                                               nl: ::std::os::raw::c_int,
                                               e:
                                                   *const ::std::os::raw::c_char,
                                               el: ::std::os::raw::c_int,
                                               sense: rpmsenseFlags,
                                               op: rpmrichOp,
                                               emsg:
                                                   *mut *mut ::std::os::raw::c_char)
                              -> rpmRC>;
extern "C" {
    pub fn rpmrichParse(dstrp: *mut *const ::std::os::raw::c_char,
                        emsg: *mut *mut ::std::os::raw::c_char,
                        cb: rpmrichParseFunction,
                        cbdata: *mut ::std::os::raw::c_void) -> rpmRC;
}
extern "C" {
    pub fn rpmrichParseForTag(dstrp: *mut *const ::std::os::raw::c_char,
                              emsg: *mut *mut ::std::os::raw::c_char,
                              cb: rpmrichParseFunction,
                              cbdata: *mut ::std::os::raw::c_void,
                              tagN: rpmTagVal) -> rpmRC;
}
extern "C" {
    pub fn rpmdsIsRich(dep: rpmds) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmrichOpStr(op: rpmrichOp) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmdsParseRichDep(dep: rpmds, leftds: *mut rpmds,
                             rightds: *mut rpmds, op: *mut rpmrichOp,
                             emsg: *mut *mut ::std::os::raw::c_char) -> rpmRC;
}
extern "C" {
    pub fn memcpy(__dest: *mut ::std::os::raw::c_void,
                  __src: *const ::std::os::raw::c_void, __n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(__dest: *mut ::std::os::raw::c_void,
                   __src: *const ::std::os::raw::c_void, __n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memccpy(__dest: *mut ::std::os::raw::c_void,
                   __src: *const ::std::os::raw::c_void,
                   __c: ::std::os::raw::c_int, __n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(__s: *mut ::std::os::raw::c_void,
                  __c: ::std::os::raw::c_int, __n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(__s1: *const ::std::os::raw::c_void,
                  __s2: *const ::std::os::raw::c_void, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(__s: *const ::std::os::raw::c_void,
                  __c: ::std::os::raw::c_int, __n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcpy(__dest: *mut ::std::os::raw::c_char,
                  __src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(__dest: *mut ::std::os::raw::c_char,
                   __src: *const ::std::os::raw::c_char, __n: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(__dest: *mut ::std::os::raw::c_char,
                  __src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(__dest: *mut ::std::os::raw::c_char,
                   __src: *const ::std::os::raw::c_char, __n: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(__s1: *const ::std::os::raw::c_char,
                  __s2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncmp(__s1: *const ::std::os::raw::c_char,
                   __s2: *const ::std::os::raw::c_char, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(__s1: *const ::std::os::raw::c_char,
                   __s2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(__dest: *mut ::std::os::raw::c_char,
                   __src: *const ::std::os::raw::c_char, __n: usize)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strcoll_l(__s1: *const ::std::os::raw::c_char,
                     __s2: *const ::std::os::raw::c_char, __l: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(__dest: *mut ::std::os::raw::c_char,
                     __src: *const ::std::os::raw::c_char, __n: usize,
                     __l: __locale_t) -> usize;
}
extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(__string: *const ::std::os::raw::c_char, __n: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(__s: *const ::std::os::raw::c_char,
                  __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(__s: *const ::std::os::raw::c_char,
                   __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(__s: *const ::std::os::raw::c_char,
                   __reject: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strspn(__s: *const ::std::os::raw::c_char,
                  __accept: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strpbrk(__s: *const ::std::os::raw::c_char,
                   __accept: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(__haystack: *const ::std::os::raw::c_char,
                  __needle: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(__s: *mut ::std::os::raw::c_char,
                  __delim: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strtok_r(__s: *mut ::std::os::raw::c_char,
                      __delim: *const ::std::os::raw::c_char,
                      __save_ptr: *mut *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(__s: *mut ::std::os::raw::c_char,
                    __delim: *const ::std::os::raw::c_char,
                    __save_ptr: *mut *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: usize)
     -> usize;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "__xpg_strerror_r"]
    pub fn strerror_r(__errnum: ::std::os::raw::c_int,
                      __buf: *mut ::std::os::raw::c_char, __buflen: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strerror_l(__errnum: ::std::os::raw::c_int, __l: __locale_t)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn bcopy(__src: *const ::std::os::raw::c_void,
                 __dest: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn bcmp(__s1: *const ::std::os::raw::c_void,
                __s2: *const ::std::os::raw::c_void, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn index(__s: *const ::std::os::raw::c_char,
                 __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(__s: *const ::std::os::raw::c_char,
                  __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(__s1: *const ::std::os::raw::c_char,
                      __s2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(__s1: *const ::std::os::raw::c_char,
                       __s2: *const ::std::os::raw::c_char, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strsep(__stringp: *mut *mut ::std::os::raw::c_char,
                  __delim: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpcpy(__dest: *mut ::std::os::raw::c_char,
                    __src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpcpy(__dest: *mut ::std::os::raw::c_char,
                  __src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpncpy(__dest: *mut ::std::os::raw::c_char,
                     __src: *const ::std::os::raw::c_char, __n: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(__dest: *mut ::std::os::raw::c_char,
                   __src: *const ::std::os::raw::c_char, __n: usize)
     -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: f64,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(::std::mem::size_of::<max_align_t>() , 32usize , concat ! (
               "Size of: " , stringify ! ( max_align_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const max_align_t ) ) .
                __clang_max_align_nonce1 as * const _ as usize } , 0usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( max_align_t ) , "::" ,
                stringify ! ( __clang_max_align_nonce1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const max_align_t ) ) .
                __clang_max_align_nonce2 as * const _ as usize } , 16usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( max_align_t ) , "::" ,
                stringify ! ( __clang_max_align_nonce2 ) ));
}
impl Clone for max_align_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn rstrcasecmp(s1: *const ::std::os::raw::c_char,
                       s2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rstrncasecmp(s1: *const ::std::os::raw::c_char,
                        s2: *const ::std::os::raw::c_char, n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rasprintf(strp: *mut *mut ::std::os::raw::c_char,
                     fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rstrcat(dest: *mut *mut ::std::os::raw::c_char,
                   src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rstrscat(dest: *mut *mut ::std::os::raw::c_char,
                    arg: *const ::std::os::raw::c_char, ...)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rstrlcpy(dest: *mut ::std::os::raw::c_char,
                    src: *const ::std::os::raw::c_char, n: usize) -> usize;
}
extern "C" {
    pub fn rstrhash(string: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_uint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DIGEST_CTX_s {
    _unused: [u8; 0],
}
pub type DIGEST_CTX = *mut DIGEST_CTX_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpmDigestBundle_s {
    _unused: [u8; 0],
}
pub type rpmDigestBundle = *mut rpmDigestBundle_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pgpDig_s {
    _unused: [u8; 0],
}
pub type pgpDig = *mut pgpDig_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pgpDigParams_s {
    _unused: [u8; 0],
}
pub type pgpDigParams = *mut pgpDigParams_s;
pub type pgpKeyID_t = [u8; 8usize];
pub type pgpTime_t = [u8; 4usize];
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pgpTag_e {
    PGPTAG_RESERVED = 0,
    PGPTAG_PUBLIC_SESSION_KEY = 1,
    PGPTAG_SIGNATURE = 2,
    PGPTAG_SYMMETRIC_SESSION_KEY = 3,
    PGPTAG_ONEPASS_SIGNATURE = 4,
    PGPTAG_SECRET_KEY = 5,
    PGPTAG_PUBLIC_KEY = 6,
    PGPTAG_SECRET_SUBKEY = 7,
    PGPTAG_COMPRESSED_DATA = 8,
    PGPTAG_SYMMETRIC_DATA = 9,
    PGPTAG_MARKER = 10,
    PGPTAG_LITERAL_DATA = 11,
    PGPTAG_TRUST = 12,
    PGPTAG_USER_ID = 13,
    PGPTAG_PUBLIC_SUBKEY = 14,
    PGPTAG_COMMENT_OLD = 16,
    PGPTAG_PHOTOID = 17,
    PGPTAG_ENCRYPTED_MDC = 18,
    PGPTAG_MDC = 19,
    PGPTAG_PRIVATE_60 = 60,
    PGPTAG_COMMENT = 61,
    PGPTAG_PRIVATE_62 = 62,
    PGPTAG_CONTROL = 63,
}
pub use self::pgpTag_e as pgpTag;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pgpPktPubkey_s {
    pub version: u8,
    pub keyid: pgpKeyID_t,
    pub algo: u8,
}
#[test]
fn bindgen_test_layout_pgpPktPubkey_s() {
    assert_eq!(::std::mem::size_of::<pgpPktPubkey_s>() , 10usize , concat ! (
               "Size of: " , stringify ! ( pgpPktPubkey_s ) ));
    assert_eq! (::std::mem::align_of::<pgpPktPubkey_s>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( pgpPktPubkey_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgpPktPubkey_s ) ) . version as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pgpPktPubkey_s ) , "::"
                , stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgpPktPubkey_s ) ) . keyid as * const _
                as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( pgpPktPubkey_s ) , "::"
                , stringify ! ( keyid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgpPktPubkey_s ) ) . algo as * const _ as
                usize } , 9usize , concat ! (
                "Alignment of field: " , stringify ! ( pgpPktPubkey_s ) , "::"
                , stringify ! ( algo ) ));
}
impl Clone for pgpPktPubkey_s {
    fn clone(&self) -> Self { *self }
}
pub type pgpPktPubkey = pgpPktPubkey_s;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pgpSigType_e {
    PGPSIGTYPE_BINARY = 0,
    PGPSIGTYPE_TEXT = 1,
    PGPSIGTYPE_STANDALONE = 2,
    PGPSIGTYPE_GENERIC_CERT = 16,
    PGPSIGTYPE_PERSONA_CERT = 17,
    PGPSIGTYPE_CASUAL_CERT = 18,
    PGPSIGTYPE_POSITIVE_CERT = 19,
    PGPSIGTYPE_SUBKEY_BINDING = 24,
    PGPSIGTYPE_SIGNED_KEY = 31,
    PGPSIGTYPE_KEY_REVOKE = 32,
    PGPSIGTYPE_SUBKEY_REVOKE = 40,
    PGPSIGTYPE_CERT_REVOKE = 48,
    PGPSIGTYPE_TIMESTAMP = 64,
}
pub use self::pgpSigType_e as pgpSigType;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pgpPubkeyAlgo_e {
    PGPPUBKEYALGO_RSA = 1,
    PGPPUBKEYALGO_RSA_ENCRYPT = 2,
    PGPPUBKEYALGO_RSA_SIGN = 3,
    PGPPUBKEYALGO_ELGAMAL_ENCRYPT = 16,
    PGPPUBKEYALGO_DSA = 17,
    PGPPUBKEYALGO_EC = 18,
    PGPPUBKEYALGO_ECDSA = 19,
    PGPPUBKEYALGO_ELGAMAL = 20,
    PGPPUBKEYALGO_DH = 21,
}
pub use self::pgpPubkeyAlgo_e as pgpPubkeyAlgo;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pgpSymkeyAlgo_e {
    PGPSYMKEYALGO_PLAINTEXT = 0,
    PGPSYMKEYALGO_IDEA = 1,
    PGPSYMKEYALGO_TRIPLE_DES = 2,
    PGPSYMKEYALGO_CAST5 = 3,
    PGPSYMKEYALGO_BLOWFISH = 4,
    PGPSYMKEYALGO_SAFER = 5,
    PGPSYMKEYALGO_DES_SK = 6,
    PGPSYMKEYALGO_AES_128 = 7,
    PGPSYMKEYALGO_AES_192 = 8,
    PGPSYMKEYALGO_AES_256 = 9,
    PGPSYMKEYALGO_TWOFISH = 10,
    PGPSYMKEYALGO_NOENCRYPT = 110,
}
pub use self::pgpSymkeyAlgo_e as pgpSymkeyAlgo;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pgpCompressAlgo_e {
    PGPCOMPRESSALGO_NONE = 0,
    PGPCOMPRESSALGO_ZIP = 1,
    PGPCOMPRESSALGO_ZLIB = 2,
    PGPCOMPRESSALGO_BZIP2 = 3,
}
pub use self::pgpCompressAlgo_e as pgpCompressAlgo;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pgpHashAlgo_e {
    PGPHASHALGO_MD5 = 1,
    PGPHASHALGO_SHA1 = 2,
    PGPHASHALGO_RIPEMD160 = 3,
    PGPHASHALGO_MD2 = 5,
    PGPHASHALGO_TIGER192 = 6,
    PGPHASHALGO_HAVAL_5_160 = 7,
    PGPHASHALGO_SHA256 = 8,
    PGPHASHALGO_SHA384 = 9,
    PGPHASHALGO_SHA512 = 10,
    PGPHASHALGO_SHA224 = 11,
}
pub use self::pgpHashAlgo_e as pgpHashAlgo;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pgpPktSigV3_s {
    pub version: u8,
    pub hashlen: u8,
    pub sigtype: u8,
    pub time: pgpTime_t,
    pub signid: pgpKeyID_t,
    pub pubkey_algo: u8,
    pub hash_algo: u8,
    pub signhash16: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_pgpPktSigV3_s() {
    assert_eq!(::std::mem::size_of::<pgpPktSigV3_s>() , 19usize , concat ! (
               "Size of: " , stringify ! ( pgpPktSigV3_s ) ));
    assert_eq! (::std::mem::align_of::<pgpPktSigV3_s>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( pgpPktSigV3_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgpPktSigV3_s ) ) . version as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pgpPktSigV3_s ) , "::"
                , stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgpPktSigV3_s ) ) . hashlen as * const _
                as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( pgpPktSigV3_s ) , "::"
                , stringify ! ( hashlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgpPktSigV3_s ) ) . sigtype as * const _
                as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( pgpPktSigV3_s ) , "::"
                , stringify ! ( sigtype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgpPktSigV3_s ) ) . time as * const _ as
                usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( pgpPktSigV3_s ) , "::"
                , stringify ! ( time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgpPktSigV3_s ) ) . signid as * const _
                as usize } , 7usize , concat ! (
                "Alignment of field: " , stringify ! ( pgpPktSigV3_s ) , "::"
                , stringify ! ( signid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgpPktSigV3_s ) ) . pubkey_algo as *
                const _ as usize } , 15usize , concat ! (
                "Alignment of field: " , stringify ! ( pgpPktSigV3_s ) , "::"
                , stringify ! ( pubkey_algo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgpPktSigV3_s ) ) . hash_algo as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( pgpPktSigV3_s ) , "::"
                , stringify ! ( hash_algo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgpPktSigV3_s ) ) . signhash16 as * const
                _ as usize } , 17usize , concat ! (
                "Alignment of field: " , stringify ! ( pgpPktSigV3_s ) , "::"
                , stringify ! ( signhash16 ) ));
}
impl Clone for pgpPktSigV3_s {
    fn clone(&self) -> Self { *self }
}
pub type pgpPktSigV3 = *mut pgpPktSigV3_s;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pgpPktSigV4_s {
    pub version: u8,
    pub sigtype: u8,
    pub pubkey_algo: u8,
    pub hash_algo: u8,
    pub hashlen: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_pgpPktSigV4_s() {
    assert_eq!(::std::mem::size_of::<pgpPktSigV4_s>() , 6usize , concat ! (
               "Size of: " , stringify ! ( pgpPktSigV4_s ) ));
    assert_eq! (::std::mem::align_of::<pgpPktSigV4_s>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( pgpPktSigV4_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgpPktSigV4_s ) ) . version as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pgpPktSigV4_s ) , "::"
                , stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgpPktSigV4_s ) ) . sigtype as * const _
                as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( pgpPktSigV4_s ) , "::"
                , stringify ! ( sigtype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgpPktSigV4_s ) ) . pubkey_algo as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( pgpPktSigV4_s ) , "::"
                , stringify ! ( pubkey_algo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgpPktSigV4_s ) ) . hash_algo as * const
                _ as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( pgpPktSigV4_s ) , "::"
                , stringify ! ( hash_algo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgpPktSigV4_s ) ) . hashlen as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( pgpPktSigV4_s ) , "::"
                , stringify ! ( hashlen ) ));
}
impl Clone for pgpPktSigV4_s {
    fn clone(&self) -> Self { *self }
}
pub type pgpPktSigV4 = *mut pgpPktSigV4_s;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pgpSubType_e {
    PGPSUBTYPE_NONE = 0,
    PGPSUBTYPE_SIG_CREATE_TIME = 2,
    PGPSUBTYPE_SIG_EXPIRE_TIME = 3,
    PGPSUBTYPE_EXPORTABLE_CERT = 4,
    PGPSUBTYPE_TRUST_SIG = 5,
    PGPSUBTYPE_REGEX = 6,
    PGPSUBTYPE_REVOCABLE = 7,
    PGPSUBTYPE_KEY_EXPIRE_TIME = 9,
    PGPSUBTYPE_ARR = 10,
    PGPSUBTYPE_PREFER_SYMKEY = 11,
    PGPSUBTYPE_REVOKE_KEY = 12,
    PGPSUBTYPE_ISSUER_KEYID = 16,
    PGPSUBTYPE_NOTATION = 20,
    PGPSUBTYPE_PREFER_HASH = 21,
    PGPSUBTYPE_PREFER_COMPRESS = 22,
    PGPSUBTYPE_KEYSERVER_PREFERS = 23,
    PGPSUBTYPE_PREFER_KEYSERVER = 24,
    PGPSUBTYPE_PRIMARY_USERID = 25,
    PGPSUBTYPE_POLICY_URL = 26,
    PGPSUBTYPE_KEY_FLAGS = 27,
    PGPSUBTYPE_SIGNER_USERID = 28,
    PGPSUBTYPE_REVOKE_REASON = 29,
    PGPSUBTYPE_FEATURES = 30,
    PGPSUBTYPE_EMBEDDED_SIG = 32,
    PGPSUBTYPE_INTERNAL_100 = 100,
    PGPSUBTYPE_INTERNAL_101 = 101,
    PGPSUBTYPE_INTERNAL_102 = 102,
    PGPSUBTYPE_INTERNAL_103 = 103,
    PGPSUBTYPE_INTERNAL_104 = 104,
    PGPSUBTYPE_INTERNAL_105 = 105,
    PGPSUBTYPE_INTERNAL_106 = 106,
    PGPSUBTYPE_INTERNAL_107 = 107,
    PGPSUBTYPE_INTERNAL_108 = 108,
    PGPSUBTYPE_INTERNAL_109 = 109,
    PGPSUBTYPE_INTERNAL_110 = 110,
    PGPSUBTYPE_CRITICAL = 128,
}
pub use self::pgpSubType_e as pgpSubType;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pgpPktSig_u {
    pub v3: __BindgenUnionField<pgpPktSigV3_s>,
    pub v4: __BindgenUnionField<pgpPktSigV4_s>,
    pub bindgen_union_field: [u8; 19usize],
}
#[test]
fn bindgen_test_layout_pgpPktSig_u() {
    assert_eq!(::std::mem::size_of::<pgpPktSig_u>() , 19usize , concat ! (
               "Size of: " , stringify ! ( pgpPktSig_u ) ));
    assert_eq! (::std::mem::align_of::<pgpPktSig_u>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( pgpPktSig_u ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgpPktSig_u ) ) . v3 as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pgpPktSig_u ) , "::" ,
                stringify ! ( v3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgpPktSig_u ) ) . v4 as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pgpPktSig_u ) , "::" ,
                stringify ! ( v4 ) ));
}
impl Clone for pgpPktSig_u {
    fn clone(&self) -> Self { *self }
}
pub type pgpPktSig = *mut pgpPktSig_u;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pgpPktSymkey_s {
    pub version: u8,
    pub symkey_algo: u8,
    pub s2k: [u8; 1usize],
}
#[test]
fn bindgen_test_layout_pgpPktSymkey_s() {
    assert_eq!(::std::mem::size_of::<pgpPktSymkey_s>() , 3usize , concat ! (
               "Size of: " , stringify ! ( pgpPktSymkey_s ) ));
    assert_eq! (::std::mem::align_of::<pgpPktSymkey_s>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( pgpPktSymkey_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgpPktSymkey_s ) ) . version as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pgpPktSymkey_s ) , "::"
                , stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgpPktSymkey_s ) ) . symkey_algo as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( pgpPktSymkey_s ) , "::"
                , stringify ! ( symkey_algo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgpPktSymkey_s ) ) . s2k as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( pgpPktSymkey_s ) , "::"
                , stringify ! ( s2k ) ));
}
impl Clone for pgpPktSymkey_s {
    fn clone(&self) -> Self { *self }
}
pub type pgpPktSymkey = pgpPktSymkey_s;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pgpPktOnepass_s {
    pub version: u8,
    pub sigtype: u8,
    pub hash_algo: u8,
    pub pubkey_algo: u8,
    pub signid: pgpKeyID_t,
    pub nested: u8,
}
#[test]
fn bindgen_test_layout_pgpPktOnepass_s() {
    assert_eq!(::std::mem::size_of::<pgpPktOnepass_s>() , 13usize , concat ! (
               "Size of: " , stringify ! ( pgpPktOnepass_s ) ));
    assert_eq! (::std::mem::align_of::<pgpPktOnepass_s>() , 1usize , concat !
                ( "Alignment of " , stringify ! ( pgpPktOnepass_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgpPktOnepass_s ) ) . version as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pgpPktOnepass_s ) ,
                "::" , stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgpPktOnepass_s ) ) . sigtype as * const
                _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( pgpPktOnepass_s ) ,
                "::" , stringify ! ( sigtype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgpPktOnepass_s ) ) . hash_algo as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( pgpPktOnepass_s ) ,
                "::" , stringify ! ( hash_algo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgpPktOnepass_s ) ) . pubkey_algo as *
                const _ as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( pgpPktOnepass_s ) ,
                "::" , stringify ! ( pubkey_algo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgpPktOnepass_s ) ) . signid as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( pgpPktOnepass_s ) ,
                "::" , stringify ! ( signid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgpPktOnepass_s ) ) . nested as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( pgpPktOnepass_s ) ,
                "::" , stringify ! ( nested ) ));
}
impl Clone for pgpPktOnepass_s {
    fn clone(&self) -> Self { *self }
}
pub type pgpPktOnepass = *mut pgpPktOnepass_s;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pgpPktKeyV3_s {
    pub version: u8,
    pub time: pgpTime_t,
    pub valid: [u8; 2usize],
    pub pubkey_algo: u8,
}
#[test]
fn bindgen_test_layout_pgpPktKeyV3_s() {
    assert_eq!(::std::mem::size_of::<pgpPktKeyV3_s>() , 8usize , concat ! (
               "Size of: " , stringify ! ( pgpPktKeyV3_s ) ));
    assert_eq! (::std::mem::align_of::<pgpPktKeyV3_s>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( pgpPktKeyV3_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgpPktKeyV3_s ) ) . version as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pgpPktKeyV3_s ) , "::"
                , stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgpPktKeyV3_s ) ) . time as * const _ as
                usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( pgpPktKeyV3_s ) , "::"
                , stringify ! ( time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgpPktKeyV3_s ) ) . valid as * const _ as
                usize } , 5usize , concat ! (
                "Alignment of field: " , stringify ! ( pgpPktKeyV3_s ) , "::"
                , stringify ! ( valid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgpPktKeyV3_s ) ) . pubkey_algo as *
                const _ as usize } , 7usize , concat ! (
                "Alignment of field: " , stringify ! ( pgpPktKeyV3_s ) , "::"
                , stringify ! ( pubkey_algo ) ));
}
impl Clone for pgpPktKeyV3_s {
    fn clone(&self) -> Self { *self }
}
pub type pgpPktKeyV3 = *mut pgpPktKeyV3_s;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pgpPktKeyV4_s {
    pub version: u8,
    pub time: pgpTime_t,
    pub pubkey_algo: u8,
}
#[test]
fn bindgen_test_layout_pgpPktKeyV4_s() {
    assert_eq!(::std::mem::size_of::<pgpPktKeyV4_s>() , 6usize , concat ! (
               "Size of: " , stringify ! ( pgpPktKeyV4_s ) ));
    assert_eq! (::std::mem::align_of::<pgpPktKeyV4_s>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( pgpPktKeyV4_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgpPktKeyV4_s ) ) . version as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pgpPktKeyV4_s ) , "::"
                , stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgpPktKeyV4_s ) ) . time as * const _ as
                usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( pgpPktKeyV4_s ) , "::"
                , stringify ! ( time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgpPktKeyV4_s ) ) . pubkey_algo as *
                const _ as usize } , 5usize , concat ! (
                "Alignment of field: " , stringify ! ( pgpPktKeyV4_s ) , "::"
                , stringify ! ( pubkey_algo ) ));
}
impl Clone for pgpPktKeyV4_s {
    fn clone(&self) -> Self { *self }
}
pub type pgpPktKeyV4 = *mut pgpPktKeyV4_s;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pgpPktKey_u {
    pub v3: __BindgenUnionField<pgpPktKeyV3_s>,
    pub v4: __BindgenUnionField<pgpPktKeyV4_s>,
    pub bindgen_union_field: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_pgpPktKey_u() {
    assert_eq!(::std::mem::size_of::<pgpPktKey_u>() , 8usize , concat ! (
               "Size of: " , stringify ! ( pgpPktKey_u ) ));
    assert_eq! (::std::mem::align_of::<pgpPktKey_u>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( pgpPktKey_u ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgpPktKey_u ) ) . v3 as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pgpPktKey_u ) , "::" ,
                stringify ! ( v3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgpPktKey_u ) ) . v4 as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pgpPktKey_u ) , "::" ,
                stringify ! ( v4 ) ));
}
impl Clone for pgpPktKey_u {
    fn clone(&self) -> Self { *self }
}
pub type pgpPktKey = pgpPktKey_u;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pgpPktCdata_s {
    pub compressalgo: u8,
    pub data: [u8; 1usize],
}
#[test]
fn bindgen_test_layout_pgpPktCdata_s() {
    assert_eq!(::std::mem::size_of::<pgpPktCdata_s>() , 2usize , concat ! (
               "Size of: " , stringify ! ( pgpPktCdata_s ) ));
    assert_eq! (::std::mem::align_of::<pgpPktCdata_s>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( pgpPktCdata_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgpPktCdata_s ) ) . compressalgo as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pgpPktCdata_s ) , "::"
                , stringify ! ( compressalgo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgpPktCdata_s ) ) . data as * const _ as
                usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( pgpPktCdata_s ) , "::"
                , stringify ! ( data ) ));
}
impl Clone for pgpPktCdata_s {
    fn clone(&self) -> Self { *self }
}
pub type pgpPktCdata = pgpPktCdata_s;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pgpPktEdata_s {
    pub data: [u8; 1usize],
}
#[test]
fn bindgen_test_layout_pgpPktEdata_s() {
    assert_eq!(::std::mem::size_of::<pgpPktEdata_s>() , 1usize , concat ! (
               "Size of: " , stringify ! ( pgpPktEdata_s ) ));
    assert_eq! (::std::mem::align_of::<pgpPktEdata_s>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( pgpPktEdata_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgpPktEdata_s ) ) . data as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pgpPktEdata_s ) , "::"
                , stringify ! ( data ) ));
}
impl Clone for pgpPktEdata_s {
    fn clone(&self) -> Self { *self }
}
pub type pgpPktEdata = pgpPktEdata_s;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pgpPktLdata_s {
    pub format: u8,
    pub filenamelen: u8,
    pub filename: [u8; 1usize],
}
#[test]
fn bindgen_test_layout_pgpPktLdata_s() {
    assert_eq!(::std::mem::size_of::<pgpPktLdata_s>() , 3usize , concat ! (
               "Size of: " , stringify ! ( pgpPktLdata_s ) ));
    assert_eq! (::std::mem::align_of::<pgpPktLdata_s>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( pgpPktLdata_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgpPktLdata_s ) ) . format as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pgpPktLdata_s ) , "::"
                , stringify ! ( format ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgpPktLdata_s ) ) . filenamelen as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( pgpPktLdata_s ) , "::"
                , stringify ! ( filenamelen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgpPktLdata_s ) ) . filename as * const _
                as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( pgpPktLdata_s ) , "::"
                , stringify ! ( filename ) ));
}
impl Clone for pgpPktLdata_s {
    fn clone(&self) -> Self { *self }
}
pub type pgpPktLdata = pgpPktLdata_s;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pgpPktTrust_s {
    pub flag: u8,
}
#[test]
fn bindgen_test_layout_pgpPktTrust_s() {
    assert_eq!(::std::mem::size_of::<pgpPktTrust_s>() , 1usize , concat ! (
               "Size of: " , stringify ! ( pgpPktTrust_s ) ));
    assert_eq! (::std::mem::align_of::<pgpPktTrust_s>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( pgpPktTrust_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgpPktTrust_s ) ) . flag as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pgpPktTrust_s ) , "::"
                , stringify ! ( flag ) ));
}
impl Clone for pgpPktTrust_s {
    fn clone(&self) -> Self { *self }
}
pub type pgpPktTrust = pgpPktTrust_s;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pgpPktUid_s {
    pub userid: [u8; 1usize],
}
#[test]
fn bindgen_test_layout_pgpPktUid_s() {
    assert_eq!(::std::mem::size_of::<pgpPktUid_s>() , 1usize , concat ! (
               "Size of: " , stringify ! ( pgpPktUid_s ) ));
    assert_eq! (::std::mem::align_of::<pgpPktUid_s>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( pgpPktUid_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgpPktUid_s ) ) . userid as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pgpPktUid_s ) , "::" ,
                stringify ! ( userid ) ));
}
impl Clone for pgpPktUid_s {
    fn clone(&self) -> Self { *self }
}
pub type pgpPktUid = pgpPktUid_s;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pgpPktPre_u {
    pub pubkey: __BindgenUnionField<pgpPktPubkey>,
    pub sig: __BindgenUnionField<pgpPktSig>,
    pub symkey: __BindgenUnionField<pgpPktSymkey>,
    pub onepass: __BindgenUnionField<pgpPktOnepass>,
    pub key: __BindgenUnionField<pgpPktKey>,
    pub cdata: __BindgenUnionField<pgpPktCdata>,
    pub edata: __BindgenUnionField<pgpPktEdata>,
    pub ldata: __BindgenUnionField<pgpPktLdata>,
    pub tdata: __BindgenUnionField<pgpPktTrust>,
    pub uid: __BindgenUnionField<pgpPktUid>,
    pub bindgen_union_field: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_pgpPktPre_u() {
    assert_eq!(::std::mem::size_of::<pgpPktPre_u>() , 16usize , concat ! (
               "Size of: " , stringify ! ( pgpPktPre_u ) ));
    assert_eq! (::std::mem::align_of::<pgpPktPre_u>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pgpPktPre_u ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgpPktPre_u ) ) . pubkey as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pgpPktPre_u ) , "::" ,
                stringify ! ( pubkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgpPktPre_u ) ) . sig as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pgpPktPre_u ) , "::" ,
                stringify ! ( sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgpPktPre_u ) ) . symkey as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pgpPktPre_u ) , "::" ,
                stringify ! ( symkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgpPktPre_u ) ) . onepass as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pgpPktPre_u ) , "::" ,
                stringify ! ( onepass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgpPktPre_u ) ) . key as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pgpPktPre_u ) , "::" ,
                stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgpPktPre_u ) ) . cdata as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pgpPktPre_u ) , "::" ,
                stringify ! ( cdata ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgpPktPre_u ) ) . edata as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pgpPktPre_u ) , "::" ,
                stringify ! ( edata ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgpPktPre_u ) ) . ldata as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pgpPktPre_u ) , "::" ,
                stringify ! ( ldata ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgpPktPre_u ) ) . tdata as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pgpPktPre_u ) , "::" ,
                stringify ! ( tdata ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgpPktPre_u ) ) . uid as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pgpPktPre_u ) , "::" ,
                stringify ! ( uid ) ));
}
impl Clone for pgpPktPre_u {
    fn clone(&self) -> Self { *self }
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pgpArmor_e {
    PGPARMOR_ERR_CRC_CHECK = -7,
    PGPARMOR_ERR_BODY_DECODE = -6,
    PGPARMOR_ERR_CRC_DECODE = -5,
    PGPARMOR_ERR_NO_END_PGP = -4,
    PGPARMOR_ERR_UNKNOWN_PREAMBLE_TAG = -3,
    PGPARMOR_ERR_UNKNOWN_ARMOR_TYPE = -2,
    PGPARMOR_ERR_NO_BEGIN_PGP = -1,
    PGPARMOR_NONE = 0,
    PGPARMOR_MESSAGE = 1,
    PGPARMOR_PUBKEY = 2,
    PGPARMOR_SIGNATURE = 3,
    PGPARMOR_SIGNED_MESSAGE = 4,
    PGPARMOR_FILE = 5,
    PGPARMOR_PRIVKEY = 6,
    PGPARMOR_SECKEY = 7,
}
pub use self::pgpArmor_e as pgpArmor;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pgpArmorKey_e {
    PGPARMORKEY_VERSION = 1,
    PGPARMORKEY_COMMENT = 2,
    PGPARMORKEY_MESSAGEID = 3,
    PGPARMORKEY_HASH = 4,
    PGPARMORKEY_CHARSET = 5,
}
pub use self::pgpArmorKey_e as pgpArmorKey;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pgpValType_e {
    PGPVAL_TAG = 1,
    PGPVAL_ARMORBLOCK = 2,
    PGPVAL_ARMORKEY = 3,
    PGPVAL_SIGTYPE = 4,
    PGPVAL_SUBTYPE = 5,
    PGPVAL_PUBKEYALGO = 6,
    PGPVAL_SYMKEYALGO = 7,
    PGPVAL_COMPRESSALGO = 8,
    PGPVAL_HASHALGO = 9,
    PGPVAL_SERVERPREFS = 10,
}
pub use self::pgpValType_e as pgpValType;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rpmDigestFlags_e { RPMDIGEST_NONE = 0, }
pub type rpmDigestFlags = rpmFlags;
extern "C" {
    pub fn pgpValString(type_: pgpValType, val: u8)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn pgpHexStr(p: *const u8, plen: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pgpPubkeyFingerprint(pkt: *const u8, pktlen: usize, keyid: *mut u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pgpExtractPubkeyFingerprint(b64pkt: *const ::std::os::raw::c_char,
                                       keyid: *mut u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pgpPrtParams(pkts: *const u8, pktlen: usize,
                        pkttype: ::std::os::raw::c_uint,
                        ret: *mut pgpDigParams) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pgpPrtParamsSubkeys(pkts: *const u8, pktlen: usize,
                               mainkey: pgpDigParams,
                               subkeys: *mut *mut pgpDigParams,
                               subkeysCount: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pgpPrtPkts(pkts: *const u8, pktlen: usize, dig: pgpDig,
                      printing: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pgpReadPkts(fn_: *const ::std::os::raw::c_char, pkt: *mut *mut u8,
                       pktlen: *mut usize) -> pgpArmor;
}
extern "C" {
    pub fn pgpParsePkts(armor: *const ::std::os::raw::c_char,
                        pkt: *mut *mut u8, pktlen: *mut usize) -> pgpArmor;
}
extern "C" {
    pub fn pgpPubKeyCertLen(pkts: *const u8, pktslen: usize,
                            certlen: *mut usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pgpArmorWrap(atype: ::std::os::raw::c_int,
                        s: *const ::std::os::raw::c_uchar, ns: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pgpNewDig() -> pgpDig;
}
extern "C" {
    pub fn pgpCleanDig(dig: pgpDig);
}
extern "C" {
    pub fn pgpFreeDig(dig: pgpDig) -> pgpDig;
}
extern "C" {
    pub fn pgpDigGetParams(dig: pgpDig, pkttype: ::std::os::raw::c_uint)
     -> pgpDigParams;
}
extern "C" {
    pub fn pgpDigParamsCmp(p1: pgpDigParams, p2: pgpDigParams)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pgpDigParamsAlgo(digp: pgpDigParams,
                            algotype: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn pgpDigParamsFree(digp: pgpDigParams) -> pgpDigParams;
}
extern "C" {
    pub fn pgpVerifySignature(key: pgpDigParams, sig: pgpDigParams,
                              hashctx: DIGEST_CTX) -> rpmRC;
}
extern "C" {
    pub fn pgpVerifySig(dig: pgpDig, hashctx: DIGEST_CTX) -> rpmRC;
}
extern "C" {
    pub fn pgpIdentItem(digp: pgpDigParams) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmInitCrypto() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmFreeCrypto() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmDigestDup(octx: DIGEST_CTX) -> DIGEST_CTX;
}
extern "C" {
    pub fn rpmDigestLength(hashalgo: ::std::os::raw::c_int) -> usize;
}
extern "C" {
    pub fn rpmDigestInit(hashalgo: ::std::os::raw::c_int,
                         flags: rpmDigestFlags) -> DIGEST_CTX;
}
extern "C" {
    pub fn rpmDigestUpdate(ctx: DIGEST_CTX,
                           data: *const ::std::os::raw::c_void, len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmDigestFinal(ctx: DIGEST_CTX,
                          datap: *mut *mut ::std::os::raw::c_void,
                          lenp: *mut usize, asAscii: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmDigestBundleNew() -> rpmDigestBundle;
}
extern "C" {
    pub fn rpmDigestBundleFree(bundle: rpmDigestBundle) -> rpmDigestBundle;
}
extern "C" {
    pub fn rpmDigestBundleAdd(bundle: rpmDigestBundle,
                              algo: ::std::os::raw::c_int,
                              flags: rpmDigestFlags) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmDigestBundleUpdate(bundle: rpmDigestBundle,
                                 data: *const ::std::os::raw::c_void,
                                 len: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmDigestBundleFinal(bundle: rpmDigestBundle,
                                algo: ::std::os::raw::c_int,
                                datap: *mut *mut ::std::os::raw::c_void,
                                lenp: *mut usize,
                                asAscii: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmDigestBundleDupCtx(bundle: rpmDigestBundle,
                                 algo: ::std::os::raw::c_int) -> DIGEST_CTX;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpmMacroContext_s {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "rpmGlobalMacroContext"]
    pub static mut rpmGlobalMacroContext: *mut rpmMacroContext_s;
}
extern "C" {
    #[link_name = "rpmCLIMacroContext"]
    pub static mut rpmCLIMacroContext: *mut rpmMacroContext_s;
}
extern "C" {
    #[link_name = "RPMVERSION"]
    pub static RPMVERSION: *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "rpmNAME"]
    pub static rpmNAME: *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "rpmEVR"]
    pub static rpmEVR: *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "rpmFLAGS"]
    pub static rpmFLAGS: ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rpm_machtable_e {
    RPM_MACHTABLE_INSTARCH = 0,
    RPM_MACHTABLE_INSTOS = 1,
    RPM_MACHTABLE_BUILDARCH = 2,
    RPM_MACHTABLE_BUILDOS = 3,
}
extern "C" {
    pub fn rpmReadConfigFiles(file: *const ::std::os::raw::c_char,
                              target: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmGetArchInfo(name: *mut *const ::std::os::raw::c_char,
                          num: *mut ::std::os::raw::c_int);
}
extern "C" {
    pub fn rpmGetArchColor(arch: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmGetOsInfo(name: *mut *const ::std::os::raw::c_char,
                        num: *mut ::std::os::raw::c_int);
}
extern "C" {
    pub fn rpmMachineScore(type_: ::std::os::raw::c_int,
                           name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmShowRC(fp: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmFreeRpmrc();
}
extern "C" {
    pub fn rpmVersionCompare(first: Header, second: Header)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn headerCheck(ts: rpmts, uh: *const ::std::os::raw::c_void,
                       uc: usize, msg: *mut *mut ::std::os::raw::c_char)
     -> rpmRC;
}
extern "C" {
    pub fn rpmReadHeader(ts: rpmts, fd: FD_t, hdrp: *mut Header,
                         msg: *mut *mut ::std::os::raw::c_char) -> rpmRC;
}
extern "C" {
    pub fn rpmReadPackageFile(ts: rpmts, fd: FD_t,
                              fn_: *const ::std::os::raw::c_char,
                              hdrp: *mut Header) -> rpmRC;
}
extern "C" {
    pub fn rpmInstallSourcePackage(ts: rpmts, fd: FD_t,
                                   specFilePtr:
                                       *mut *mut ::std::os::raw::c_char,
                                   cookie: *mut *mut ::std::os::raw::c_char)
     -> rpmRC;
}
extern "C" {
    pub fn rpmvercmp(a: *const ::std::os::raw::c_char,
                     b: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum urltype_e {
    URL_IS_UNKNOWN = 0,
    URL_IS_DASH = 1,
    URL_IS_PATH = 2,
    URL_IS_FTP = 3,
    URL_IS_HTTP = 4,
    URL_IS_HTTPS = 5,
    URL_IS_HKP = 6,
}
pub use self::urltype_e as urltype;
extern "C" {
    pub fn urlIsURL(url: *const ::std::os::raw::c_char) -> urltype;
}
extern "C" {
    pub fn urlPath(url: *const ::std::os::raw::c_char,
                   pathp: *mut *const ::std::os::raw::c_char) -> urltype;
}
extern "C" {
    pub fn urlGetFile(url: *const ::std::os::raw::c_char,
                      dest: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rpmCompressedMagic_e {
    COMPRESSED_NOT = 0,
    COMPRESSED_OTHER = 1,
    COMPRESSED_BZIP2 = 2,
    COMPRESSED_ZIP = 3,
    COMPRESSED_LZMA = 4,
    COMPRESSED_XZ = 5,
    COMPRESSED_LZIP = 6,
    COMPRESSED_LRZIP = 7,
    COMPRESSED_7ZIP = 8,
    COMPRESSED_GEM = 9,
}
pub use self::rpmCompressedMagic_e as rpmCompressedMagic;
extern "C" {
    pub fn rpmDoDigest(algo: ::std::os::raw::c_int,
                       fn_: *const ::std::os::raw::c_char,
                       asAscii: ::std::os::raw::c_int,
                       digest: *mut ::std::os::raw::c_uchar,
                       fsizep: *mut rpm_loff_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmMkTemp(templ: *mut ::std::os::raw::c_char) -> FD_t;
}
extern "C" {
    pub fn rpmMkTempFile(prefix: *const ::std::os::raw::c_char,
                         fn_: *mut *mut ::std::os::raw::c_char) -> FD_t;
}
extern "C" {
    pub fn rpmioMkpath(path: *const ::std::os::raw::c_char, mode: mode_t,
                       uid: uid_t, gid: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmMkdirs(root: *const ::std::os::raw::c_char,
                     pathstr: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmCleanPath(path: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmGenPath(urlroot: *const ::std::os::raw::c_char,
                      urlmdir: *const ::std::os::raw::c_char,
                      urlfile: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmGetPath(path: *const ::std::os::raw::c_char, ...)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmIsGlob(pattern: *const ::std::os::raw::c_char,
                     quote: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmGlob(patterns: *const ::std::os::raw::c_char,
                   argcPtr: *mut ::std::os::raw::c_int, argvPtr: *mut ARGV_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmEscapeSpaces(s: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmFileIsCompressed(file: *const ::std::os::raw::c_char,
                               compressed: *mut rpmCompressedMagic)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmFileHasSuffix(path: *const ::std::os::raw::c_char,
                            suffix: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmGetCwd() -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpmMacroEntry_s {
    _unused: [u8; 0],
}
pub type rpmMacroEntry = *mut rpmMacroEntry_s;
pub type rpmMacroContext = *mut rpmMacroContext_s;
extern "C" {
    #[link_name = "macrofiles"]
    pub static mut macrofiles: *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmDumpMacroTable(mc: rpmMacroContext, fp: *mut FILE);
}
extern "C" {
    pub fn expandMacros(spec: *mut ::std::os::raw::c_void,
                        mc: rpmMacroContext,
                        sbuf: *mut ::std::os::raw::c_char, slen: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmExpandMacros(mc: rpmMacroContext,
                           sbuf: *const ::std::os::raw::c_char,
                           obuf: *mut *mut ::std::os::raw::c_char,
                           flags: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn addMacro(mc: rpmMacroContext, n: *const ::std::os::raw::c_char,
                    o: *const ::std::os::raw::c_char,
                    b: *const ::std::os::raw::c_char,
                    level: ::std::os::raw::c_int);
}
extern "C" {
    pub fn delMacro(mc: rpmMacroContext, n: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn rpmDefineMacro(mc: rpmMacroContext,
                          macro_: *const ::std::os::raw::c_char,
                          level: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmLoadMacros(mc: rpmMacroContext, level: ::std::os::raw::c_int);
}
extern "C" {
    pub fn rpmLoadMacroFile(mc: rpmMacroContext,
                            fn_: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmInitMacros(mc: rpmMacroContext,
                         macrofiles: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn rpmFreeMacros(mc: rpmMacroContext);
}
extern "C" {
    pub fn rpmExpand(arg: *const ::std::os::raw::c_char, ...)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmExpandNumeric(arg: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmConfigDir() -> *const ::std::os::raw::c_char;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rpmCallbackType_e {
    RPMCALLBACK_UNKNOWN = 0,
    RPMCALLBACK_INST_PROGRESS = 1,
    RPMCALLBACK_INST_START = 2,
    RPMCALLBACK_INST_OPEN_FILE = 4,
    RPMCALLBACK_INST_CLOSE_FILE = 8,
    RPMCALLBACK_TRANS_PROGRESS = 16,
    RPMCALLBACK_TRANS_START = 32,
    RPMCALLBACK_TRANS_STOP = 64,
    RPMCALLBACK_UNINST_PROGRESS = 128,
    RPMCALLBACK_UNINST_START = 256,
    RPMCALLBACK_UNINST_STOP = 512,
    RPMCALLBACK_REPACKAGE_PROGRESS = 1024,
    RPMCALLBACK_REPACKAGE_START = 2048,
    RPMCALLBACK_REPACKAGE_STOP = 4096,
    RPMCALLBACK_UNPACK_ERROR = 8192,
    RPMCALLBACK_CPIO_ERROR = 16384,
    RPMCALLBACK_SCRIPT_ERROR = 32768,
    RPMCALLBACK_SCRIPT_START = 65536,
    RPMCALLBACK_SCRIPT_STOP = 131072,
    RPMCALLBACK_INST_STOP = 262144,
    RPMCALLBACK_ELEM_PROGRESS = 524288,
}
pub use self::rpmCallbackType_e as rpmCallbackType;
pub type rpmCallbackFunction =
    ::std::option::Option<unsafe extern "C" fn(h:
                                                   *const ::std::os::raw::c_void,
                                               what: rpmCallbackType,
                                               amount: rpm_loff_t,
                                               total: rpm_loff_t,
                                               key: fnpyKey,
                                               data: rpmCallbackData)
                              -> *mut ::std::os::raw::c_void>;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rpmElementType_e { TR_ADDED = 1, TR_REMOVED = 2, }
pub use self::rpmElementType_e as rpmElementType;
pub type rpmElementTypes = rpmFlags;
extern "C" {
    pub fn rpmteHeader(te: rpmte) -> Header;
}
extern "C" {
    pub fn rpmteSetHeader(te: rpmte, h: Header) -> Header;
}
extern "C" {
    pub fn rpmteType(te: rpmte) -> rpmElementType;
}
extern "C" {
    pub fn rpmteN(te: rpmte) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmteE(te: rpmte) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmteV(te: rpmte) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmteR(te: rpmte) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmteA(te: rpmte) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmteO(te: rpmte) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmteIsSource(te: rpmte) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmteColor(te: rpmte) -> rpm_color_t;
}
extern "C" {
    pub fn rpmteSetColor(te: rpmte, color: rpm_color_t) -> rpm_color_t;
}
extern "C" {
    pub fn rpmteDBInstance(te: rpmte) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rpmteSetDBInstance(te: rpmte, instance: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rpmtePkgFileSize(te: rpmte) -> rpm_loff_t;
}
extern "C" {
    pub fn rpmteParent(te: rpmte) -> rpmte;
}
extern "C" {
    pub fn rpmteSetParent(te: rpmte, pte: rpmte) -> rpmte;
}
extern "C" {
    pub fn rpmteProblems(te: rpmte) -> rpmps;
}
extern "C" {
    pub fn rpmteCleanProblems(te: rpmte);
}
extern "C" {
    pub fn rpmteCleanDS(te: rpmte);
}
extern "C" {
    pub fn rpmteSetDependsOn(te: rpmte, depends: rpmte);
}
extern "C" {
    pub fn rpmteDependsOn(te: rpmte) -> rpmte;
}
extern "C" {
    pub fn rpmteDBOffset(te: rpmte) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmteEVR(te: rpmte) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmteNEVR(te: rpmte) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmteNEVRA(te: rpmte) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmteKey(te: rpmte) -> fnpyKey;
}
extern "C" {
    pub fn rpmteFailed(te: rpmte) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmteDS(te: rpmte, tag: rpmTagVal) -> rpmds;
}
extern "C" {
    pub fn rpmteFiles(te: rpmte) -> rpmfiles;
}
extern "C" {
    pub fn rpmteFI(te: rpmte) -> rpmfi;
}
pub const rpmVerifyAttrs_e_RPMVERIFY_FILEDIGEST: rpmVerifyAttrs_e =
    rpmVerifyAttrs_e::RPMVERIFY_MD5;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rpmVerifyAttrs_e {
    RPMVERIFY_NONE = 0,
    RPMVERIFY_MD5 = 1,
    RPMVERIFY_FILESIZE = 2,
    RPMVERIFY_LINKTO = 4,
    RPMVERIFY_USER = 8,
    RPMVERIFY_GROUP = 16,
    RPMVERIFY_MTIME = 32,
    RPMVERIFY_MODE = 64,
    RPMVERIFY_RDEV = 128,
    RPMVERIFY_CAPS = 256,
    RPMVERIFY_CONTEXTS = 32768,
    RPMVERIFY_READLINKFAIL = 268435456,
    RPMVERIFY_READFAIL = 536870912,
    RPMVERIFY_LSTATFAIL = 1073741824,
    RPMVERIFY_LGETFILECONFAIL = -2147483648,
}
pub type rpmVerifyAttrs = rpmFlags;
pub const rpmVerifyFlags_e_VERIFY_FILEDIGEST: rpmVerifyFlags_e =
    rpmVerifyFlags_e::VERIFY_MD5;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rpmVerifyFlags_e {
    VERIFY_DEFAULT = 0,
    VERIFY_MD5 = 1,
    VERIFY_SIZE = 2,
    VERIFY_LINKTO = 4,
    VERIFY_USER = 8,
    VERIFY_GROUP = 16,
    VERIFY_MTIME = 32,
    VERIFY_MODE = 64,
    VERIFY_RDEV = 128,
    VERIFY_CAPS = 256,
    VERIFY_CONTEXTS = 32768,
    VERIFY_FILES = 65536,
    VERIFY_DEPS = 131072,
    VERIFY_SCRIPT = 262144,
    VERIFY_DIGEST = 524288,
    VERIFY_SIGNATURE = 1048576,
    VERIFY_PATCHES = 2097152,
    VERIFY_HDRCHK = 4194304,
    VERIFY_FOR_LIST = 8388608,
    VERIFY_FOR_STATE = 16777216,
    VERIFY_FOR_DOCS = 33554432,
    VERIFY_FOR_CONFIG = 67108864,
    VERIFY_FOR_DUMPFILES = 134217728,
}
pub type rpmVerifyFlags = rpmFlags;
extern "C" {
    pub fn rpmVerifyFile(ts: rpmts, fi: rpmfi, res: *mut rpmVerifyAttrs,
                         omitMask: rpmVerifyAttrs) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rpmFileTypes_e {
    PIPE = 1,
    CDEV = 2,
    XDIR = 4,
    BDEV = 6,
    REG = 8,
    LINK = 10,
    SOCK = 12,
}
pub use self::rpmFileTypes_e as rpmFileTypes;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rpmfileState_e {
    RPMFILE_STATE_MISSING = -1,
    RPMFILE_STATE_NORMAL = 0,
    RPMFILE_STATE_REPLACED = 1,
    RPMFILE_STATE_NOTINSTALLED = 2,
    RPMFILE_STATE_NETSHARED = 3,
    RPMFILE_STATE_WRONGCOLOR = 4,
}
pub use self::rpmfileState_e as rpmfileState;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rpmfileAttrs_e {
    RPMFILE_NONE = 0,
    RPMFILE_CONFIG = 1,
    RPMFILE_DOC = 2,
    RPMFILE_ICON = 4,
    RPMFILE_MISSINGOK = 8,
    RPMFILE_NOREPLACE = 16,
    RPMFILE_SPECFILE = 32,
    RPMFILE_GHOST = 64,
    RPMFILE_LICENSE = 128,
    RPMFILE_README = 256,
    RPMFILE_PUBKEY = 2048,
}
pub type rpmfileAttrs = rpmFlags;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rpmFileAction_e {
    FA_UNKNOWN = 0,
    FA_CREATE = 1,
    FA_COPYIN = 2,
    FA_COPYOUT = 3,
    FA_BACKUP = 4,
    FA_SAVE = 5,
    FA_SKIP = 6,
    FA_ALTNAME = 7,
    FA_ERASE = 8,
    FA_SKIPNSTATE = 9,
    FA_SKIPNETSHARED = 10,
    FA_SKIPCOLOR = 11,
}
pub use self::rpmFileAction_e as rpmFileAction;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rpmfiFlags_e {
    RPMFI_NOHEADER = 0,
    RPMFI_KEEPHEADER = 1,
    RPMFI_NOFILECLASS = 2,
    RPMFI_NOFILEDEPS = 4,
    RPMFI_NOFILELANGS = 8,
    RPMFI_NOFILEUSER = 16,
    RPMFI_NOFILEGROUP = 32,
    RPMFI_NOFILEMODES = 64,
    RPMFI_NOFILESIZES = 128,
    RPMFI_NOFILECAPS = 256,
    RPMFI_NOFILELINKTOS = 512,
    RPMFI_NOFILEDIGESTS = 1024,
    RPMFI_NOFILEMTIMES = 2048,
    RPMFI_NOFILERDEVS = 4096,
    RPMFI_NOFILEINODES = 8192,
    RPMFI_NOFILESTATES = 16384,
    RPMFI_NOFILECOLORS = 32768,
    RPMFI_NOFILEVERIFYFLAGS = 65536,
    RPMFI_NOFILEFLAGS = 131072,
    RPMFI_NOFILESIGNATURES = 262144,
}
pub type rpmfiFlags = rpmFlags;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rpmFileIter_e {
    RPMFI_ITER_FWD = 0,
    RPMFI_ITER_BACK = 1,
    RPMFI_ITER_WRITE_ARCHIVE = 2,
    RPMFI_ITER_READ_ARCHIVE = 3,
    RPMFI_ITER_READ_ARCHIVE_CONTENT_FIRST = 4,
    RPMFI_ITER_READ_ARCHIVE_OMIT_HARDLINKS = 5,
    RPMFI_ITER_INTERVAL = 6,
}
pub use self::rpmFileIter_e as rpmFileIter;
extern "C" {
    pub fn rpmfilesNew(pool: rpmstrPool, h: Header, tagN: rpmTagVal,
                       flags: rpmfiFlags) -> rpmfiles;
}
extern "C" {
    pub fn rpmfilesLink(fi: rpmfiles) -> rpmfiles;
}
extern "C" {
    pub fn rpmfilesFree(fi: rpmfiles) -> rpmfiles;
}
extern "C" {
    pub fn rpmfilesFC(fi: rpmfiles) -> rpm_count_t;
}
extern "C" {
    pub fn rpmfilesDC(fi: rpmfiles) -> rpm_count_t;
}
extern "C" {
    pub fn rpmfilesFindFN(files: rpmfiles, fn_: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmfilesFindOFN(files: rpmfiles,
                           fn_: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmfilesIter(files: rpmfiles, itype: ::std::os::raw::c_int)
     -> rpmfi;
}
extern "C" {
    pub fn rpmfilesDigestAlgo(fi: rpmfiles) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmfilesColor(files: rpmfiles) -> rpm_color_t;
}
extern "C" {
    pub fn rpmfilesCompare(afi: rpmfiles, aix: ::std::os::raw::c_int,
                           bfi: rpmfiles, bix: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmfilesBN(fi: rpmfiles, ix: ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmfilesDN(fi: rpmfiles, jx: ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmfilesDI(fi: rpmfiles, ix: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmfilesFN(fi: rpmfiles, ix: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmfilesODI(fi: rpmfiles, ix: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmfilesOBN(fi: rpmfiles, ix: ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmfilesODN(fi: rpmfiles, jx: ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmfilesOFN(fi: rpmfiles, ix: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmfilesVFlags(fi: rpmfiles, ix: ::std::os::raw::c_int)
     -> rpmVerifyAttrs;
}
extern "C" {
    pub fn rpmfilesFState(fi: rpmfiles, ix: ::std::os::raw::c_int)
     -> rpmfileState;
}
extern "C" {
    pub fn rpmfilesFLink(fi: rpmfiles, ix: ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmfilesFSize(fi: rpmfiles, ix: ::std::os::raw::c_int)
     -> rpm_loff_t;
}
extern "C" {
    pub fn rpmfilesFColor(fi: rpmfiles, ix: ::std::os::raw::c_int)
     -> rpm_color_t;
}
extern "C" {
    pub fn rpmfilesFClass(fi: rpmfiles, ix: ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmfilesFDepends(fi: rpmfiles, ix: ::std::os::raw::c_int,
                            fddictp: *mut *const u32) -> u32;
}
extern "C" {
    pub fn rpmfilesFNlink(fi: rpmfiles, ix: ::std::os::raw::c_int) -> u32;
}
extern "C" {
    pub fn rpmfilesFLinks(fi: rpmfiles, ix: ::std::os::raw::c_int,
                          files: *mut *const ::std::os::raw::c_int) -> u32;
}
extern "C" {
    pub fn rpmfilesFLangs(fi: rpmfiles, ix: ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmfilesFFlags(fi: rpmfiles, ix: ::std::os::raw::c_int)
     -> rpmfileAttrs;
}
extern "C" {
    pub fn rpmfilesFMode(fi: rpmfiles, ix: ::std::os::raw::c_int)
     -> rpm_mode_t;
}
extern "C" {
    pub fn rpmfilesFDigest(fi: rpmfiles, ix: ::std::os::raw::c_int,
                           algo: *mut ::std::os::raw::c_int, len: *mut usize)
     -> *const ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn rpmfilesFSignature(fi: rpmfiles, ix: ::std::os::raw::c_int,
                              len: *mut usize)
     -> *const ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn rpmfilesFRdev(fi: rpmfiles, ix: ::std::os::raw::c_int)
     -> rpm_rdev_t;
}
extern "C" {
    pub fn rpmfilesFInode(fi: rpmfiles, ix: ::std::os::raw::c_int)
     -> rpm_ino_t;
}
extern "C" {
    pub fn rpmfilesFMtime(fi: rpmfiles, ix: ::std::os::raw::c_int)
     -> rpm_time_t;
}
extern "C" {
    pub fn rpmfilesFUser(fi: rpmfiles, ix: ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmfilesFGroup(fi: rpmfiles, ix: ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmfilesFCaps(fi: rpmfiles, ix: ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmfilesStat(fi: rpmfiles, ix: ::std::os::raw::c_int,
                        flags: ::std::os::raw::c_int, sb: *mut stat)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmfiLink(fi: rpmfi) -> rpmfi;
}
extern "C" {
    pub fn rpmfiFC(fi: rpmfi) -> rpm_count_t;
}
extern "C" {
    pub fn rpmfiFX(fi: rpmfi) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmfiSetFX(fi: rpmfi, fx: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmfiDC(fi: rpmfi) -> rpm_count_t;
}
extern "C" {
    pub fn rpmfiDX(fi: rpmfi) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmfiSetDX(fi: rpmfi, dx: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmfiBN(fi: rpmfi) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmfiDN(fi: rpmfi) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmfiFN(fi: rpmfi) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmfiFindFN(fi: rpmfi, fn_: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmfiOBN(fi: rpmfi) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmfiODN(fi: rpmfi) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmfiOFN(fi: rpmfi) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmfiFindOFN(fi: rpmfi, fn_: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmfiFFlags(fi: rpmfi) -> rpmfileAttrs;
}
extern "C" {
    pub fn rpmfiVFlags(fi: rpmfi) -> rpmVerifyAttrs;
}
extern "C" {
    pub fn rpmfiFMode(fi: rpmfi) -> rpm_mode_t;
}
extern "C" {
    pub fn rpmfiFState(fi: rpmfi) -> rpmfileState;
}
extern "C" {
    pub fn rpmfiDigestAlgo(fi: rpmfi) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmfiFDigest(fi: rpmfi, algo: *mut ::std::os::raw::c_int,
                        diglen: *mut usize) -> *const ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn rpmfiFDigestHex(fi: rpmfi, algo: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmfiFSignature(fi: rpmfi, siglen: *mut usize)
     -> *const ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn rpmfiMD5(fi: rpmfi) -> *const ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn rpmfiFLink(fi: rpmfi) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmfiFSize(fi: rpmfi) -> rpm_loff_t;
}
extern "C" {
    pub fn rpmfiFRdev(fi: rpmfi) -> rpm_rdev_t;
}
extern "C" {
    pub fn rpmfiFInode(fi: rpmfi) -> rpm_ino_t;
}
extern "C" {
    pub fn rpmfiColor(fi: rpmfi) -> rpm_color_t;
}
extern "C" {
    pub fn rpmfiFColor(fi: rpmfi) -> rpm_color_t;
}
extern "C" {
    pub fn rpmfiFClass(fi: rpmfi) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmfiFDepends(fi: rpmfi, fddictp: *mut *const u32) -> u32;
}
extern "C" {
    pub fn rpmfiFNlink(fi: rpmfi) -> u32;
}
extern "C" {
    pub fn rpmfiFLinks(fi: rpmfi, files: *mut *const ::std::os::raw::c_int)
     -> u32;
}
extern "C" {
    pub fn rpmfiFMtime(fi: rpmfi) -> rpm_time_t;
}
extern "C" {
    pub fn rpmfiFUser(fi: rpmfi) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmfiFGroup(fi: rpmfi) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmfiFCaps(fi: rpmfi) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmfiFLangs(fi: rpmfi) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmfiStat(fi: rpmfi, flags: ::std::os::raw::c_int, sb: *mut stat)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmfiNext(fi: rpmfi) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmfiInit(fi: rpmfi, fx: ::std::os::raw::c_int) -> rpmfi;
}
extern "C" {
    pub fn rpmfiNextD(fi: rpmfi) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmfiInitD(fi: rpmfi, dx: ::std::os::raw::c_int) -> rpmfi;
}
extern "C" {
    pub fn rpmfiFree(fi: rpmfi) -> rpmfi;
}
extern "C" {
    pub fn rpmfiNewPool(pool: rpmstrPool, h: Header, tagN: rpmTagVal,
                        flags: rpmfiFlags) -> rpmfi;
}
extern "C" {
    pub fn rpmfiNew(ts: rpmts, h: Header, tagN: rpmTagVal, flags: rpmfiFlags)
     -> rpmfi;
}
extern "C" {
    pub fn rpmfiWhatis(mode: rpm_mode_t) -> rpmFileTypes;
}
extern "C" {
    pub fn rpmfiCompare(afi: rpmfi, bfi: rpmfi) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmfiDecideFate(ofi: rpmfi, nfi: rpmfi,
                           skipMissing: ::std::os::raw::c_int)
     -> rpmFileAction;
}
extern "C" {
    pub fn rpmfiConfigConflict(fi: rpmfi) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_rpmts_stats"]
    pub static mut _rpmts_stats: ::std::os::raw::c_int;
}
pub const rpmtransFlags_e_RPMTRANS_FLAG_NOFILEDIGEST: rpmtransFlags_e =
    rpmtransFlags_e::RPMTRANS_FLAG_NOMD5;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rpmtransFlags_e {
    RPMTRANS_FLAG_NONE = 0,
    RPMTRANS_FLAG_TEST = 1,
    RPMTRANS_FLAG_BUILD_PROBS = 2,
    RPMTRANS_FLAG_NOSCRIPTS = 4,
    RPMTRANS_FLAG_JUSTDB = 8,
    RPMTRANS_FLAG_NOTRIGGERS = 16,
    RPMTRANS_FLAG_NODOCS = 32,
    RPMTRANS_FLAG_ALLFILES = 64,
    RPMTRANS_FLAG_NOPLUGINS = 128,
    RPMTRANS_FLAG_NOCONTEXTS = 256,
    RPMTRANS_FLAG_NOTRIGGERPREIN = 65536,
    RPMTRANS_FLAG_NOPRE = 131072,
    RPMTRANS_FLAG_NOPOST = 262144,
    RPMTRANS_FLAG_NOTRIGGERIN = 524288,
    RPMTRANS_FLAG_NOTRIGGERUN = 1048576,
    RPMTRANS_FLAG_NOPREUN = 2097152,
    RPMTRANS_FLAG_NOPOSTUN = 4194304,
    RPMTRANS_FLAG_NOTRIGGERPOSTUN = 8388608,
    RPMTRANS_FLAG_NOPRETRANS = 16777216,
    RPMTRANS_FLAG_NOPOSTTRANS = 33554432,
    RPMTRANS_FLAG_NOMD5 = 134217728,
    RPMTRANS_FLAG_NOCONFIGS = 1073741824,
    RPMTRANS_FLAG_DEPLOOPS = -2147483648,
}
pub type rpmtransFlags = rpmFlags;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rpmVSFlags_e {
    RPMVSF_DEFAULT = 0,
    RPMVSF_NOHDRCHK = 1,
    RPMVSF_NEEDPAYLOAD = 2,
    RPMVSF_NOSHA1HEADER = 256,
    RPMVSF_NOMD5HEADER = 512,
    RPMVSF_NODSAHEADER = 1024,
    RPMVSF_NORSAHEADER = 2048,
    RPMVSF_NOSHA1 = 65536,
    RPMVSF_NOMD5 = 131072,
    RPMVSF_NODSA = 262144,
    RPMVSF_NORSA = 524288,
}
pub type rpmVSFlags = rpmFlags;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rpmtsOpX_e {
    RPMTS_OP_TOTAL = 0,
    RPMTS_OP_CHECK = 1,
    RPMTS_OP_ORDER = 2,
    RPMTS_OP_FINGERPRINT = 3,
    RPMTS_OP_INSTALL = 5,
    RPMTS_OP_ERASE = 6,
    RPMTS_OP_SCRIPTLETS = 7,
    RPMTS_OP_COMPRESS = 8,
    RPMTS_OP_UNCOMPRESS = 9,
    RPMTS_OP_DIGEST = 10,
    RPMTS_OP_SIGNATURE = 11,
    RPMTS_OP_DBADD = 12,
    RPMTS_OP_DBREMOVE = 13,
    RPMTS_OP_DBGET = 14,
    RPMTS_OP_DBPUT = 15,
    RPMTS_OP_DBDEL = 16,
    RPMTS_OP_MAX = 17,
}
pub use self::rpmtsOpX_e as rpmtsOpX;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rpmtxnFlags_e { RPMTXN_READ = 1, RPMTXN_WRITE = 2, }
pub type rpmtxnFlags = rpmFlags;
extern "C" {
    pub fn rpmtsCheck(ts: rpmts) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmtsOrder(ts: rpmts) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmtsRun(ts: rpmts, okProbs: rpmps, ignoreSet: rpmprobFilterFlags)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmtsLink(ts: rpmts) -> rpmts;
}
extern "C" {
    pub fn rpmtsCloseDB(ts: rpmts) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmtsOpenDB(ts: rpmts, dbmode: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmtsInitDB(ts: rpmts, dbmode: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmtsGetDBMode(ts: rpmts) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmtsSetDBMode(ts: rpmts, dbmode: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmtsRebuildDB(ts: rpmts) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmtsVerifyDB(ts: rpmts) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmtsInitIterator(ts: rpmts, rpmtag: rpmDbiTagVal,
                             keyp: *const ::std::os::raw::c_void,
                             keylen: usize) -> rpmdbMatchIterator;
}
extern "C" {
    pub fn rpmtsImportHeader(txn: rpmtxn, h: Header, flags: rpmFlags)
     -> rpmRC;
}
extern "C" {
    pub fn rpmtsImportPubkey(ts: rpmts, pkt: *const ::std::os::raw::c_uchar,
                             pktlen: usize) -> rpmRC;
}
extern "C" {
    pub fn rpmtsGetKeyring(ts: rpmts, autoload: ::std::os::raw::c_int)
     -> rpmKeyring;
}
extern "C" {
    pub fn rpmtsSetKeyring(ts: rpmts, keyring: rpmKeyring)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmtsSetSolveCallback(ts: rpmts,
                                 solve:
                                     ::std::option::Option<unsafe extern "C" fn(ts:
                                                                                    rpmts,
                                                                                ds:
                                                                                    rpmds,
                                                                                data:
                                                                                    *const ::std::os::raw::c_void)
                                                               ->
                                                                   ::std::os::raw::c_int>,
                                 solveData: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmtsProblems(ts: rpmts) -> rpmps;
}
extern "C" {
    pub fn rpmtsCleanProblems(ts: rpmts);
}
extern "C" {
    pub fn rpmtsClean(ts: rpmts);
}
extern "C" {
    pub fn rpmtsEmpty(ts: rpmts);
}
extern "C" {
    pub fn rpmtsFree(ts: rpmts) -> rpmts;
}
extern "C" {
    pub fn rpmtsVSFlags(ts: rpmts) -> rpmVSFlags;
}
extern "C" {
    pub fn rpmtsSetVSFlags(ts: rpmts, vsflags: rpmVSFlags) -> rpmVSFlags;
}
extern "C" {
    pub fn rpmtsRootDir(ts: rpmts) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmtsSetRootDir(ts: rpmts, rootDir: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmtsScriptFd(ts: rpmts) -> FD_t;
}
extern "C" {
    pub fn rpmtsSetScriptFd(ts: rpmts, scriptFd: FD_t);
}
extern "C" {
    pub fn rpmtsGetTid(ts: rpmts) -> rpm_tid_t;
}
extern "C" {
    pub fn rpmtsSetTid(ts: rpmts, tid: rpm_tid_t) -> rpm_tid_t;
}
extern "C" {
    pub fn rpmtsGetRdb(ts: rpmts) -> rpmdb;
}
extern "C" {
    pub fn rpmtsNotify(ts: rpmts, te: rpmte, what: rpmCallbackType,
                       amount: rpm_loff_t, total: rpm_loff_t)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn rpmtsNElements(ts: rpmts) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmtsElement(ts: rpmts, ix: ::std::os::raw::c_int) -> rpmte;
}
extern "C" {
    pub fn rpmtsFilterFlags(ts: rpmts) -> rpmprobFilterFlags;
}
extern "C" {
    pub fn rpmtsFlags(ts: rpmts) -> rpmtransFlags;
}
extern "C" {
    pub fn rpmtsSetFlags(ts: rpmts, transFlags: rpmtransFlags)
     -> rpmtransFlags;
}
extern "C" {
    pub fn rpmtsColor(ts: rpmts) -> rpm_color_t;
}
extern "C" {
    pub fn rpmtsPrefColor(ts: rpmts) -> rpm_color_t;
}
extern "C" {
    pub fn rpmtsSetColor(ts: rpmts, color: rpm_color_t) -> rpm_color_t;
}
extern "C" {
    pub fn rpmtsSetPrefColor(ts: rpmts, color: rpm_color_t) -> rpm_color_t;
}
extern "C" {
    pub fn rpmtsOp(ts: rpmts, opx: rpmtsOpX) -> rpmop;
}
extern "C" {
    pub fn rpmtsPlugins(ts: rpmts) -> rpmPlugins;
}
extern "C" {
    pub fn rpmtsSetNotifyCallback(ts: rpmts, notify: rpmCallbackFunction,
                                  notifyData: rpmCallbackData)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmtsCreate() -> rpmts;
}
extern "C" {
    pub fn rpmtsAddInstallElement(ts: rpmts, h: Header, key: fnpyKey,
                                  upgrade: ::std::os::raw::c_int,
                                  relocs: *mut rpmRelocation)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmtsAddReinstallElement(ts: rpmts, h: Header, key: fnpyKey)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmtsAddEraseElement(ts: rpmts, h: Header,
                                dboffset: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmtxnBegin(ts: rpmts, flags: rpmtxnFlags) -> rpmtxn;
}
extern "C" {
    pub fn rpmtxnEnd(txn: rpmtxn) -> rpmtxn;
}
extern "C" {
    pub fn rpmtsiFree(tsi: rpmtsi) -> rpmtsi;
}
extern "C" {
    pub fn rpmtsiInit(ts: rpmts) -> rpmtsi;
}
extern "C" {
    pub fn rpmtsiNext(tsi: rpmtsi, types: rpmElementTypes) -> rpmte;
}
extern "C" {
    #[link_name = "rpmcliAllPoptTable"]
    pub static mut rpmcliAllPoptTable: [poptOption; 0usize];
}
extern "C" {
    #[link_name = "rpmcliPipeOutput"]
    pub static mut rpmcliPipeOutput: *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "rpmcliRcfile"]
    pub static mut rpmcliRcfile: *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "rpmcliRootDir"]
    pub static mut rpmcliRootDir: *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmcliInit(argc: ::std::os::raw::c_int,
                      argv: *const *const ::std::os::raw::c_char,
                      optionsTable: *mut poptOption) -> poptContext;
}
extern "C" {
    pub fn rpmcliConfigured();
}
extern "C" {
    pub fn rpmcliFini(optCon: poptContext) -> poptContext;
}
pub const rpmQVSources_e_RPMQV_SPECFILE: rpmQVSources_e =
    rpmQVSources_e::RPMQV_SPECRPMS;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rpmQVSources_e {
    RPMQV_PACKAGE = 0,
    RPMQV_PATH = 1,
    RPMQV_ALL = 2,
    RPMQV_RPM = 3,
    RPMQV_GROUP = 4,
    RPMQV_WHATPROVIDES = 5,
    RPMQV_WHATREQUIRES = 6,
    RPMQV_TRIGGEREDBY = 7,
    RPMQV_DBOFFSET = 8,
    RPMQV_SPECRPMS = 9,
    RPMQV_PKGID = 10,
    RPMQV_HDRID = 11,
    RPMQV_TID = 12,
    RPMQV_SPECSRPM = 13,
    RPMQV_WHATRECOMMENDS = 14,
    RPMQV_WHATSUGGESTS = 15,
    RPMQV_WHATSUPPLEMENTS = 16,
    RPMQV_WHATENHANCES = 17,
}
pub type rpmQVSources = rpmFlags;
pub const rpmQueryFlags_e_QUERY_FILEDIGEST: rpmQueryFlags_e =
    rpmQueryFlags_e::QUERY_MD5;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rpmQueryFlags_e {
    QUERY_FOR_DEFAULT = 0,
    QUERY_MD5 = 1,
    QUERY_SIZE = 2,
    QUERY_LINKTO = 4,
    QUERY_USER = 8,
    QUERY_GROUP = 16,
    QUERY_MTIME = 32,
    QUERY_MODE = 64,
    QUERY_RDEV = 128,
    QUERY_CONTEXTS = 32768,
    QUERY_FILES = 65536,
    QUERY_DEPS = 131072,
    QUERY_SCRIPT = 262144,
    QUERY_DIGEST = 524288,
    QUERY_SIGNATURE = 1048576,
    QUERY_PATCHES = 2097152,
    QUERY_HDRCHK = 4194304,
    QUERY_FOR_LIST = 8388608,
    QUERY_FOR_STATE = 16777216,
    QUERY_FOR_DOCS = 33554432,
    QUERY_FOR_CONFIG = 67108864,
    QUERY_FOR_DUMPFILES = 134217728,
    QUERY_FOR_LICENSE = 268435456,
}
pub type rpmQueryFlags = rpmFlags;
extern "C" {
    #[link_name = "rpmcliQueryFlags"]
    pub static mut rpmcliQueryFlags: rpmQueryFlags;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rpmQVKArguments_s {
    pub qva_source: rpmQVSources,
    pub qva_sourceCount: ::std::os::raw::c_int,
    pub qva_flags: rpmQueryFlags,
    pub qva_fflags: rpmfileAttrs,
    pub qva_showPackage: QVF_t,
    pub qva_specQuery: QSpecF_t,
    pub qva_queryFormat: *mut ::std::os::raw::c_char,
    pub qva_mode: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_rpmQVKArguments_s() {
    assert_eq!(::std::mem::size_of::<rpmQVKArguments_s>() , 48usize , concat !
               ( "Size of: " , stringify ! ( rpmQVKArguments_s ) ));
    assert_eq! (::std::mem::align_of::<rpmQVKArguments_s>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( rpmQVKArguments_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rpmQVKArguments_s ) ) . qva_source as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rpmQVKArguments_s ) ,
                "::" , stringify ! ( qva_source ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rpmQVKArguments_s ) ) . qva_sourceCount
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rpmQVKArguments_s ) ,
                "::" , stringify ! ( qva_sourceCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rpmQVKArguments_s ) ) . qva_flags as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rpmQVKArguments_s ) ,
                "::" , stringify ! ( qva_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rpmQVKArguments_s ) ) . qva_fflags as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( rpmQVKArguments_s ) ,
                "::" , stringify ! ( qva_fflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rpmQVKArguments_s ) ) . qva_showPackage
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rpmQVKArguments_s ) ,
                "::" , stringify ! ( qva_showPackage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rpmQVKArguments_s ) ) . qva_specQuery as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rpmQVKArguments_s ) ,
                "::" , stringify ! ( qva_specQuery ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rpmQVKArguments_s ) ) . qva_queryFormat
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rpmQVKArguments_s ) ,
                "::" , stringify ! ( qva_queryFormat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rpmQVKArguments_s ) ) . qva_mode as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rpmQVKArguments_s ) ,
                "::" , stringify ! ( qva_mode ) ));
}
impl Clone for rpmQVKArguments_s {
    fn clone(&self) -> Self { *self }
}
pub type QVA_t = *mut rpmQVKArguments_s;
pub type QVF_t =
    ::std::option::Option<unsafe extern "C" fn(qva: QVA_t, ts: rpmts,
                                               h: Header)
                              -> ::std::os::raw::c_int>;
pub type QSpecF_t =
    ::std::option::Option<unsafe extern "C" fn(ts: rpmts, qva: QVA_t,
                                               arg:
                                                   *const ::std::os::raw::c_char)
                              -> ::std::os::raw::c_int>;
extern "C" {
    #[link_name = "rpmQVKArgs"]
    pub static mut rpmQVKArgs: rpmQVKArguments_s;
}
extern "C" {
    #[link_name = "rpmQVSourcePoptTable"]
    pub static mut rpmQVSourcePoptTable: [poptOption; 0usize];
}
extern "C" {
    #[link_name = "rpmQueryPoptTable"]
    pub static mut rpmQueryPoptTable: [poptOption; 0usize];
}
extern "C" {
    #[link_name = "rpmVerifyPoptTable"]
    pub static mut rpmVerifyPoptTable: [poptOption; 0usize];
}
extern "C" {
    pub fn rpmDisplayQueryTags(fp: *mut FILE);
}
extern "C" {
    pub fn showQueryPackage(qva: QVA_t, ts: rpmts, h: Header)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmcliArgIter(ts: rpmts, qva: QVA_t, argv: ARGV_const_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmcliQuery(ts: rpmts, qva: QVA_t, argv: ARGV_const_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn showVerifyPackage(qva: QVA_t, ts: rpmts, h: Header)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmVerifySignatures(qva: QVA_t, ts: rpmts, fd: FD_t,
                               fn_: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmcliVerify(ts: rpmts, qva: QVA_t, argv: ARGV_const_t)
     -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rpmInstallFlags_e {
    INSTALL_NONE = 0,
    INSTALL_PERCENT = 1,
    INSTALL_HASH = 2,
    INSTALL_NODEPS = 4,
    INSTALL_NOORDER = 8,
    INSTALL_LABEL = 16,
    INSTALL_UPGRADE = 32,
    INSTALL_FRESHEN = 64,
    INSTALL_INSTALL = 128,
    INSTALL_ERASE = 256,
    INSTALL_ALLMATCHES = 512,
    INSTALL_REINSTALL = 1024,
}
pub type rpmInstallFlags = rpmFlags;
extern "C" {
    pub fn rpmShowProgress(arg: *const ::std::os::raw::c_void,
                           what: rpmCallbackType, amount: rpm_loff_t,
                           total: rpm_loff_t, key: fnpyKey,
                           data: *mut ::std::os::raw::c_void)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn rpmInstallSource(ts: rpmts, arg: *const ::std::os::raw::c_char,
                            specFilePtr: *mut *mut ::std::os::raw::c_char,
                            cookie: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rpmInstallArguments_s {
    pub transFlags: rpmtransFlags,
    pub probFilter: rpmprobFilterFlags,
    pub installInterfaceFlags: rpmInstallFlags,
    pub numRelocations: ::std::os::raw::c_int,
    pub noDeps: ::std::os::raw::c_int,
    pub incldocs: ::std::os::raw::c_int,
    pub relocations: *mut rpmRelocation,
    pub prefix: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_rpmInstallArguments_s() {
    assert_eq!(::std::mem::size_of::<rpmInstallArguments_s>() , 40usize ,
               concat ! ( "Size of: " , stringify ! ( rpmInstallArguments_s )
               ));
    assert_eq! (::std::mem::align_of::<rpmInstallArguments_s>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rpmInstallArguments_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rpmInstallArguments_s ) ) . transFlags as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rpmInstallArguments_s )
                , "::" , stringify ! ( transFlags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rpmInstallArguments_s ) ) . probFilter as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rpmInstallArguments_s )
                , "::" , stringify ! ( probFilter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rpmInstallArguments_s ) ) .
                installInterfaceFlags as * const _ as usize } , 8usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rpmInstallArguments_s )
                , "::" , stringify ! ( installInterfaceFlags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rpmInstallArguments_s ) ) .
                numRelocations as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( rpmInstallArguments_s )
                , "::" , stringify ! ( numRelocations ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rpmInstallArguments_s ) ) . noDeps as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rpmInstallArguments_s )
                , "::" , stringify ! ( noDeps ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rpmInstallArguments_s ) ) . incldocs as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( rpmInstallArguments_s )
                , "::" , stringify ! ( incldocs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rpmInstallArguments_s ) ) . relocations
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rpmInstallArguments_s )
                , "::" , stringify ! ( relocations ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rpmInstallArguments_s ) ) . prefix as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rpmInstallArguments_s )
                , "::" , stringify ! ( prefix ) ));
}
impl Clone for rpmInstallArguments_s {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn rpmInstall(ts: rpmts, ia: *mut rpmInstallArguments_s,
                      fileArgv: ARGV_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmErase(ts: rpmts, ia: *mut rpmInstallArguments_s,
                    argv: ARGV_const_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "rpmIArgs"]
    pub static mut rpmIArgs: rpmInstallArguments_s;
}
extern "C" {
    #[link_name = "rpmInstallPoptTable"]
    pub static mut rpmInstallPoptTable: [poptOption; 0usize];
}
extern "C" {
    pub fn rpmcliImportPubkeys(ts: rpmts, argv: ARGV_const_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmcliVerifySignatures(ts: rpmts, argv: ARGV_const_t)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Package_s {
    _unused: [u8; 0],
}
pub type rpmSpecPkg = *mut Package_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Source {
    _unused: [u8; 0],
}
pub type rpmSpecSrc = *mut Source;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpmSpecIter_s {
    _unused: [u8; 0],
}
pub type rpmSpecPkgIter = *mut rpmSpecIter_s;
pub type rpmSpecSrcIter = *mut rpmSpecIter_s;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rpmSourceFlags_e {
    RPMBUILD_ISSOURCE = 1,
    RPMBUILD_ISPATCH = 2,
    RPMBUILD_ISICON = 4,
    RPMBUILD_ISNO = 8,
}
pub type rpmSourceFlags = rpmFlags;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rpmSpecFlags_e {
    RPMSPEC_NONE = 0,
    RPMSPEC_ANYARCH = 1,
    RPMSPEC_FORCE = 2,
    RPMSPEC_NOLANG = 4,
    RPMSPEC_NOUTF8 = 8,
}
pub type rpmSpecFlags = rpmFlags;
extern "C" {
    pub fn rpmSpecFree(spec: rpmSpec) -> rpmSpec;
}
extern "C" {
    pub fn rpmSpecPkgIterInit(spec: rpmSpec) -> rpmSpecPkgIter;
}
extern "C" {
    pub fn rpmSpecPkgIterNext(iter: rpmSpecPkgIter) -> rpmSpecPkg;
}
extern "C" {
    pub fn rpmSpecPkgIterFree(iter: rpmSpecPkgIter) -> rpmSpecPkgIter;
}
extern "C" {
    pub fn rpmSpecPkgHeader(pkg: rpmSpecPkg) -> Header;
}
extern "C" {
    pub fn rpmSpecPkgGetSection(pkg: rpmSpecPkg,
                                section: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmSpecSrcIterInit(spec: rpmSpec) -> rpmSpecSrcIter;
}
extern "C" {
    pub fn rpmSpecSrcIterNext(iter: rpmSpecSrcIter) -> rpmSpecSrc;
}
extern "C" {
    pub fn rpmSpecSrcIterFree(iter: rpmSpecSrcIter) -> rpmSpecSrcIter;
}
extern "C" {
    pub fn rpmSpecSrcFlags(src: rpmSpecSrc) -> rpmSourceFlags;
}
extern "C" {
    pub fn rpmSpecSrcNum(src: rpmSpecSrc) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmSpecSrcFilename(src: rpmSpecSrc, full: ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmSpecGetSection(spec: rpmSpec, section: ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmspecQuery(ts: rpmts, qva: QVA_t,
                        arg: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rpmBuildFlags_e {
    RPMBUILD_NONE = 0,
    RPMBUILD_PREP = 1,
    RPMBUILD_BUILD = 2,
    RPMBUILD_INSTALL = 4,
    RPMBUILD_CHECK = 8,
    RPMBUILD_CLEAN = 16,
    RPMBUILD_FILECHECK = 32,
    RPMBUILD_PACKAGESOURCE = 64,
    RPMBUILD_PACKAGEBINARY = 128,
    RPMBUILD_RMSOURCE = 256,
    RPMBUILD_RMBUILD = 512,
    RPMBUILD_STRINGBUF = 1024,
    RPMBUILD_RMSPEC = 2048,
    RPMBUILD_FILE_FILE = 65536,
    RPMBUILD_FILE_LIST = 131072,
    RPMBUILD_POLICY = 262144,
    RPMBUILD_NOBUILD = -2147483648,
}
pub type rpmBuildFlags = rpmFlags;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rpmBuildPkgFlags_e {
    RPMBUILD_PKG_NONE = 0,
    RPMBUILD_PKG_NODIRTOKENS = 1,
}
pub type rpmBuildPkgFlags = rpmFlags;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rpmBuildArguments_s {
    pub pkgFlags: rpmBuildPkgFlags,
    pub buildAmount: rpmBuildFlags,
    pub buildRootOverride: *mut ::std::os::raw::c_char,
    pub cookie: *mut ::std::os::raw::c_char,
    pub rootdir: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_rpmBuildArguments_s() {
    assert_eq!(::std::mem::size_of::<rpmBuildArguments_s>() , 32usize , concat
               ! ( "Size of: " , stringify ! ( rpmBuildArguments_s ) ));
    assert_eq! (::std::mem::align_of::<rpmBuildArguments_s>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rpmBuildArguments_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rpmBuildArguments_s ) ) . pkgFlags as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rpmBuildArguments_s ) ,
                "::" , stringify ! ( pkgFlags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rpmBuildArguments_s ) ) . buildAmount as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( rpmBuildArguments_s ) ,
                "::" , stringify ! ( buildAmount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rpmBuildArguments_s ) ) .
                buildRootOverride as * const _ as usize } , 8usize , concat !
                (
                "Alignment of field: " , stringify ! ( rpmBuildArguments_s ) ,
                "::" , stringify ! ( buildRootOverride ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rpmBuildArguments_s ) ) . cookie as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rpmBuildArguments_s ) ,
                "::" , stringify ! ( cookie ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rpmBuildArguments_s ) ) . rootdir as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rpmBuildArguments_s ) ,
                "::" , stringify ! ( rootdir ) ));
}
impl Clone for rpmBuildArguments_s {
    fn clone(&self) -> Self { *self }
}
pub type BTA_t = *mut rpmBuildArguments_s;
extern "C" {
    pub fn rpmSpecParse(specFile: *const ::std::os::raw::c_char,
                        flags: rpmSpecFlags,
                        buildRoot: *const ::std::os::raw::c_char) -> rpmSpec;
}
extern "C" {
    pub fn rpmSpecSourceHeader(spec: rpmSpec) -> Header;
}
extern "C" {
    pub fn rpmSpecCheckDeps(ts: rpmts, spec: rpmSpec) -> rpmps;
}
extern "C" {
    pub fn rpmSpecDS(spec: rpmSpec, tag: rpmTagVal) -> rpmds;
}
extern "C" {
    pub fn rpmSpecBuild(spec: rpmSpec, buildArgs: BTA_t) -> rpmRC;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rpmMireMode_e {
    RPMMIRE_DEFAULT = 0,
    RPMMIRE_STRCMP = 1,
    RPMMIRE_REGEX = 2,
    RPMMIRE_GLOB = 3,
}
pub use self::rpmMireMode_e as rpmMireMode;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rpmdbOpX_e {
    RPMDB_OP_DBGET = 1,
    RPMDB_OP_DBPUT = 2,
    RPMDB_OP_DBDEL = 3,
    RPMDB_OP_MAX = 4,
}
pub use self::rpmdbOpX_e as rpmdbOpX;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rpmdbCtrlOp_e {
    RPMDB_CTRL_LOCK_RO = 1,
    RPMDB_CTRL_UNLOCK_RO = 2,
    RPMDB_CTRL_LOCK_RW = 3,
    RPMDB_CTRL_UNLOCK_RW = 4,
    RPMDB_CTRL_INDEXSYNC = 5,
}
pub use self::rpmdbCtrlOp_e as rpmdbCtrlOp;
extern "C" {
    pub fn rpmdbOp(db: rpmdb, opx: rpmdbOpX) -> rpmop;
}
extern "C" {
    pub fn rpmdbOpenAll(db: rpmdb) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmdbCountPackages(db: rpmdb, name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmdbGetIteratorOffset(mi: rpmdbMatchIterator)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rpmdbGetIteratorCount(mi: rpmdbMatchIterator)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmdbGetIteratorFileNum(mi: rpmdbMatchIterator)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rpmdbAppendIterator(mi: rpmdbMatchIterator,
                               hdrNums: *const ::std::os::raw::c_uint,
                               nHdrNums: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmdbSetIteratorRE(mi: rpmdbMatchIterator, tag: rpmTagVal,
                              mode: rpmMireMode,
                              pattern: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmdbSetIteratorRewrite(mi: rpmdbMatchIterator,
                                   rewrite: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmdbSetIteratorModified(mi: rpmdbMatchIterator,
                                    modified: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmdbSetHdrChk(mi: rpmdbMatchIterator, ts: rpmts,
                          hdrchk:
                              ::std::option::Option<unsafe extern "C" fn(ts:
                                                                             rpmts,
                                                                         uh:
                                                                             *const ::std::os::raw::c_void,
                                                                         uc:
                                                                             usize,
                                                                         msg:
                                                                             *mut *mut ::std::os::raw::c_char)
                                                        -> rpmRC>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmdbInitIterator(db: rpmdb, rpmtag: rpmDbiTagVal,
                             keyp: *const ::std::os::raw::c_void,
                             keylen: usize) -> rpmdbMatchIterator;
}
extern "C" {
    pub fn rpmdbNextIterator(mi: rpmdbMatchIterator) -> Header;
}
extern "C" {
    pub fn rpmdbCheckSignals() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmdbCheckTerminate(terminate: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmdbFreeIterator(mi: rpmdbMatchIterator) -> rpmdbMatchIterator;
}
extern "C" {
    pub fn rpmdbIndexIteratorInit(db: rpmdb, rpmtag: rpmDbiTag)
     -> rpmdbIndexIterator;
}
extern "C" {
    pub fn rpmdbIndexIteratorNext(ii: rpmdbIndexIterator,
                                  key: *mut *const ::std::os::raw::c_void,
                                  keylen: *mut usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmdbIndexIteratorNextTd(ii: rpmdbIndexIterator, keytd: rpmtd)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmdbIndexIteratorNumPkgs(ii: rpmdbIndexIterator)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rpmdbIndexIteratorPkgOffset(ii: rpmdbIndexIterator,
                                       nr: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rpmdbIndexIteratorTagNum(ii: rpmdbIndexIterator,
                                    nr: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rpmdbIndexIteratorFree(ii: rpmdbIndexIterator)
     -> rpmdbIndexIterator;
}
extern "C" {
    pub fn rpmdbCtrl(db: rpmdb, ctrl: rpmdbCtrlOp) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_rpmfc_debug"]
    pub static mut _rpmfc_debug: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpmfc_s {
    _unused: [u8; 0],
}
pub type rpmfc = *mut rpmfc_s;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum FCOLOR_e {
    RPMFC_BLACK = 0,
    RPMFC_ELF32 = 1,
    RPMFC_ELF64 = 2,
    RPMFC_ELFMIPSN32 = 4,
    RPMFC_WHITE = 536870912,
    RPMFC_INCLUDE = 1073741824,
    RPMFC_ERROR = -2147483648,
}
pub type FCOLOR_t = rpmFlags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpmfcTokens_s {
    _unused: [u8; 0],
}
pub type rpmfcToken = *const rpmfcTokens_s;
extern "C" {
    pub fn rpmfcPrint(msg: *const ::std::os::raw::c_char, fc: rpmfc,
                      fp: *mut FILE);
}
extern "C" {
    pub fn rpmfcFree(fc: rpmfc) -> rpmfc;
}
extern "C" {
    pub fn rpmfcCreate(rootDir: *const ::std::os::raw::c_char,
                       flags: rpmFlags) -> rpmfc;
}
extern "C" {
    pub fn rpmfcNew() -> rpmfc;
}
extern "C" {
    pub fn rpmfcClassify(fc: rpmfc, argv: ARGV_t, fmode: *mut rpm_mode_t)
     -> rpmRC;
}
extern "C" {
    pub fn rpmfcApply(fc: rpmfc) -> rpmRC;
}
extern "C" {
    pub fn rpmfcProvides(fc: rpmfc) -> rpmds;
}
extern "C" {
    pub fn rpmfcRequires(fc: rpmfc) -> rpmds;
}
extern "C" {
    pub fn rpmfcRecommends(fc: rpmfc) -> rpmds;
}
extern "C" {
    pub fn rpmfcSuggests(fc: rpmfc) -> rpmds;
}
extern "C" {
    pub fn rpmfcSupplements(fc: rpmfc) -> rpmds;
}
extern "C" {
    pub fn rpmfcEnhances(fc: rpmfc) -> rpmds;
}
extern "C" {
    pub fn rpmfcConflicts(fc: rpmfc) -> rpmds;
}
extern "C" {
    pub fn rpmfcObsoletes(fc: rpmfc) -> rpmds;
}
extern "C" {
    pub fn rpmfcDependencies(fc: rpmfc, tagN: rpmTagVal) -> rpmds;
}
extern "C" {
    pub fn rpmKeyringNew() -> rpmKeyring;
}
extern "C" {
    pub fn rpmKeyringFree(keyring: rpmKeyring) -> rpmKeyring;
}
extern "C" {
    pub fn rpmKeyringAddKey(keyring: rpmKeyring, key: rpmPubkey)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmKeyringLookup(keyring: rpmKeyring, sig: pgpDig) -> rpmRC;
}
extern "C" {
    pub fn rpmKeyringVerifySig(keyring: rpmKeyring, sig: pgpDigParams,
                               ctx: DIGEST_CTX) -> rpmRC;
}
extern "C" {
    pub fn rpmKeyringLink(keyring: rpmKeyring) -> rpmKeyring;
}
extern "C" {
    pub fn rpmPubkeyNew(pkt: *const u8, pktlen: usize) -> rpmPubkey;
}
extern "C" {
    pub fn rpmGetSubkeys(mainkey: rpmPubkey,
                         count: *mut ::std::os::raw::c_int) -> *mut rpmPubkey;
}
extern "C" {
    pub fn rpmPubkeyRead(filename: *const ::std::os::raw::c_char)
     -> rpmPubkey;
}
extern "C" {
    pub fn rpmPubkeyFree(key: rpmPubkey) -> rpmPubkey;
}
extern "C" {
    pub fn rpmPubkeyLink(key: rpmPubkey) -> rpmPubkey;
}
extern "C" {
    pub fn rpmPubkeyDig(key: rpmPubkey) -> pgpDig;
}
extern "C" {
    pub fn rpmPubkeyBase64(key: rpmPubkey) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmPubkeyPgpDigParams(key: rpmPubkey) -> pgpDigParams;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rpmlogLvl_e {
    RPMLOG_EMERG = 0,
    RPMLOG_ALERT = 1,
    RPMLOG_CRIT = 2,
    RPMLOG_ERR = 3,
    RPMLOG_WARNING = 4,
    RPMLOG_NOTICE = 5,
    RPMLOG_INFO = 6,
    RPMLOG_DEBUG = 7,
}
pub use self::rpmlogLvl_e as rpmlogLvl;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rpmlogFac_e {
    RPMLOG_KERN = 0,
    RPMLOG_USER = 8,
    RPMLOG_MAIL = 16,
    RPMLOG_DAEMON = 24,
    RPMLOG_AUTH = 32,
    RPMLOG_SYSLOG = 40,
    RPMLOG_LPR = 48,
    RPMLOG_NEWS = 56,
    RPMLOG_UUCP = 64,
    RPMLOG_CRON = 72,
    RPMLOG_AUTHPRIV = 80,
    RPMLOG_FTP = 88,
    RPMLOG_LOCAL0 = 128,
    RPMLOG_LOCAL1 = 136,
    RPMLOG_LOCAL2 = 144,
    RPMLOG_LOCAL3 = 152,
    RPMLOG_LOCAL4 = 160,
    RPMLOG_LOCAL5 = 168,
    RPMLOG_LOCAL6 = 176,
    RPMLOG_LOCAL7 = 184,
    RPMLOG_ERRMSG = 192,
}
pub use self::rpmlogFac_e as rpmlogFac;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpmlogRec_s {
    _unused: [u8; 0],
}
pub type rpmlogRec = *mut rpmlogRec_s;
extern "C" {
    pub fn rpmlogRecMessage(rec: rpmlogRec) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmlogRecPriority(rec: rpmlogRec) -> rpmlogLvl;
}
pub type rpmlogCallbackData = *mut ::std::os::raw::c_void;
pub type rpmlogCallback =
    ::std::option::Option<unsafe extern "C" fn(rec: rpmlogRec,
                                               data: rpmlogCallbackData)
                              -> ::std::os::raw::c_int>;
extern "C" {
    pub fn rpmlogGetNrecs() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmlogPrint(f: *mut FILE);
}
extern "C" {
    pub fn rpmlogClose();
}
extern "C" {
    pub fn rpmlogOpen(ident: *const ::std::os::raw::c_char,
                      option: ::std::os::raw::c_int,
                      facility: ::std::os::raw::c_int);
}
extern "C" {
    pub fn rpmlogSetMask(mask: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmlog(code: ::std::os::raw::c_int,
                  fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn rpmlogMessage() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmlogCode() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmlogLevelPrefix(pri: rpmlogLvl) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmlogSetCallback(cb: rpmlogCallback, data: rpmlogCallbackData)
     -> rpmlogCallback;
}
extern "C" {
    pub fn rpmlogSetFile(fp: *mut FILE) -> *mut FILE;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rpmpolFlags_e { RPMPOL_FLAG_NONE = 0, RPMPOL_FLAG_BASE = 1, }
pub type rpmpolFlags = rpmFlags;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rpmSignArgs {
    pub keyid: *mut ::std::os::raw::c_char,
    pub hashalgo: pgpHashAlgo,
    pub signfiles: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_rpmSignArgs() {
    assert_eq!(::std::mem::size_of::<rpmSignArgs>() , 16usize , concat ! (
               "Size of: " , stringify ! ( rpmSignArgs ) ));
    assert_eq! (::std::mem::align_of::<rpmSignArgs>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rpmSignArgs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rpmSignArgs ) ) . keyid as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rpmSignArgs ) , "::" ,
                stringify ! ( keyid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rpmSignArgs ) ) . hashalgo as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rpmSignArgs ) , "::" ,
                stringify ! ( hashalgo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rpmSignArgs ) ) . signfiles as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( rpmSignArgs ) , "::" ,
                stringify ! ( signfiles ) ));
}
impl Clone for rpmSignArgs {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn rpmPkgSign(path: *const ::std::os::raw::c_char,
                      args: *const rpmSignArgs) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmPkgDelSign(path: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __sigismember(arg1: *const __sigset_t, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __sigaddset(arg1: *mut __sigset_t, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __sigdelset(arg1: *mut __sigset_t, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
pub type sig_atomic_t = __sig_atomic_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sigval {
    pub sival_int: __BindgenUnionField<::std::os::raw::c_int>,
    pub sival_ptr: __BindgenUnionField<*mut ::std::os::raw::c_void>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_sigval() {
    assert_eq!(::std::mem::size_of::<sigval>() , 8usize , concat ! (
               "Size of: " , stringify ! ( sigval ) ));
    assert_eq! (::std::mem::align_of::<sigval>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sigval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigval ) ) . sival_int as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigval ) , "::" ,
                stringify ! ( sival_int ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigval ) ) . sival_ptr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigval ) , "::" ,
                stringify ! ( sival_ptr ) ));
}
impl Clone for sigval {
    fn clone(&self) -> Self { *self }
}
pub type sigval_t = sigval;
pub type __sigchld_clock_t = __clock_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct siginfo_t {
    pub si_signo: ::std::os::raw::c_int,
    pub si_errno: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub _sifields: siginfo_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct siginfo_t__bindgen_ty_1 {
    pub _pad: __BindgenUnionField<[::std::os::raw::c_int; 28usize]>,
    pub _kill: __BindgenUnionField<siginfo_t__bindgen_ty_1__bindgen_ty_1>,
    pub _timer: __BindgenUnionField<siginfo_t__bindgen_ty_1__bindgen_ty_2>,
    pub _rt: __BindgenUnionField<siginfo_t__bindgen_ty_1__bindgen_ty_3>,
    pub _sigchld: __BindgenUnionField<siginfo_t__bindgen_ty_1__bindgen_ty_4>,
    pub _sigfault: __BindgenUnionField<siginfo_t__bindgen_ty_1__bindgen_ty_5>,
    pub _sigpoll: __BindgenUnionField<siginfo_t__bindgen_ty_1__bindgen_ty_6>,
    pub _sigsys: __BindgenUnionField<siginfo_t__bindgen_ty_1__bindgen_ty_7>,
    pub bindgen_union_field: [u64; 14usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_1 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_1>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               siginfo_t__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_1 ) )
                . si_pid as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! (
                si_pid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_1 ) )
                . si_uid as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! (
                si_uid ) ));
}
impl Clone for siginfo_t__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_2 {
    pub si_tid: ::std::os::raw::c_int,
    pub si_overrun: ::std::os::raw::c_int,
    pub si_sigval: sigval_t,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_2>()
               , 16usize , concat ! (
               "Size of: " , stringify ! (
               siginfo_t__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_2>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_2 ) )
                . si_tid as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify ! (
                si_tid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_2 ) )
                . si_overrun as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify ! (
                si_overrun ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_2 ) )
                . si_sigval as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify ! (
                si_sigval ) ));
}
impl Clone for siginfo_t__bindgen_ty_1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_3 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_sigval: sigval_t,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_3>()
               , 16usize , concat ! (
               "Size of: " , stringify ! (
               siginfo_t__bindgen_ty_1__bindgen_ty_3 ) ));
    assert_eq! (::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_3>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_3 ) )
                . si_pid as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_3 ) , "::" , stringify ! (
                si_pid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_3 ) )
                . si_uid as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_3 ) , "::" , stringify ! (
                si_uid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_3 ) )
                . si_sigval as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_3 ) , "::" , stringify ! (
                si_sigval ) ));
}
impl Clone for siginfo_t__bindgen_ty_1__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_4 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_status: ::std::os::raw::c_int,
    pub si_utime: __sigchld_clock_t,
    pub si_stime: __sigchld_clock_t,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_4>()
               , 32usize , concat ! (
               "Size of: " , stringify ! (
               siginfo_t__bindgen_ty_1__bindgen_ty_4 ) ));
    assert_eq! (::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_4>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_4 ) )
                . si_pid as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_4 ) , "::" , stringify ! (
                si_pid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_4 ) )
                . si_uid as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_4 ) , "::" , stringify ! (
                si_uid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_4 ) )
                . si_status as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_4 ) , "::" , stringify ! (
                si_status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_4 ) )
                . si_utime as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_4 ) , "::" , stringify ! (
                si_utime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_4 ) )
                . si_stime as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_4 ) , "::" , stringify ! (
                si_stime ) ));
}
impl Clone for siginfo_t__bindgen_ty_1__bindgen_ty_4 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_5 {
    pub si_addr: *mut ::std::os::raw::c_void,
    pub si_addr_lsb: ::std::os::raw::c_short,
    pub si_addr_bnd: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
    pub _lower: *mut ::std::os::raw::c_void,
    pub _upper: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>()
               , 16usize , concat ! (
               "Size of: " , stringify ! (
               siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 ) ) .
                _lower as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 ) , "::" ,
                stringify ! ( _lower ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 ) ) .
                _upper as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 ) , "::" ,
                stringify ! ( _upper ) ));
}
impl Clone for siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_5() {
    assert_eq!(::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5>()
               , 32usize , concat ! (
               "Size of: " , stringify ! (
               siginfo_t__bindgen_ty_1__bindgen_ty_5 ) ));
    assert_eq! (::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_5 ) )
                . si_addr as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_5 ) , "::" , stringify ! (
                si_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_5 ) )
                . si_addr_lsb as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_5 ) , "::" , stringify ! (
                si_addr_lsb ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_5 ) )
                . si_addr_bnd as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_5 ) , "::" , stringify ! (
                si_addr_bnd ) ));
}
impl Clone for siginfo_t__bindgen_ty_1__bindgen_ty_5 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_6 {
    pub si_band: ::std::os::raw::c_long,
    pub si_fd: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_6() {
    assert_eq!(::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_6>()
               , 16usize , concat ! (
               "Size of: " , stringify ! (
               siginfo_t__bindgen_ty_1__bindgen_ty_6 ) ));
    assert_eq! (::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_6>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_6 ) )
                . si_band as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_6 ) , "::" , stringify ! (
                si_band ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_6 ) )
                . si_fd as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_6 ) , "::" , stringify ! (
                si_fd ) ));
}
impl Clone for siginfo_t__bindgen_ty_1__bindgen_ty_6 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_7 {
    pub _call_addr: *mut ::std::os::raw::c_void,
    pub _syscall: ::std::os::raw::c_int,
    pub _arch: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_7() {
    assert_eq!(::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_7>()
               , 16usize , concat ! (
               "Size of: " , stringify ! (
               siginfo_t__bindgen_ty_1__bindgen_ty_7 ) ));
    assert_eq! (::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_7>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_7 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_7 ) )
                . _call_addr as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_7 ) , "::" , stringify ! (
                _call_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_7 ) )
                . _syscall as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_7 ) , "::" , stringify ! (
                _syscall ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1__bindgen_ty_7 ) )
                . _arch as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo_t__bindgen_ty_1__bindgen_ty_7 ) , "::" , stringify ! (
                _arch ) ));
}
impl Clone for siginfo_t__bindgen_ty_1__bindgen_ty_7 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<siginfo_t__bindgen_ty_1>() , 112usize ,
               concat ! (
               "Size of: " , stringify ! ( siginfo_t__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<siginfo_t__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( siginfo_t__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1 ) ) . _pad as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo_t__bindgen_ty_1
                ) , "::" , stringify ! ( _pad ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1 ) ) . _kill as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo_t__bindgen_ty_1
                ) , "::" , stringify ! ( _kill ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1 ) ) . _timer as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo_t__bindgen_ty_1
                ) , "::" , stringify ! ( _timer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1 ) ) . _rt as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo_t__bindgen_ty_1
                ) , "::" , stringify ! ( _rt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1 ) ) . _sigchld as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo_t__bindgen_ty_1
                ) , "::" , stringify ! ( _sigchld ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1 ) ) . _sigfault
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo_t__bindgen_ty_1
                ) , "::" , stringify ! ( _sigfault ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1 ) ) . _sigpoll as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo_t__bindgen_ty_1
                ) , "::" , stringify ! ( _sigpoll ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t__bindgen_ty_1 ) ) . _sigsys as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo_t__bindgen_ty_1
                ) , "::" , stringify ! ( _sigsys ) ));
}
impl Clone for siginfo_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_siginfo_t() {
    assert_eq!(::std::mem::size_of::<siginfo_t>() , 128usize , concat ! (
               "Size of: " , stringify ! ( siginfo_t ) ));
    assert_eq! (::std::mem::align_of::<siginfo_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( siginfo_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t ) ) . si_signo as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo_t ) , "::" ,
                stringify ! ( si_signo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t ) ) . si_errno as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo_t ) , "::" ,
                stringify ! ( si_errno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t ) ) . si_code as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo_t ) , "::" ,
                stringify ! ( si_code ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo_t ) ) . _sifields as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo_t ) , "::" ,
                stringify ! ( _sifields ) ));
}
impl Clone for siginfo_t {
    fn clone(&self) -> Self { *self }
}
pub const SI_ASYNCNL: _bindgen_ty_4 = _bindgen_ty_4::SI_ASYNCNL;
pub const SI_TKILL: _bindgen_ty_4 = _bindgen_ty_4::SI_TKILL;
pub const SI_SIGIO: _bindgen_ty_4 = _bindgen_ty_4::SI_SIGIO;
pub const SI_ASYNCIO: _bindgen_ty_4 = _bindgen_ty_4::SI_ASYNCIO;
pub const SI_MESGQ: _bindgen_ty_4 = _bindgen_ty_4::SI_MESGQ;
pub const SI_TIMER: _bindgen_ty_4 = _bindgen_ty_4::SI_TIMER;
pub const SI_QUEUE: _bindgen_ty_4 = _bindgen_ty_4::SI_QUEUE;
pub const SI_USER: _bindgen_ty_4 = _bindgen_ty_4::SI_USER;
pub const SI_KERNEL: _bindgen_ty_4 = _bindgen_ty_4::SI_KERNEL;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_4 {
    SI_ASYNCNL = -60,
    SI_TKILL = -6,
    SI_SIGIO = -5,
    SI_ASYNCIO = -4,
    SI_MESGQ = -3,
    SI_TIMER = -2,
    SI_QUEUE = -1,
    SI_USER = 0,
    SI_KERNEL = 128,
}
pub const ILL_ILLOPC: _bindgen_ty_5 = _bindgen_ty_5::ILL_ILLOPC;
pub const ILL_ILLOPN: _bindgen_ty_5 = _bindgen_ty_5::ILL_ILLOPN;
pub const ILL_ILLADR: _bindgen_ty_5 = _bindgen_ty_5::ILL_ILLADR;
pub const ILL_ILLTRP: _bindgen_ty_5 = _bindgen_ty_5::ILL_ILLTRP;
pub const ILL_PRVOPC: _bindgen_ty_5 = _bindgen_ty_5::ILL_PRVOPC;
pub const ILL_PRVREG: _bindgen_ty_5 = _bindgen_ty_5::ILL_PRVREG;
pub const ILL_COPROC: _bindgen_ty_5 = _bindgen_ty_5::ILL_COPROC;
pub const ILL_BADSTK: _bindgen_ty_5 = _bindgen_ty_5::ILL_BADSTK;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_5 {
    ILL_ILLOPC = 1,
    ILL_ILLOPN = 2,
    ILL_ILLADR = 3,
    ILL_ILLTRP = 4,
    ILL_PRVOPC = 5,
    ILL_PRVREG = 6,
    ILL_COPROC = 7,
    ILL_BADSTK = 8,
}
pub const FPE_INTDIV: _bindgen_ty_6 = _bindgen_ty_6::FPE_INTDIV;
pub const FPE_INTOVF: _bindgen_ty_6 = _bindgen_ty_6::FPE_INTOVF;
pub const FPE_FLTDIV: _bindgen_ty_6 = _bindgen_ty_6::FPE_FLTDIV;
pub const FPE_FLTOVF: _bindgen_ty_6 = _bindgen_ty_6::FPE_FLTOVF;
pub const FPE_FLTUND: _bindgen_ty_6 = _bindgen_ty_6::FPE_FLTUND;
pub const FPE_FLTRES: _bindgen_ty_6 = _bindgen_ty_6::FPE_FLTRES;
pub const FPE_FLTINV: _bindgen_ty_6 = _bindgen_ty_6::FPE_FLTINV;
pub const FPE_FLTSUB: _bindgen_ty_6 = _bindgen_ty_6::FPE_FLTSUB;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_6 {
    FPE_INTDIV = 1,
    FPE_INTOVF = 2,
    FPE_FLTDIV = 3,
    FPE_FLTOVF = 4,
    FPE_FLTUND = 5,
    FPE_FLTRES = 6,
    FPE_FLTINV = 7,
    FPE_FLTSUB = 8,
}
pub const SEGV_MAPERR: _bindgen_ty_7 = _bindgen_ty_7::SEGV_MAPERR;
pub const SEGV_ACCERR: _bindgen_ty_7 = _bindgen_ty_7::SEGV_ACCERR;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_7 { SEGV_MAPERR = 1, SEGV_ACCERR = 2, }
pub const BUS_ADRALN: _bindgen_ty_8 = _bindgen_ty_8::BUS_ADRALN;
pub const BUS_ADRERR: _bindgen_ty_8 = _bindgen_ty_8::BUS_ADRERR;
pub const BUS_OBJERR: _bindgen_ty_8 = _bindgen_ty_8::BUS_OBJERR;
pub const BUS_MCEERR_AR: _bindgen_ty_8 = _bindgen_ty_8::BUS_MCEERR_AR;
pub const BUS_MCEERR_AO: _bindgen_ty_8 = _bindgen_ty_8::BUS_MCEERR_AO;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_8 {
    BUS_ADRALN = 1,
    BUS_ADRERR = 2,
    BUS_OBJERR = 3,
    BUS_MCEERR_AR = 4,
    BUS_MCEERR_AO = 5,
}
pub const CLD_EXITED: _bindgen_ty_9 = _bindgen_ty_9::CLD_EXITED;
pub const CLD_KILLED: _bindgen_ty_9 = _bindgen_ty_9::CLD_KILLED;
pub const CLD_DUMPED: _bindgen_ty_9 = _bindgen_ty_9::CLD_DUMPED;
pub const CLD_TRAPPED: _bindgen_ty_9 = _bindgen_ty_9::CLD_TRAPPED;
pub const CLD_STOPPED: _bindgen_ty_9 = _bindgen_ty_9::CLD_STOPPED;
pub const CLD_CONTINUED: _bindgen_ty_9 = _bindgen_ty_9::CLD_CONTINUED;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_9 {
    CLD_EXITED = 1,
    CLD_KILLED = 2,
    CLD_DUMPED = 3,
    CLD_TRAPPED = 4,
    CLD_STOPPED = 5,
    CLD_CONTINUED = 6,
}
pub const POLL_IN: _bindgen_ty_10 = _bindgen_ty_10::POLL_IN;
pub const POLL_OUT: _bindgen_ty_10 = _bindgen_ty_10::POLL_OUT;
pub const POLL_MSG: _bindgen_ty_10 = _bindgen_ty_10::POLL_MSG;
pub const POLL_ERR: _bindgen_ty_10 = _bindgen_ty_10::POLL_ERR;
pub const POLL_PRI: _bindgen_ty_10 = _bindgen_ty_10::POLL_PRI;
pub const POLL_HUP: _bindgen_ty_10 = _bindgen_ty_10::POLL_HUP;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_10 {
    POLL_IN = 1,
    POLL_OUT = 2,
    POLL_MSG = 3,
    POLL_ERR = 4,
    POLL_PRI = 5,
    POLL_HUP = 6,
}
pub type sigevent_t = sigevent;
pub const SIGEV_SIGNAL: _bindgen_ty_11 = _bindgen_ty_11::SIGEV_SIGNAL;
pub const SIGEV_NONE: _bindgen_ty_11 = _bindgen_ty_11::SIGEV_NONE;
pub const SIGEV_THREAD: _bindgen_ty_11 = _bindgen_ty_11::SIGEV_THREAD;
pub const SIGEV_THREAD_ID: _bindgen_ty_11 = _bindgen_ty_11::SIGEV_THREAD_ID;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_11 {
    SIGEV_SIGNAL = 0,
    SIGEV_NONE = 1,
    SIGEV_THREAD = 2,
    SIGEV_THREAD_ID = 4,
}
pub type __sighandler_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
extern "C" {
    pub fn __sysv_signal(__sig: ::std::os::raw::c_int,
                         __handler: __sighandler_t) -> __sighandler_t;
}
extern "C" {
    pub fn signal(__sig: ::std::os::raw::c_int, __handler: __sighandler_t)
     -> __sighandler_t;
}
extern "C" {
    pub fn kill(__pid: __pid_t, __sig: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn killpg(__pgrp: __pid_t, __sig: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn raise(__sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ssignal(__sig: ::std::os::raw::c_int, __handler: __sighandler_t)
     -> __sighandler_t;
}
extern "C" {
    pub fn gsignal(__sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn psignal(__sig: ::std::os::raw::c_int,
                   __s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn psiginfo(__pinfo: *const siginfo_t,
                    __s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn sigblock(__mask: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigsetmask(__mask: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn siggetmask() -> ::std::os::raw::c_int;
}
pub type sig_t = __sighandler_t;
extern "C" {
    pub fn sigemptyset(__set: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigfillset(__set: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigaddset(__set: *mut sigset_t, __signo: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigdelset(__set: *mut sigset_t, __signo: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigismember(__set: *const sigset_t, __signo: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sigaction {
    pub __sigaction_handler: sigaction__bindgen_ty_1,
    pub sa_mask: __sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
    pub sa_restorer: ::std::option::Option<unsafe extern "C" fn()>,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sigaction__bindgen_ty_1 {
    pub sa_handler: __BindgenUnionField<__sighandler_t>,
    pub sa_sigaction: __BindgenUnionField<::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                         ::std::os::raw::c_int,
                                                                                     arg2:
                                                                                         *mut siginfo_t,
                                                                                     arg3:
                                                                                         *mut ::std::os::raw::c_void)>>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_sigaction__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<sigaction__bindgen_ty_1>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( sigaction__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<sigaction__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( sigaction__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigaction__bindgen_ty_1 ) ) . sa_handler
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigaction__bindgen_ty_1
                ) , "::" , stringify ! ( sa_handler ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigaction__bindgen_ty_1 ) ) .
                sa_sigaction as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigaction__bindgen_ty_1
                ) , "::" , stringify ! ( sa_sigaction ) ));
}
impl Clone for sigaction__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_sigaction() {
    assert_eq!(::std::mem::size_of::<sigaction>() , 152usize , concat ! (
               "Size of: " , stringify ! ( sigaction ) ));
    assert_eq! (::std::mem::align_of::<sigaction>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sigaction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigaction ) ) . __sigaction_handler as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigaction ) , "::" ,
                stringify ! ( __sigaction_handler ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigaction ) ) . sa_mask as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sigaction ) , "::" ,
                stringify ! ( sa_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigaction ) ) . sa_flags as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( sigaction ) , "::" ,
                stringify ! ( sa_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigaction ) ) . sa_restorer as * const _
                as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( sigaction ) , "::" ,
                stringify ! ( sa_restorer ) ));
}
impl Clone for sigaction {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn sigprocmask(__how: ::std::os::raw::c_int, __set: *const sigset_t,
                       __oset: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigsuspend(__set: *const sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigaction(__sig: ::std::os::raw::c_int, __act: *const sigaction,
                     __oact: *mut sigaction) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigpending(__set: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigwait(__set: *const sigset_t, __sig: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigwaitinfo(__set: *const sigset_t, __info: *mut siginfo_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigtimedwait(__set: *const sigset_t, __info: *mut siginfo_t,
                        __timeout: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigqueue(__pid: __pid_t, __sig: ::std::os::raw::c_int,
                    __val: sigval) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_sys_siglist"]
    pub static mut _sys_siglist: [*const ::std::os::raw::c_char; 65usize];
}
extern "C" {
    #[link_name = "sys_siglist"]
    pub static mut sys_siglist: [*const ::std::os::raw::c_char; 65usize];
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _fpx_sw_bytes {
    pub magic1: __uint32_t,
    pub extended_size: __uint32_t,
    pub xstate_bv: __uint64_t,
    pub xstate_size: __uint32_t,
    pub padding: [__uint32_t; 7usize],
}
#[test]
fn bindgen_test_layout__fpx_sw_bytes() {
    assert_eq!(::std::mem::size_of::<_fpx_sw_bytes>() , 48usize , concat ! (
               "Size of: " , stringify ! ( _fpx_sw_bytes ) ));
    assert_eq! (::std::mem::align_of::<_fpx_sw_bytes>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _fpx_sw_bytes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpx_sw_bytes ) ) . magic1 as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpx_sw_bytes ) , "::"
                , stringify ! ( magic1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpx_sw_bytes ) ) . extended_size as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpx_sw_bytes ) , "::"
                , stringify ! ( extended_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpx_sw_bytes ) ) . xstate_bv as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpx_sw_bytes ) , "::"
                , stringify ! ( xstate_bv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpx_sw_bytes ) ) . xstate_size as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpx_sw_bytes ) , "::"
                , stringify ! ( xstate_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpx_sw_bytes ) ) . padding as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpx_sw_bytes ) , "::"
                , stringify ! ( padding ) ));
}
impl Clone for _fpx_sw_bytes {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _fpreg {
    pub significand: [::std::os::raw::c_ushort; 4usize],
    pub exponent: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout__fpreg() {
    assert_eq!(::std::mem::size_of::<_fpreg>() , 10usize , concat ! (
               "Size of: " , stringify ! ( _fpreg ) ));
    assert_eq! (::std::mem::align_of::<_fpreg>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( _fpreg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpreg ) ) . significand as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpreg ) , "::" ,
                stringify ! ( significand ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpreg ) ) . exponent as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpreg ) , "::" ,
                stringify ! ( exponent ) ));
}
impl Clone for _fpreg {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _fpxreg {
    pub significand: [::std::os::raw::c_ushort; 4usize],
    pub exponent: ::std::os::raw::c_ushort,
    pub padding: [::std::os::raw::c_ushort; 3usize],
}
#[test]
fn bindgen_test_layout__fpxreg() {
    assert_eq!(::std::mem::size_of::<_fpxreg>() , 16usize , concat ! (
               "Size of: " , stringify ! ( _fpxreg ) ));
    assert_eq! (::std::mem::align_of::<_fpxreg>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( _fpxreg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpxreg ) ) . significand as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpxreg ) , "::" ,
                stringify ! ( significand ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpxreg ) ) . exponent as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpxreg ) , "::" ,
                stringify ! ( exponent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpxreg ) ) . padding as * const _ as
                usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpxreg ) , "::" ,
                stringify ! ( padding ) ));
}
impl Clone for _fpxreg {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _xmmreg {
    pub element: [__uint32_t; 4usize],
}
#[test]
fn bindgen_test_layout__xmmreg() {
    assert_eq!(::std::mem::size_of::<_xmmreg>() , 16usize , concat ! (
               "Size of: " , stringify ! ( _xmmreg ) ));
    assert_eq! (::std::mem::align_of::<_xmmreg>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( _xmmreg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _xmmreg ) ) . element as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _xmmreg ) , "::" ,
                stringify ! ( element ) ));
}
impl Clone for _xmmreg {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _fpstate {
    pub cwd: __uint16_t,
    pub swd: __uint16_t,
    pub ftw: __uint16_t,
    pub fop: __uint16_t,
    pub rip: __uint64_t,
    pub rdp: __uint64_t,
    pub mxcsr: __uint32_t,
    pub mxcr_mask: __uint32_t,
    pub _st: [_fpxreg; 8usize],
    pub _xmm: [_xmmreg; 16usize],
    pub padding: [__uint32_t; 24usize],
}
#[test]
fn bindgen_test_layout__fpstate() {
    assert_eq!(::std::mem::size_of::<_fpstate>() , 512usize , concat ! (
               "Size of: " , stringify ! ( _fpstate ) ));
    assert_eq! (::std::mem::align_of::<_fpstate>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _fpstate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpstate ) ) . cwd as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpstate ) , "::" ,
                stringify ! ( cwd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpstate ) ) . swd as * const _ as usize
                } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpstate ) , "::" ,
                stringify ! ( swd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpstate ) ) . ftw as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpstate ) , "::" ,
                stringify ! ( ftw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpstate ) ) . fop as * const _ as usize
                } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpstate ) , "::" ,
                stringify ! ( fop ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpstate ) ) . rip as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpstate ) , "::" ,
                stringify ! ( rip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpstate ) ) . rdp as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpstate ) , "::" ,
                stringify ! ( rdp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpstate ) ) . mxcsr as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpstate ) , "::" ,
                stringify ! ( mxcsr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpstate ) ) . mxcr_mask as * const _ as
                usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpstate ) , "::" ,
                stringify ! ( mxcr_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpstate ) ) . _st as * const _ as usize
                } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpstate ) , "::" ,
                stringify ! ( _st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpstate ) ) . _xmm as * const _ as usize
                } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpstate ) , "::" ,
                stringify ! ( _xmm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _fpstate ) ) . padding as * const _ as
                usize } , 416usize , concat ! (
                "Alignment of field: " , stringify ! ( _fpstate ) , "::" ,
                stringify ! ( padding ) ));
}
impl Clone for _fpstate {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sigcontext {
    pub r8: __uint64_t,
    pub r9: __uint64_t,
    pub r10: __uint64_t,
    pub r11: __uint64_t,
    pub r12: __uint64_t,
    pub r13: __uint64_t,
    pub r14: __uint64_t,
    pub r15: __uint64_t,
    pub rdi: __uint64_t,
    pub rsi: __uint64_t,
    pub rbp: __uint64_t,
    pub rbx: __uint64_t,
    pub rdx: __uint64_t,
    pub rax: __uint64_t,
    pub rcx: __uint64_t,
    pub rsp: __uint64_t,
    pub rip: __uint64_t,
    pub eflags: __uint64_t,
    pub cs: ::std::os::raw::c_ushort,
    pub gs: ::std::os::raw::c_ushort,
    pub fs: ::std::os::raw::c_ushort,
    pub __pad0: ::std::os::raw::c_ushort,
    pub err: __uint64_t,
    pub trapno: __uint64_t,
    pub oldmask: __uint64_t,
    pub cr2: __uint64_t,
    pub __bindgen_anon_1: sigcontext__bindgen_ty_1,
    pub __reserved1: [__uint64_t; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sigcontext__bindgen_ty_1 {
    pub fpstate: __BindgenUnionField<*mut _fpstate>,
    pub __fpstate_word: __BindgenUnionField<__uint64_t>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_sigcontext__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<sigcontext__bindgen_ty_1>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( sigcontext__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<sigcontext__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( sigcontext__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext__bindgen_ty_1 ) ) . fpstate as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                sigcontext__bindgen_ty_1 ) , "::" , stringify ! ( fpstate )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext__bindgen_ty_1 ) ) .
                __fpstate_word as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                sigcontext__bindgen_ty_1 ) , "::" , stringify ! (
                __fpstate_word ) ));
}
impl Clone for sigcontext__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_sigcontext() {
    assert_eq!(::std::mem::size_of::<sigcontext>() , 256usize , concat ! (
               "Size of: " , stringify ! ( sigcontext ) ));
    assert_eq! (::std::mem::align_of::<sigcontext>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sigcontext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . r8 as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( r8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . r9 as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( r9 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . r10 as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( r10 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . r11 as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( r11 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . r12 as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( r12 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . r13 as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( r13 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . r14 as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( r14 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . r15 as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( r15 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . rdi as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( rdi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . rsi as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( rsi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . rbp as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( rbp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . rbx as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( rbx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . rdx as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( rdx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . rax as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( rax ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . rcx as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( rcx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . rsp as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( rsp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . rip as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( rip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . eflags as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( eflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . cs as * const _ as usize
                } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( cs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . gs as * const _ as usize
                } , 146usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( gs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . fs as * const _ as usize
                } , 148usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( fs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . __pad0 as * const _ as
                usize } , 150usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( __pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . err as * const _ as
                usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( err ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . trapno as * const _ as
                usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( trapno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . oldmask as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( oldmask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . cr2 as * const _ as
                usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( cr2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . __reserved1 as * const _
                as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( __reserved1 ) ));
}
impl Clone for sigcontext {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _xsave_hdr {
    pub xstate_bv: __uint64_t,
    pub reserved1: [__uint64_t; 2usize],
    pub reserved2: [__uint64_t; 5usize],
}
#[test]
fn bindgen_test_layout__xsave_hdr() {
    assert_eq!(::std::mem::size_of::<_xsave_hdr>() , 64usize , concat ! (
               "Size of: " , stringify ! ( _xsave_hdr ) ));
    assert_eq! (::std::mem::align_of::<_xsave_hdr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _xsave_hdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _xsave_hdr ) ) . xstate_bv as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _xsave_hdr ) , "::" ,
                stringify ! ( xstate_bv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _xsave_hdr ) ) . reserved1 as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _xsave_hdr ) , "::" ,
                stringify ! ( reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _xsave_hdr ) ) . reserved2 as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _xsave_hdr ) , "::" ,
                stringify ! ( reserved2 ) ));
}
impl Clone for _xsave_hdr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct _ymmh_state {
    pub ymmh_space: [__uint32_t; 64usize],
}
#[test]
fn bindgen_test_layout__ymmh_state() {
    assert_eq!(::std::mem::size_of::<_ymmh_state>() , 256usize , concat ! (
               "Size of: " , stringify ! ( _ymmh_state ) ));
    assert_eq! (::std::mem::align_of::<_ymmh_state>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( _ymmh_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _ymmh_state ) ) . ymmh_space as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _ymmh_state ) , "::" ,
                stringify ! ( ymmh_space ) ));
}
#[repr(C)]
pub struct _xstate {
    pub fpstate: _fpstate,
    pub xstate_hdr: _xsave_hdr,
    pub ymmh: _ymmh_state,
}
#[test]
fn bindgen_test_layout__xstate() {
    assert_eq!(::std::mem::size_of::<_xstate>() , 832usize , concat ! (
               "Size of: " , stringify ! ( _xstate ) ));
    assert_eq! (::std::mem::align_of::<_xstate>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _xstate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _xstate ) ) . fpstate as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _xstate ) , "::" ,
                stringify ! ( fpstate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _xstate ) ) . xstate_hdr as * const _ as
                usize } , 512usize , concat ! (
                "Alignment of field: " , stringify ! ( _xstate ) , "::" ,
                stringify ! ( xstate_hdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _xstate ) ) . ymmh as * const _ as usize
                } , 576usize , concat ! (
                "Alignment of field: " , stringify ! ( _xstate ) , "::" ,
                stringify ! ( ymmh ) ));
}
extern "C" {
    pub fn sigreturn(__scp: *mut sigcontext) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn siginterrupt(__sig: ::std::os::raw::c_int,
                        __interrupt: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sigstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_onstack: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigstack() {
    assert_eq!(::std::mem::size_of::<sigstack>() , 16usize , concat ! (
               "Size of: " , stringify ! ( sigstack ) ));
    assert_eq! (::std::mem::align_of::<sigstack>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sigstack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigstack ) ) . ss_sp as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigstack ) , "::" ,
                stringify ! ( ss_sp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigstack ) ) . ss_onstack as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sigstack ) , "::" ,
                stringify ! ( ss_onstack ) ));
}
impl Clone for sigstack {
    fn clone(&self) -> Self { *self }
}
pub const SS_ONSTACK: _bindgen_ty_12 = _bindgen_ty_12::SS_ONSTACK;
pub const SS_DISABLE: _bindgen_ty_12 = _bindgen_ty_12::SS_DISABLE;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_12 { SS_ONSTACK = 1, SS_DISABLE = 2, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sigaltstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_flags: ::std::os::raw::c_int,
    pub ss_size: usize,
}
#[test]
fn bindgen_test_layout_sigaltstack() {
    assert_eq!(::std::mem::size_of::<sigaltstack>() , 24usize , concat ! (
               "Size of: " , stringify ! ( sigaltstack ) ));
    assert_eq! (::std::mem::align_of::<sigaltstack>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sigaltstack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigaltstack ) ) . ss_sp as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigaltstack ) , "::" ,
                stringify ! ( ss_sp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigaltstack ) ) . ss_flags as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sigaltstack ) , "::" ,
                stringify ! ( ss_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigaltstack ) ) . ss_size as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( sigaltstack ) , "::" ,
                stringify ! ( ss_size ) ));
}
impl Clone for sigaltstack {
    fn clone(&self) -> Self { *self }
}
pub type stack_t = sigaltstack;
pub type greg_t = ::std::os::raw::c_longlong;
pub type gregset_t = [greg_t; 23usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _libc_fpxreg {
    pub significand: [::std::os::raw::c_ushort; 4usize],
    pub exponent: ::std::os::raw::c_ushort,
    pub padding: [::std::os::raw::c_ushort; 3usize],
}
#[test]
fn bindgen_test_layout__libc_fpxreg() {
    assert_eq!(::std::mem::size_of::<_libc_fpxreg>() , 16usize , concat ! (
               "Size of: " , stringify ! ( _libc_fpxreg ) ));
    assert_eq! (::std::mem::align_of::<_libc_fpxreg>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( _libc_fpxreg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _libc_fpxreg ) ) . significand as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _libc_fpxreg ) , "::" ,
                stringify ! ( significand ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _libc_fpxreg ) ) . exponent as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _libc_fpxreg ) , "::" ,
                stringify ! ( exponent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _libc_fpxreg ) ) . padding as * const _
                as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( _libc_fpxreg ) , "::" ,
                stringify ! ( padding ) ));
}
impl Clone for _libc_fpxreg {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _libc_xmmreg {
    pub element: [__uint32_t; 4usize],
}
#[test]
fn bindgen_test_layout__libc_xmmreg() {
    assert_eq!(::std::mem::size_of::<_libc_xmmreg>() , 16usize , concat ! (
               "Size of: " , stringify ! ( _libc_xmmreg ) ));
    assert_eq! (::std::mem::align_of::<_libc_xmmreg>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( _libc_xmmreg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _libc_xmmreg ) ) . element as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _libc_xmmreg ) , "::" ,
                stringify ! ( element ) ));
}
impl Clone for _libc_xmmreg {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _libc_fpstate {
    pub cwd: __uint16_t,
    pub swd: __uint16_t,
    pub ftw: __uint16_t,
    pub fop: __uint16_t,
    pub rip: __uint64_t,
    pub rdp: __uint64_t,
    pub mxcsr: __uint32_t,
    pub mxcr_mask: __uint32_t,
    pub _st: [_libc_fpxreg; 8usize],
    pub _xmm: [_libc_xmmreg; 16usize],
    pub padding: [__uint32_t; 24usize],
}
#[test]
fn bindgen_test_layout__libc_fpstate() {
    assert_eq!(::std::mem::size_of::<_libc_fpstate>() , 512usize , concat ! (
               "Size of: " , stringify ! ( _libc_fpstate ) ));
    assert_eq! (::std::mem::align_of::<_libc_fpstate>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _libc_fpstate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _libc_fpstate ) ) . cwd as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _libc_fpstate ) , "::"
                , stringify ! ( cwd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _libc_fpstate ) ) . swd as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( _libc_fpstate ) , "::"
                , stringify ! ( swd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _libc_fpstate ) ) . ftw as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _libc_fpstate ) , "::"
                , stringify ! ( ftw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _libc_fpstate ) ) . fop as * const _ as
                usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( _libc_fpstate ) , "::"
                , stringify ! ( fop ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _libc_fpstate ) ) . rip as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _libc_fpstate ) , "::"
                , stringify ! ( rip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _libc_fpstate ) ) . rdp as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _libc_fpstate ) , "::"
                , stringify ! ( rdp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _libc_fpstate ) ) . mxcsr as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _libc_fpstate ) , "::"
                , stringify ! ( mxcsr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _libc_fpstate ) ) . mxcr_mask as * const
                _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( _libc_fpstate ) , "::"
                , stringify ! ( mxcr_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _libc_fpstate ) ) . _st as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _libc_fpstate ) , "::"
                , stringify ! ( _st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _libc_fpstate ) ) . _xmm as * const _ as
                usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( _libc_fpstate ) , "::"
                , stringify ! ( _xmm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _libc_fpstate ) ) . padding as * const _
                as usize } , 416usize , concat ! (
                "Alignment of field: " , stringify ! ( _libc_fpstate ) , "::"
                , stringify ! ( padding ) ));
}
impl Clone for _libc_fpstate {
    fn clone(&self) -> Self { *self }
}
pub type fpregset_t = *mut _libc_fpstate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mcontext_t {
    pub gregs: gregset_t,
    pub fpregs: fpregset_t,
    pub __reserved1: [::std::os::raw::c_ulonglong; 8usize],
}
#[test]
fn bindgen_test_layout_mcontext_t() {
    assert_eq!(::std::mem::size_of::<mcontext_t>() , 256usize , concat ! (
               "Size of: " , stringify ! ( mcontext_t ) ));
    assert_eq! (::std::mem::align_of::<mcontext_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( mcontext_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mcontext_t ) ) . gregs as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mcontext_t ) , "::" ,
                stringify ! ( gregs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mcontext_t ) ) . fpregs as * const _ as
                usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( mcontext_t ) , "::" ,
                stringify ! ( fpregs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mcontext_t ) ) . __reserved1 as * const _
                as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( mcontext_t ) , "::" ,
                stringify ! ( __reserved1 ) ));
}
impl Clone for mcontext_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ucontext {
    pub uc_flags: ::std::os::raw::c_ulong,
    pub uc_link: *mut ucontext,
    pub uc_stack: stack_t,
    pub uc_mcontext: mcontext_t,
    pub uc_sigmask: __sigset_t,
    pub __fpregs_mem: _libc_fpstate,
}
#[test]
fn bindgen_test_layout_ucontext() {
    assert_eq!(::std::mem::size_of::<ucontext>() , 936usize , concat ! (
               "Size of: " , stringify ! ( ucontext ) ));
    assert_eq! (::std::mem::align_of::<ucontext>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ucontext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ucontext ) ) . uc_flags as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ucontext ) , "::" ,
                stringify ! ( uc_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ucontext ) ) . uc_link as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ucontext ) , "::" ,
                stringify ! ( uc_link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ucontext ) ) . uc_stack as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ucontext ) , "::" ,
                stringify ! ( uc_stack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ucontext ) ) . uc_mcontext as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( ucontext ) , "::" ,
                stringify ! ( uc_mcontext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ucontext ) ) . uc_sigmask as * const _ as
                usize } , 296usize , concat ! (
                "Alignment of field: " , stringify ! ( ucontext ) , "::" ,
                stringify ! ( uc_sigmask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ucontext ) ) . __fpregs_mem as * const _
                as usize } , 424usize , concat ! (
                "Alignment of field: " , stringify ! ( ucontext ) , "::" ,
                stringify ! ( __fpregs_mem ) ));
}
impl Clone for ucontext {
    fn clone(&self) -> Self { *self }
}
pub type ucontext_t = ucontext;
extern "C" {
    pub fn sigstack(__ss: *mut sigstack, __oss: *mut sigstack)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigaltstack(__ss: *const sigaltstack, __oss: *mut sigaltstack)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_sigmask(__how: ::std::os::raw::c_int,
                           __newmask: *const __sigset_t,
                           __oldmask: *mut __sigset_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_kill(__threadid: pthread_t, __signo: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __libc_current_sigrtmin() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __libc_current_sigrtmax() -> ::std::os::raw::c_int;
}
pub type rpmsqAction_t =
    ::std::option::Option<unsafe extern "C" fn(signum: ::std::os::raw::c_int,
                                               info: *mut siginfo_t,
                                               context:
                                                   *mut ::std::os::raw::c_void)>;
extern "C" {
    pub fn rpmsqIsCaught(signum: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmsqAction(signum: ::std::os::raw::c_int, info: *mut siginfo_t,
                       context: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn rpmsqEnable(signum: ::std::os::raw::c_int, handler: rpmsqAction_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmsqSetInterruptSafety(on: ::std::os::raw::c_int);
}
extern "C" {
    pub fn rpmstrPoolCreate() -> rpmstrPool;
}
extern "C" {
    pub fn rpmstrPoolFree(pool: rpmstrPool) -> rpmstrPool;
}
extern "C" {
    pub fn rpmstrPoolLink(pool: rpmstrPool) -> rpmstrPool;
}
extern "C" {
    pub fn rpmstrPoolFreeze(pool: rpmstrPool,
                            keephash: ::std::os::raw::c_int);
}
extern "C" {
    pub fn rpmstrPoolUnfreeze(pool: rpmstrPool);
}
extern "C" {
    pub fn rpmstrPoolId(pool: rpmstrPool, s: *const ::std::os::raw::c_char,
                        create: ::std::os::raw::c_int) -> rpmsid;
}
extern "C" {
    pub fn rpmstrPoolIdn(pool: rpmstrPool, s: *const ::std::os::raw::c_char,
                         slen: usize, create: ::std::os::raw::c_int)
     -> rpmsid;
}
extern "C" {
    pub fn rpmstrPoolStr(pool: rpmstrPool, sid: rpmsid)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rpmstrPoolStrlen(pool: rpmstrPool, sid: rpmsid) -> usize;
}
extern "C" {
    pub fn rpmstrPoolStreq(poolA: rpmstrPool, sidA: rpmsid, poolB: rpmstrPool,
                           sidB: rpmsid) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmstrPoolNumStr(pool: rpmstrPool) -> rpmsid;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(::std::mem::size_of::<__va_list_tag>() , 24usize , concat ! (
               "Size of: " , stringify ! ( __va_list_tag ) ));
    assert_eq! (::std::mem::align_of::<__va_list_tag>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __va_list_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . gp_offset as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( gp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . fp_offset as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( fp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . overflow_arg_area as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( overflow_arg_area ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . reg_save_area as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( reg_save_area ) ));
}
impl Clone for __va_list_tag {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __locale_data {
    pub _address: u8,
}
impl Clone for __locale_data {
    fn clone(&self) -> Self { *self }
}
